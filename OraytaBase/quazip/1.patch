diff -ruN ./CMakeFiles/CMakeDirectoryInformation.cmake ../../dep/quazip/quazip/CMakeFiles/CMakeDirectoryInformation.cmake
--- ./CMakeFiles/CMakeDirectoryInformation.cmake	1970-01-01 02:00:00.000000000 +0200
+++ ../../dep/quazip/quazip/CMakeFiles/CMakeDirectoryInformation.cmake	2020-11-27 04:08:37.015850049 +0200
@@ -0,0 +1,16 @@
+# CMAKE generated file: DO NOT EDIT!
+# Generated by "Unix Makefiles" Generator, CMake Version 3.19
+
+# Relative path conversion top directories.
+set(CMAKE_RELATIVE_PATH_TOP_SOURCE "/home/dash/dev/Orayta-QT/dep/quazip")
+set(CMAKE_RELATIVE_PATH_TOP_BINARY "/home/dash/dev/Orayta-QT/dep/quazip")
+
+# Force unix paths in dependencies.
+set(CMAKE_FORCE_UNIX_PATHS 1)
+
+
+# The C and CXX include file regular expressions for this directory.
+set(CMAKE_C_INCLUDE_REGEX_SCAN "^.*$")
+set(CMAKE_C_INCLUDE_REGEX_COMPLAIN "^$")
+set(CMAKE_CXX_INCLUDE_REGEX_SCAN ${CMAKE_C_INCLUDE_REGEX_SCAN})
+set(CMAKE_CXX_INCLUDE_REGEX_COMPLAIN ${CMAKE_C_INCLUDE_REGEX_COMPLAIN})
diff -ruN ./CMakeFiles/Export/lib/cmake/QuaZip-Qt5-1.1/QuaZip-Qt5_SharedTargets.cmake ../../dep/quazip/quazip/CMakeFiles/Export/lib/cmake/QuaZip-Qt5-1.1/QuaZip-Qt5_SharedTargets.cmake
--- ./CMakeFiles/Export/lib/cmake/QuaZip-Qt5-1.1/QuaZip-Qt5_SharedTargets.cmake	1970-01-01 02:00:00.000000000 +0200
+++ ../../dep/quazip/quazip/CMakeFiles/Export/lib/cmake/QuaZip-Qt5-1.1/QuaZip-Qt5_SharedTargets.cmake	2020-11-27 04:08:37.015850049 +0200
@@ -0,0 +1,99 @@
+# Generated by CMake
+
+if("${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION}" LESS 2.5)
+   message(FATAL_ERROR "CMake >= 2.6.0 required")
+endif()
+cmake_policy(PUSH)
+cmake_policy(VERSION 2.6...3.17)
+#----------------------------------------------------------------
+# Generated CMake target import file.
+#----------------------------------------------------------------
+
+# Commands may need to know the format version.
+set(CMAKE_IMPORT_FILE_VERSION 1)
+
+# Protect against multiple inclusion, which would fail when already imported targets are added once more.
+set(_targetsDefined)
+set(_targetsNotDefined)
+set(_expectedTargets)
+foreach(_expectedTarget QuaZip::QuaZip)
+  list(APPEND _expectedTargets ${_expectedTarget})
+  if(NOT TARGET ${_expectedTarget})
+    list(APPEND _targetsNotDefined ${_expectedTarget})
+  endif()
+  if(TARGET ${_expectedTarget})
+    list(APPEND _targetsDefined ${_expectedTarget})
+  endif()
+endforeach()
+if("${_targetsDefined}" STREQUAL "${_expectedTargets}")
+  unset(_targetsDefined)
+  unset(_targetsNotDefined)
+  unset(_expectedTargets)
+  set(CMAKE_IMPORT_FILE_VERSION)
+  cmake_policy(POP)
+  return()
+endif()
+if(NOT "${_targetsDefined}" STREQUAL "")
+  message(FATAL_ERROR "Some (but not all) targets in this export set were already defined.\nTargets Defined: ${_targetsDefined}\nTargets not yet defined: ${_targetsNotDefined}\n")
+endif()
+unset(_targetsDefined)
+unset(_targetsNotDefined)
+unset(_expectedTargets)
+
+
+# Compute the installation prefix relative to this file.
+get_filename_component(_IMPORT_PREFIX "${CMAKE_CURRENT_LIST_FILE}" PATH)
+get_filename_component(_IMPORT_PREFIX "${_IMPORT_PREFIX}" PATH)
+get_filename_component(_IMPORT_PREFIX "${_IMPORT_PREFIX}" PATH)
+get_filename_component(_IMPORT_PREFIX "${_IMPORT_PREFIX}" PATH)
+if(_IMPORT_PREFIX STREQUAL "/")
+  set(_IMPORT_PREFIX "")
+endif()
+
+# Create imported target QuaZip::QuaZip
+add_library(QuaZip::QuaZip SHARED IMPORTED)
+
+set_target_properties(QuaZip::QuaZip PROPERTIES
+  INTERFACE_INCLUDE_DIRECTORIES "${_IMPORT_PREFIX}/include/QuaZip-Qt5-1.1;${_IMPORT_PREFIX}/include/QuaZip-Qt5-1.1/quazip"
+  INTERFACE_LINK_LIBRARIES "Qt5::Core;ZLIB::ZLIB"
+)
+
+if(CMAKE_VERSION VERSION_LESS 2.8.12)
+  message(FATAL_ERROR "This file relies on consumers using CMake 2.8.12 or greater.")
+endif()
+
+# Load information for each installed configuration.
+get_filename_component(_DIR "${CMAKE_CURRENT_LIST_FILE}" PATH)
+file(GLOB CONFIG_FILES "${_DIR}/QuaZip-Qt5_SharedTargets-*.cmake")
+foreach(f ${CONFIG_FILES})
+  include(${f})
+endforeach()
+
+# Cleanup temporary variables.
+set(_IMPORT_PREFIX)
+
+# Loop over all imported files and verify that they actually exist
+foreach(target ${_IMPORT_CHECK_TARGETS} )
+  foreach(file ${_IMPORT_CHECK_FILES_FOR_${target}} )
+    if(NOT EXISTS "${file}" )
+      message(FATAL_ERROR "The imported target \"${target}\" references the file
+   \"${file}\"
+but this file does not exist.  Possible reasons include:
+* The file was deleted, renamed, or moved to another location.
+* An install or uninstall procedure did not complete successfully.
+* The installation package was faulty and contained
+   \"${CMAKE_CURRENT_LIST_FILE}\"
+but not all the files it references.
+")
+    endif()
+  endforeach()
+  unset(_IMPORT_CHECK_FILES_FOR_${target})
+endforeach()
+unset(_IMPORT_CHECK_TARGETS)
+
+# This file does not depend on other imported targets which have
+# been exported from the same project but in a separate export set.
+
+# Commands beyond this point should not need to know the version.
+set(CMAKE_IMPORT_FILE_VERSION)
+cmake_policy(POP)
diff -ruN ./CMakeFiles/Export/lib/cmake/QuaZip-Qt5-1.1/QuaZip-Qt5_SharedTargets-release.cmake ../../dep/quazip/quazip/CMakeFiles/Export/lib/cmake/QuaZip-Qt5-1.1/QuaZip-Qt5_SharedTargets-release.cmake
--- ./CMakeFiles/Export/lib/cmake/QuaZip-Qt5-1.1/QuaZip-Qt5_SharedTargets-release.cmake	1970-01-01 02:00:00.000000000 +0200
+++ ../../dep/quazip/quazip/CMakeFiles/Export/lib/cmake/QuaZip-Qt5-1.1/QuaZip-Qt5_SharedTargets-release.cmake	2020-11-27 04:08:37.015850049 +0200
@@ -0,0 +1,19 @@
+#----------------------------------------------------------------
+# Generated CMake target import file for configuration "RELEASE".
+#----------------------------------------------------------------
+
+# Commands may need to know the format version.
+set(CMAKE_IMPORT_FILE_VERSION 1)
+
+# Import target "QuaZip::QuaZip" for configuration "RELEASE"
+set_property(TARGET QuaZip::QuaZip APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(QuaZip::QuaZip PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/lib/libquazip1-qt5.so.1.1"
+  IMPORTED_SONAME_RELEASE "libquazip1-qt5.so.1.0.0"
+  )
+
+list(APPEND _IMPORT_CHECK_TARGETS QuaZip::QuaZip )
+list(APPEND _IMPORT_CHECK_FILES_FOR_QuaZip::QuaZip "${_IMPORT_PREFIX}/lib/libquazip1-qt5.so.1.1" )
+
+# Commands beyond this point should not need to know the version.
+set(CMAKE_IMPORT_FILE_VERSION)
diff -ruN ./CMakeFiles/progress.marks ../../dep/quazip/quazip/CMakeFiles/progress.marks
--- ./CMakeFiles/progress.marks	1970-01-01 02:00:00.000000000 +0200
+++ ../../dep/quazip/quazip/CMakeFiles/progress.marks	2020-11-27 04:08:37.019183382 +0200
@@ -0,0 +1 @@
+17
diff -ruN ./CMakeFiles/QuaZip_autogen.dir/AutogenInfo.json ../../dep/quazip/quazip/CMakeFiles/QuaZip_autogen.dir/AutogenInfo.json
--- ./CMakeFiles/QuaZip_autogen.dir/AutogenInfo.json	1970-01-01 02:00:00.000000000 +0200
+++ ../../dep/quazip/quazip/CMakeFiles/QuaZip_autogen.dir/AutogenInfo.json	2020-11-27 04:08:37.009183382 +0200
@@ -0,0 +1,174 @@
+{
+	"BUILD_DIR" : "/home/dash/dev/Orayta-QT/dep/quazip/quazip/QuaZip_autogen",
+	"CMAKE_BINARY_DIR" : "/home/dash/dev/Orayta-QT/dep/quazip",
+	"CMAKE_CURRENT_BINARY_DIR" : "/home/dash/dev/Orayta-QT/dep/quazip/quazip",
+	"CMAKE_CURRENT_SOURCE_DIR" : "/home/dash/dev/Orayta-QT/dep/quazip/quazip",
+	"CMAKE_EXECUTABLE" : "/usr/bin/cmake",
+	"CMAKE_LIST_FILES" : 
+	[
+		"/home/dash/dev/Orayta-QT/dep/quazip/quazip/CMakeLists.txt",
+		"/usr/share/cmake-3.19/Modules/GNUInstallDirs.cmake",
+		"/usr/share/cmake-3.19/Modules/CMakePackageConfigHelpers.cmake",
+		"/usr/share/cmake-3.19/Modules/WriteBasicConfigVersionFile.cmake",
+		"/usr/share/cmake-3.19/Modules/BasicConfigVersion-SameMajorVersion.cmake.in",
+		"/home/dash/dev/Orayta-QT/dep/quazip/quazip/QuaZipConfig.cmake.in",
+		"/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip.pc.cmakein"
+	],
+	"CMAKE_SOURCE_DIR" : "/home/dash/dev/Orayta-QT/dep/quazip",
+	"DEP_FILE" : "",
+	"DEP_FILE_RULE_NAME" : "",
+	"HEADERS" : 
+	[
+		[
+			"/home/dash/dev/Orayta-QT/dep/quazip/quazip/JlCompress.h",
+			"Mu",
+			"EWIEGA46WW/moc_JlCompress.cpp"
+		],
+		[
+			"/home/dash/dev/Orayta-QT/dep/quazip/quazip/ioapi.h",
+			"Mu",
+			"EWIEGA46WW/moc_ioapi.cpp"
+		],
+		[
+			"/home/dash/dev/Orayta-QT/dep/quazip/quazip/minizip_crypt.h",
+			"Mu",
+			"EWIEGA46WW/moc_minizip_crypt.cpp"
+		],
+		[
+			"/home/dash/dev/Orayta-QT/dep/quazip/quazip/quaadler32.h",
+			"Mu",
+			"EWIEGA46WW/moc_quaadler32.cpp"
+		],
+		[
+			"/home/dash/dev/Orayta-QT/dep/quazip/quazip/quachecksum32.h",
+			"Mu",
+			"EWIEGA46WW/moc_quachecksum32.cpp"
+		],
+		[
+			"/home/dash/dev/Orayta-QT/dep/quazip/quazip/quacrc32.h",
+			"Mu",
+			"EWIEGA46WW/moc_quacrc32.cpp"
+		],
+		[
+			"/home/dash/dev/Orayta-QT/dep/quazip/quazip/quagzipfile.h",
+			"Mu",
+			"EWIEGA46WW/moc_quagzipfile.cpp"
+		],
+		[
+			"/home/dash/dev/Orayta-QT/dep/quazip/quazip/quaziodevice.h",
+			"Mu",
+			"EWIEGA46WW/moc_quaziodevice.cpp"
+		],
+		[
+			"/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip.h",
+			"Mu",
+			"EWIEGA46WW/moc_quazip.cpp"
+		],
+		[
+			"/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip_global.h",
+			"Mu",
+			"EWIEGA46WW/moc_quazip_global.cpp"
+		],
+		[
+			"/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip_qt_compat.h",
+			"Mu",
+			"EWIEGA46WW/moc_quazip_qt_compat.cpp"
+		],
+		[
+			"/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipdir.h",
+			"Mu",
+			"EWIEGA46WW/moc_quazipdir.cpp"
+		],
+		[
+			"/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipfile.h",
+			"Mu",
+			"EWIEGA46WW/moc_quazipfile.cpp"
+		],
+		[
+			"/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipfileinfo.h",
+			"Mu",
+			"EWIEGA46WW/moc_quazipfileinfo.cpp"
+		],
+		[
+			"/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipnewinfo.h",
+			"Mu",
+			"EWIEGA46WW/moc_quazipnewinfo.cpp"
+		],
+		[
+			"/home/dash/dev/Orayta-QT/dep/quazip/quazip/unzip.h",
+			"Mu",
+			"EWIEGA46WW/moc_unzip.cpp"
+		],
+		[
+			"/home/dash/dev/Orayta-QT/dep/quazip/quazip/zip.h",
+			"Mu",
+			"EWIEGA46WW/moc_zip.cpp"
+		]
+	],
+	"HEADER_EXTENSIONS" : [ "h", "hh", "h++", "hm", "hpp", "hxx", "in", "txx" ],
+	"INCLUDE_DIR" : "/home/dash/dev/Orayta-QT/dep/quazip/quazip/QuaZip_autogen/include",
+	"MOC_COMPILATION_FILE" : "/home/dash/dev/Orayta-QT/dep/quazip/quazip/QuaZip_autogen/mocs_compilation.cpp",
+	"MOC_DEFINITIONS" : [ "QT_CORE_LIB", "QT_NO_DEBUG", "QUAZIP_BUILD", "QuaZip_EXPORTS" ],
+	"MOC_DEPEND_FILTERS" : 
+	[
+		[
+			"Q_PLUGIN_METADATA",
+			"[\n][ \t]*Q_PLUGIN_METADATA[ \t]*\\([^\\)]*FILE[ \t]*\"([^\"]+)\""
+		]
+	],
+	"MOC_INCLUDES" : 
+	[
+		"/home/dash/dev/Orayta-QT/dep/quazip/quazip",
+		"/home/dash/dev/Orayta-QT/dep/quazip",
+		"/usr/include/qt",
+		"/usr/include/qt/QtCore",
+		"/usr/lib/qt/mkspecs/linux-g++",
+		"/usr/include",
+		"/usr/include/c++/10.2.0",
+		"/usr/include/c++/10.2.0/x86_64-pc-linux-gnu",
+		"/usr/include/c++/10.2.0/backward",
+		"/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include",
+		"/usr/local/include",
+		"/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include-fixed"
+	],
+	"MOC_MACRO_NAMES" : [ "Q_OBJECT", "Q_GADGET", "Q_NAMESPACE", "Q_NAMESPACE_EXPORT" ],
+	"MOC_OPTIONS" : [],
+	"MOC_PATH_PREFIX" : false,
+	"MOC_PREDEFS_CMD" : 
+	[
+		"/usr/bin/c++",
+		"-dM",
+		"-E",
+		"-c",
+		"/usr/share/cmake-3.19/Modules/CMakeCXXCompilerABI.cpp"
+	],
+	"MOC_PREDEFS_FILE" : "/home/dash/dev/Orayta-QT/dep/quazip/quazip/QuaZip_autogen/moc_predefs.h",
+	"MOC_RELAXED_MODE" : false,
+	"MOC_SKIP" : [],
+	"MULTI_CONFIG" : false,
+	"PARALLEL" : 12,
+	"PARSE_CACHE_FILE" : "/home/dash/dev/Orayta-QT/dep/quazip/quazip/CMakeFiles/QuaZip_autogen.dir/ParseCache.txt",
+	"QT_MOC_EXECUTABLE" : "/usr/bin/moc",
+	"QT_UIC_EXECUTABLE" : "",
+	"QT_VERSION_MAJOR" : 5,
+	"QT_VERSION_MINOR" : 15,
+	"SETTINGS_FILE" : "/home/dash/dev/Orayta-QT/dep/quazip/quazip/CMakeFiles/QuaZip_autogen.dir/AutogenUsed.txt",
+	"SOURCES" : 
+	[
+		[ "/home/dash/dev/Orayta-QT/dep/quazip/quazip/JlCompress.cpp", "Mu" ],
+		[ "/home/dash/dev/Orayta-QT/dep/quazip/quazip/qioapi.cpp", "Mu" ],
+		[ "/home/dash/dev/Orayta-QT/dep/quazip/quazip/quaadler32.cpp", "Mu" ],
+		[ "/home/dash/dev/Orayta-QT/dep/quazip/quazip/quachecksum32.cpp", "Mu" ],
+		[ "/home/dash/dev/Orayta-QT/dep/quazip/quazip/quacrc32.cpp", "Mu" ],
+		[ "/home/dash/dev/Orayta-QT/dep/quazip/quazip/quagzipfile.cpp", "Mu" ],
+		[ "/home/dash/dev/Orayta-QT/dep/quazip/quazip/quaziodevice.cpp", "Mu" ],
+		[ "/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip.cpp", "Mu" ],
+		[ "/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipdir.cpp", "Mu" ],
+		[ "/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipfile.cpp", "Mu" ],
+		[ "/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipfileinfo.cpp", "Mu" ],
+		[ "/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipnewinfo.cpp", "Mu" ],
+		[ "/home/dash/dev/Orayta-QT/dep/quazip/quazip/unzip.c", "Mu" ],
+		[ "/home/dash/dev/Orayta-QT/dep/quazip/quazip/zip.c", "Mu" ]
+	],
+	"VERBOSITY" : 0
+}
diff -ruN ./CMakeFiles/QuaZip_autogen.dir/build.make ../../dep/quazip/quazip/CMakeFiles/QuaZip_autogen.dir/build.make
--- ./CMakeFiles/QuaZip_autogen.dir/build.make	1970-01-01 02:00:00.000000000 +0200
+++ ../../dep/quazip/quazip/CMakeFiles/QuaZip_autogen.dir/build.make	2020-11-27 04:08:37.012516716 +0200
@@ -0,0 +1,96 @@
+# CMAKE generated file: DO NOT EDIT!
+# Generated by "Unix Makefiles" Generator, CMake Version 3.19
+
+# Delete rule output on recipe failure.
+.DELETE_ON_ERROR:
+
+
+#=============================================================================
+# Special targets provided by cmake.
+
+# Disable implicit rules so canonical targets will work.
+.SUFFIXES:
+
+
+# Disable VCS-based implicit rules.
+% : %,v
+
+
+# Disable VCS-based implicit rules.
+% : RCS/%
+
+
+# Disable VCS-based implicit rules.
+% : RCS/%,v
+
+
+# Disable VCS-based implicit rules.
+% : SCCS/s.%
+
+
+# Disable VCS-based implicit rules.
+% : s.%
+
+
+.SUFFIXES: .hpux_make_needs_suffix_list
+
+
+# Command-line flag to silence nested $(MAKE).
+$(VERBOSE)MAKESILENT = -s
+
+#Suppress display of executed commands.
+$(VERBOSE).SILENT:
+
+# A target that is always out of date.
+cmake_force:
+
+.PHONY : cmake_force
+
+#=============================================================================
+# Set environment variables for the build.
+
+# The shell in which to execute make rules.
+SHELL = /bin/sh
+
+# The CMake executable.
+CMAKE_COMMAND = /usr/bin/cmake
+
+# The command to remove a file.
+RM = /usr/bin/cmake -E rm -f
+
+# Escaping for special characters.
+EQUALS = =
+
+# The top-level source directory on which CMake was run.
+CMAKE_SOURCE_DIR = /home/dash/dev/Orayta-QT/dep/quazip
+
+# The top-level build directory on which CMake was run.
+CMAKE_BINARY_DIR = /home/dash/dev/Orayta-QT/dep/quazip
+
+# Utility rule file for QuaZip_autogen.
+
+# Include the progress variables for this target.
+include quazip/CMakeFiles/QuaZip_autogen.dir/progress.make
+
+quazip/CMakeFiles/QuaZip_autogen:
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --blue --bold --progress-dir=/home/dash/dev/Orayta-QT/dep/quazip/CMakeFiles --progress-num=$(CMAKE_PROGRESS_1) "Automatic MOC for target QuaZip"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/cmake -E cmake_autogen /home/dash/dev/Orayta-QT/dep/quazip/quazip/CMakeFiles/QuaZip_autogen.dir/AutogenInfo.json RELEASE
+
+QuaZip_autogen: quazip/CMakeFiles/QuaZip_autogen
+QuaZip_autogen: quazip/CMakeFiles/QuaZip_autogen.dir/build.make
+
+.PHONY : QuaZip_autogen
+
+# Rule to build all files generated by this target.
+quazip/CMakeFiles/QuaZip_autogen.dir/build: QuaZip_autogen
+
+.PHONY : quazip/CMakeFiles/QuaZip_autogen.dir/build
+
+quazip/CMakeFiles/QuaZip_autogen.dir/clean:
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && $(CMAKE_COMMAND) -P CMakeFiles/QuaZip_autogen.dir/cmake_clean.cmake
+.PHONY : quazip/CMakeFiles/QuaZip_autogen.dir/clean
+
+quazip/CMakeFiles/QuaZip_autogen.dir/depend:
+	cd /home/dash/dev/Orayta-QT/dep/quazip && $(CMAKE_COMMAND) -E cmake_depends "Unix Makefiles" /home/dash/dev/Orayta-QT/dep/quazip /home/dash/dev/Orayta-QT/dep/quazip/quazip /home/dash/dev/Orayta-QT/dep/quazip /home/dash/dev/Orayta-QT/dep/quazip/quazip /home/dash/dev/Orayta-QT/dep/quazip/quazip/CMakeFiles/QuaZip_autogen.dir/DependInfo.cmake --color=$(COLOR)
+.PHONY : quazip/CMakeFiles/QuaZip_autogen.dir/depend
+
diff -ruN ./CMakeFiles/QuaZip_autogen.dir/cmake_clean.cmake ../../dep/quazip/quazip/CMakeFiles/QuaZip_autogen.dir/cmake_clean.cmake
--- ./CMakeFiles/QuaZip_autogen.dir/cmake_clean.cmake	1970-01-01 02:00:00.000000000 +0200
+++ ../../dep/quazip/quazip/CMakeFiles/QuaZip_autogen.dir/cmake_clean.cmake	2020-11-27 04:08:37.012516716 +0200
@@ -0,0 +1,9 @@
+file(REMOVE_RECURSE
+  "CMakeFiles/QuaZip_autogen"
+  "QuaZip_autogen/mocs_compilation.cpp"
+)
+
+# Per-language clean rules from dependency scanning.
+foreach(lang )
+  include(CMakeFiles/QuaZip_autogen.dir/cmake_clean_${lang}.cmake OPTIONAL)
+endforeach()
diff -ruN ./CMakeFiles/QuaZip_autogen.dir/DependInfo.cmake ../../dep/quazip/quazip/CMakeFiles/QuaZip_autogen.dir/DependInfo.cmake
--- ./CMakeFiles/QuaZip_autogen.dir/DependInfo.cmake	1970-01-01 02:00:00.000000000 +0200
+++ ../../dep/quazip/quazip/CMakeFiles/QuaZip_autogen.dir/DependInfo.cmake	2020-11-27 04:08:37.012516716 +0200
@@ -0,0 +1,11 @@
+# The set of languages for which implicit dependencies are needed:
+set(CMAKE_DEPENDS_LANGUAGES
+  )
+# The set of files for implicit dependencies of each language:
+
+# Targets to which this target links.
+set(CMAKE_TARGET_LINKED_INFO_FILES
+  )
+
+# Fortran module output directory.
+set(CMAKE_Fortran_TARGET_MODULE_DIR "")
diff -ruN ./CMakeFiles/QuaZip_autogen.dir/depend.internal ../../dep/quazip/quazip/CMakeFiles/QuaZip_autogen.dir/depend.internal
--- ./CMakeFiles/QuaZip_autogen.dir/depend.internal	1970-01-01 02:00:00.000000000 +0200
+++ ../../dep/quazip/quazip/CMakeFiles/QuaZip_autogen.dir/depend.internal	2020-11-27 04:08:38.145850007 +0200
@@ -0,0 +1,3 @@
+# CMAKE generated file: DO NOT EDIT!
+# Generated by "Unix Makefiles" Generator, CMake Version 3.19
+
diff -ruN ./CMakeFiles/QuaZip_autogen.dir/depend.make ../../dep/quazip/quazip/CMakeFiles/QuaZip_autogen.dir/depend.make
--- ./CMakeFiles/QuaZip_autogen.dir/depend.make	1970-01-01 02:00:00.000000000 +0200
+++ ../../dep/quazip/quazip/CMakeFiles/QuaZip_autogen.dir/depend.make	2020-11-27 04:08:38.145850007 +0200
@@ -0,0 +1,3 @@
+# CMAKE generated file: DO NOT EDIT!
+# Generated by "Unix Makefiles" Generator, CMake Version 3.19
+
diff -ruN ./CMakeFiles/QuaZip_autogen.dir/progress.make ../../dep/quazip/quazip/CMakeFiles/QuaZip_autogen.dir/progress.make
--- ./CMakeFiles/QuaZip_autogen.dir/progress.make	1970-01-01 02:00:00.000000000 +0200
+++ ../../dep/quazip/quazip/CMakeFiles/QuaZip_autogen.dir/progress.make	2020-11-27 04:08:37.019183382 +0200
@@ -0,0 +1,2 @@
+CMAKE_PROGRESS_1 = 17
+
diff -ruN ./CMakeFiles/QuaZip.dir/build.make ../../dep/quazip/quazip/CMakeFiles/QuaZip.dir/build.make
--- ./CMakeFiles/QuaZip.dir/build.make	1970-01-01 02:00:00.000000000 +0200
+++ ../../dep/quazip/quazip/CMakeFiles/QuaZip.dir/build.make	2020-11-27 04:08:37.015850049 +0200
@@ -0,0 +1,336 @@
+# CMAKE generated file: DO NOT EDIT!
+# Generated by "Unix Makefiles" Generator, CMake Version 3.19
+
+# Delete rule output on recipe failure.
+.DELETE_ON_ERROR:
+
+
+#=============================================================================
+# Special targets provided by cmake.
+
+# Disable implicit rules so canonical targets will work.
+.SUFFIXES:
+
+
+# Disable VCS-based implicit rules.
+% : %,v
+
+
+# Disable VCS-based implicit rules.
+% : RCS/%
+
+
+# Disable VCS-based implicit rules.
+% : RCS/%,v
+
+
+# Disable VCS-based implicit rules.
+% : SCCS/s.%
+
+
+# Disable VCS-based implicit rules.
+% : s.%
+
+
+.SUFFIXES: .hpux_make_needs_suffix_list
+
+
+# Command-line flag to silence nested $(MAKE).
+$(VERBOSE)MAKESILENT = -s
+
+#Suppress display of executed commands.
+$(VERBOSE).SILENT:
+
+# A target that is always out of date.
+cmake_force:
+
+.PHONY : cmake_force
+
+#=============================================================================
+# Set environment variables for the build.
+
+# The shell in which to execute make rules.
+SHELL = /bin/sh
+
+# The CMake executable.
+CMAKE_COMMAND = /usr/bin/cmake
+
+# The command to remove a file.
+RM = /usr/bin/cmake -E rm -f
+
+# Escaping for special characters.
+EQUALS = =
+
+# The top-level source directory on which CMake was run.
+CMAKE_SOURCE_DIR = /home/dash/dev/Orayta-QT/dep/quazip
+
+# The top-level build directory on which CMake was run.
+CMAKE_BINARY_DIR = /home/dash/dev/Orayta-QT/dep/quazip
+
+# Include any dependencies generated for this target.
+include quazip/CMakeFiles/QuaZip.dir/depend.make
+
+# Include the progress variables for this target.
+include quazip/CMakeFiles/QuaZip.dir/progress.make
+
+# Include the compile flags for this target's objects.
+include quazip/CMakeFiles/QuaZip.dir/flags.make
+
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: quazip/CMakeFiles/QuaZip.dir/flags.make
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: quazip/QuaZip_autogen/mocs_compilation.cpp
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/dash/dev/Orayta-QT/dep/quazip/CMakeFiles --progress-num=$(CMAKE_PROGRESS_1) "Building CXX object quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -o CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o -c /home/dash/dev/Orayta-QT/dep/quazip/quazip/QuaZip_autogen/mocs_compilation.cpp
+
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.i: cmake_force
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing CXX source to CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.i"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -E /home/dash/dev/Orayta-QT/dep/quazip/quazip/QuaZip_autogen/mocs_compilation.cpp > CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.i
+
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.s: cmake_force
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling CXX source to assembly CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.s"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -S /home/dash/dev/Orayta-QT/dep/quazip/quazip/QuaZip_autogen/mocs_compilation.cpp -o CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.s
+
+quazip/CMakeFiles/QuaZip.dir/unzip.c.o: quazip/CMakeFiles/QuaZip.dir/flags.make
+quazip/CMakeFiles/QuaZip.dir/unzip.c.o: quazip/unzip.c
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/dash/dev/Orayta-QT/dep/quazip/CMakeFiles --progress-num=$(CMAKE_PROGRESS_2) "Building C object quazip/CMakeFiles/QuaZip.dir/unzip.c.o"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -o CMakeFiles/QuaZip.dir/unzip.c.o -c /home/dash/dev/Orayta-QT/dep/quazip/quazip/unzip.c
+
+quazip/CMakeFiles/QuaZip.dir/unzip.c.i: cmake_force
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing C source to CMakeFiles/QuaZip.dir/unzip.c.i"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -E /home/dash/dev/Orayta-QT/dep/quazip/quazip/unzip.c > CMakeFiles/QuaZip.dir/unzip.c.i
+
+quazip/CMakeFiles/QuaZip.dir/unzip.c.s: cmake_force
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling C source to assembly CMakeFiles/QuaZip.dir/unzip.c.s"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -S /home/dash/dev/Orayta-QT/dep/quazip/quazip/unzip.c -o CMakeFiles/QuaZip.dir/unzip.c.s
+
+quazip/CMakeFiles/QuaZip.dir/zip.c.o: quazip/CMakeFiles/QuaZip.dir/flags.make
+quazip/CMakeFiles/QuaZip.dir/zip.c.o: quazip/zip.c
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/dash/dev/Orayta-QT/dep/quazip/CMakeFiles --progress-num=$(CMAKE_PROGRESS_3) "Building C object quazip/CMakeFiles/QuaZip.dir/zip.c.o"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -o CMakeFiles/QuaZip.dir/zip.c.o -c /home/dash/dev/Orayta-QT/dep/quazip/quazip/zip.c
+
+quazip/CMakeFiles/QuaZip.dir/zip.c.i: cmake_force
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing C source to CMakeFiles/QuaZip.dir/zip.c.i"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -E /home/dash/dev/Orayta-QT/dep/quazip/quazip/zip.c > CMakeFiles/QuaZip.dir/zip.c.i
+
+quazip/CMakeFiles/QuaZip.dir/zip.c.s: cmake_force
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling C source to assembly CMakeFiles/QuaZip.dir/zip.c.s"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -S /home/dash/dev/Orayta-QT/dep/quazip/quazip/zip.c -o CMakeFiles/QuaZip.dir/zip.c.s
+
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: quazip/CMakeFiles/QuaZip.dir/flags.make
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: quazip/JlCompress.cpp
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/dash/dev/Orayta-QT/dep/quazip/CMakeFiles --progress-num=$(CMAKE_PROGRESS_4) "Building CXX object quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -o CMakeFiles/QuaZip.dir/JlCompress.cpp.o -c /home/dash/dev/Orayta-QT/dep/quazip/quazip/JlCompress.cpp
+
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.i: cmake_force
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing CXX source to CMakeFiles/QuaZip.dir/JlCompress.cpp.i"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -E /home/dash/dev/Orayta-QT/dep/quazip/quazip/JlCompress.cpp > CMakeFiles/QuaZip.dir/JlCompress.cpp.i
+
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.s: cmake_force
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling CXX source to assembly CMakeFiles/QuaZip.dir/JlCompress.cpp.s"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -S /home/dash/dev/Orayta-QT/dep/quazip/quazip/JlCompress.cpp -o CMakeFiles/QuaZip.dir/JlCompress.cpp.s
+
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: quazip/CMakeFiles/QuaZip.dir/flags.make
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: quazip/qioapi.cpp
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/dash/dev/Orayta-QT/dep/quazip/CMakeFiles --progress-num=$(CMAKE_PROGRESS_5) "Building CXX object quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -o CMakeFiles/QuaZip.dir/qioapi.cpp.o -c /home/dash/dev/Orayta-QT/dep/quazip/quazip/qioapi.cpp
+
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.i: cmake_force
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing CXX source to CMakeFiles/QuaZip.dir/qioapi.cpp.i"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -E /home/dash/dev/Orayta-QT/dep/quazip/quazip/qioapi.cpp > CMakeFiles/QuaZip.dir/qioapi.cpp.i
+
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.s: cmake_force
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling CXX source to assembly CMakeFiles/QuaZip.dir/qioapi.cpp.s"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -S /home/dash/dev/Orayta-QT/dep/quazip/quazip/qioapi.cpp -o CMakeFiles/QuaZip.dir/qioapi.cpp.s
+
+quazip/CMakeFiles/QuaZip.dir/quaadler32.cpp.o: quazip/CMakeFiles/QuaZip.dir/flags.make
+quazip/CMakeFiles/QuaZip.dir/quaadler32.cpp.o: quazip/quaadler32.cpp
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/dash/dev/Orayta-QT/dep/quazip/CMakeFiles --progress-num=$(CMAKE_PROGRESS_6) "Building CXX object quazip/CMakeFiles/QuaZip.dir/quaadler32.cpp.o"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -o CMakeFiles/QuaZip.dir/quaadler32.cpp.o -c /home/dash/dev/Orayta-QT/dep/quazip/quazip/quaadler32.cpp
+
+quazip/CMakeFiles/QuaZip.dir/quaadler32.cpp.i: cmake_force
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing CXX source to CMakeFiles/QuaZip.dir/quaadler32.cpp.i"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -E /home/dash/dev/Orayta-QT/dep/quazip/quazip/quaadler32.cpp > CMakeFiles/QuaZip.dir/quaadler32.cpp.i
+
+quazip/CMakeFiles/QuaZip.dir/quaadler32.cpp.s: cmake_force
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling CXX source to assembly CMakeFiles/QuaZip.dir/quaadler32.cpp.s"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -S /home/dash/dev/Orayta-QT/dep/quazip/quazip/quaadler32.cpp -o CMakeFiles/QuaZip.dir/quaadler32.cpp.s
+
+quazip/CMakeFiles/QuaZip.dir/quachecksum32.cpp.o: quazip/CMakeFiles/QuaZip.dir/flags.make
+quazip/CMakeFiles/QuaZip.dir/quachecksum32.cpp.o: quazip/quachecksum32.cpp
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/dash/dev/Orayta-QT/dep/quazip/CMakeFiles --progress-num=$(CMAKE_PROGRESS_7) "Building CXX object quazip/CMakeFiles/QuaZip.dir/quachecksum32.cpp.o"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -o CMakeFiles/QuaZip.dir/quachecksum32.cpp.o -c /home/dash/dev/Orayta-QT/dep/quazip/quazip/quachecksum32.cpp
+
+quazip/CMakeFiles/QuaZip.dir/quachecksum32.cpp.i: cmake_force
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing CXX source to CMakeFiles/QuaZip.dir/quachecksum32.cpp.i"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -E /home/dash/dev/Orayta-QT/dep/quazip/quazip/quachecksum32.cpp > CMakeFiles/QuaZip.dir/quachecksum32.cpp.i
+
+quazip/CMakeFiles/QuaZip.dir/quachecksum32.cpp.s: cmake_force
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling CXX source to assembly CMakeFiles/QuaZip.dir/quachecksum32.cpp.s"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -S /home/dash/dev/Orayta-QT/dep/quazip/quazip/quachecksum32.cpp -o CMakeFiles/QuaZip.dir/quachecksum32.cpp.s
+
+quazip/CMakeFiles/QuaZip.dir/quacrc32.cpp.o: quazip/CMakeFiles/QuaZip.dir/flags.make
+quazip/CMakeFiles/QuaZip.dir/quacrc32.cpp.o: quazip/quacrc32.cpp
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/dash/dev/Orayta-QT/dep/quazip/CMakeFiles --progress-num=$(CMAKE_PROGRESS_8) "Building CXX object quazip/CMakeFiles/QuaZip.dir/quacrc32.cpp.o"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -o CMakeFiles/QuaZip.dir/quacrc32.cpp.o -c /home/dash/dev/Orayta-QT/dep/quazip/quazip/quacrc32.cpp
+
+quazip/CMakeFiles/QuaZip.dir/quacrc32.cpp.i: cmake_force
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing CXX source to CMakeFiles/QuaZip.dir/quacrc32.cpp.i"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -E /home/dash/dev/Orayta-QT/dep/quazip/quazip/quacrc32.cpp > CMakeFiles/QuaZip.dir/quacrc32.cpp.i
+
+quazip/CMakeFiles/QuaZip.dir/quacrc32.cpp.s: cmake_force
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling CXX source to assembly CMakeFiles/QuaZip.dir/quacrc32.cpp.s"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -S /home/dash/dev/Orayta-QT/dep/quazip/quazip/quacrc32.cpp -o CMakeFiles/QuaZip.dir/quacrc32.cpp.s
+
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: quazip/CMakeFiles/QuaZip.dir/flags.make
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: quazip/quagzipfile.cpp
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/dash/dev/Orayta-QT/dep/quazip/CMakeFiles --progress-num=$(CMAKE_PROGRESS_9) "Building CXX object quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -o CMakeFiles/QuaZip.dir/quagzipfile.cpp.o -c /home/dash/dev/Orayta-QT/dep/quazip/quazip/quagzipfile.cpp
+
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.i: cmake_force
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing CXX source to CMakeFiles/QuaZip.dir/quagzipfile.cpp.i"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -E /home/dash/dev/Orayta-QT/dep/quazip/quazip/quagzipfile.cpp > CMakeFiles/QuaZip.dir/quagzipfile.cpp.i
+
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.s: cmake_force
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling CXX source to assembly CMakeFiles/QuaZip.dir/quagzipfile.cpp.s"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -S /home/dash/dev/Orayta-QT/dep/quazip/quazip/quagzipfile.cpp -o CMakeFiles/QuaZip.dir/quagzipfile.cpp.s
+
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: quazip/CMakeFiles/QuaZip.dir/flags.make
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: quazip/quaziodevice.cpp
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/dash/dev/Orayta-QT/dep/quazip/CMakeFiles --progress-num=$(CMAKE_PROGRESS_10) "Building CXX object quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -o CMakeFiles/QuaZip.dir/quaziodevice.cpp.o -c /home/dash/dev/Orayta-QT/dep/quazip/quazip/quaziodevice.cpp
+
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.i: cmake_force
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing CXX source to CMakeFiles/QuaZip.dir/quaziodevice.cpp.i"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -E /home/dash/dev/Orayta-QT/dep/quazip/quazip/quaziodevice.cpp > CMakeFiles/QuaZip.dir/quaziodevice.cpp.i
+
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.s: cmake_force
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling CXX source to assembly CMakeFiles/QuaZip.dir/quaziodevice.cpp.s"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -S /home/dash/dev/Orayta-QT/dep/quazip/quazip/quaziodevice.cpp -o CMakeFiles/QuaZip.dir/quaziodevice.cpp.s
+
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: quazip/CMakeFiles/QuaZip.dir/flags.make
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: quazip/quazip.cpp
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/dash/dev/Orayta-QT/dep/quazip/CMakeFiles --progress-num=$(CMAKE_PROGRESS_11) "Building CXX object quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -o CMakeFiles/QuaZip.dir/quazip.cpp.o -c /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip.cpp
+
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.i: cmake_force
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing CXX source to CMakeFiles/QuaZip.dir/quazip.cpp.i"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -E /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip.cpp > CMakeFiles/QuaZip.dir/quazip.cpp.i
+
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.s: cmake_force
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling CXX source to assembly CMakeFiles/QuaZip.dir/quazip.cpp.s"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -S /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip.cpp -o CMakeFiles/QuaZip.dir/quazip.cpp.s
+
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: quazip/CMakeFiles/QuaZip.dir/flags.make
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: quazip/quazipdir.cpp
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/dash/dev/Orayta-QT/dep/quazip/CMakeFiles --progress-num=$(CMAKE_PROGRESS_12) "Building CXX object quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -o CMakeFiles/QuaZip.dir/quazipdir.cpp.o -c /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipdir.cpp
+
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.i: cmake_force
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing CXX source to CMakeFiles/QuaZip.dir/quazipdir.cpp.i"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -E /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipdir.cpp > CMakeFiles/QuaZip.dir/quazipdir.cpp.i
+
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.s: cmake_force
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling CXX source to assembly CMakeFiles/QuaZip.dir/quazipdir.cpp.s"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -S /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipdir.cpp -o CMakeFiles/QuaZip.dir/quazipdir.cpp.s
+
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: quazip/CMakeFiles/QuaZip.dir/flags.make
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: quazip/quazipfile.cpp
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/dash/dev/Orayta-QT/dep/quazip/CMakeFiles --progress-num=$(CMAKE_PROGRESS_13) "Building CXX object quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -o CMakeFiles/QuaZip.dir/quazipfile.cpp.o -c /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipfile.cpp
+
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.i: cmake_force
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing CXX source to CMakeFiles/QuaZip.dir/quazipfile.cpp.i"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -E /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipfile.cpp > CMakeFiles/QuaZip.dir/quazipfile.cpp.i
+
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.s: cmake_force
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling CXX source to assembly CMakeFiles/QuaZip.dir/quazipfile.cpp.s"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -S /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipfile.cpp -o CMakeFiles/QuaZip.dir/quazipfile.cpp.s
+
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: quazip/CMakeFiles/QuaZip.dir/flags.make
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: quazip/quazipfileinfo.cpp
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/dash/dev/Orayta-QT/dep/quazip/CMakeFiles --progress-num=$(CMAKE_PROGRESS_14) "Building CXX object quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -o CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o -c /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipfileinfo.cpp
+
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.i: cmake_force
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing CXX source to CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.i"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -E /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipfileinfo.cpp > CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.i
+
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.s: cmake_force
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling CXX source to assembly CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.s"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -S /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipfileinfo.cpp -o CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.s
+
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: quazip/CMakeFiles/QuaZip.dir/flags.make
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: quazip/quazipnewinfo.cpp
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/dash/dev/Orayta-QT/dep/quazip/CMakeFiles --progress-num=$(CMAKE_PROGRESS_15) "Building CXX object quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -o CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o -c /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipnewinfo.cpp
+
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.i: cmake_force
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing CXX source to CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.i"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -E /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipnewinfo.cpp > CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.i
+
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.s: cmake_force
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling CXX source to assembly CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.s"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && /usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -S /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipnewinfo.cpp -o CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.s
+
+# Object files for target QuaZip
+QuaZip_OBJECTS = \
+"CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o" \
+"CMakeFiles/QuaZip.dir/unzip.c.o" \
+"CMakeFiles/QuaZip.dir/zip.c.o" \
+"CMakeFiles/QuaZip.dir/JlCompress.cpp.o" \
+"CMakeFiles/QuaZip.dir/qioapi.cpp.o" \
+"CMakeFiles/QuaZip.dir/quaadler32.cpp.o" \
+"CMakeFiles/QuaZip.dir/quachecksum32.cpp.o" \
+"CMakeFiles/QuaZip.dir/quacrc32.cpp.o" \
+"CMakeFiles/QuaZip.dir/quagzipfile.cpp.o" \
+"CMakeFiles/QuaZip.dir/quaziodevice.cpp.o" \
+"CMakeFiles/QuaZip.dir/quazip.cpp.o" \
+"CMakeFiles/QuaZip.dir/quazipdir.cpp.o" \
+"CMakeFiles/QuaZip.dir/quazipfile.cpp.o" \
+"CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o" \
+"CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o"
+
+# External object files for target QuaZip
+QuaZip_EXTERNAL_OBJECTS =
+
+quazip/libquazip1-qt5.so.1.1: quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o
+quazip/libquazip1-qt5.so.1.1: quazip/CMakeFiles/QuaZip.dir/unzip.c.o
+quazip/libquazip1-qt5.so.1.1: quazip/CMakeFiles/QuaZip.dir/zip.c.o
+quazip/libquazip1-qt5.so.1.1: quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o
+quazip/libquazip1-qt5.so.1.1: quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o
+quazip/libquazip1-qt5.so.1.1: quazip/CMakeFiles/QuaZip.dir/quaadler32.cpp.o
+quazip/libquazip1-qt5.so.1.1: quazip/CMakeFiles/QuaZip.dir/quachecksum32.cpp.o
+quazip/libquazip1-qt5.so.1.1: quazip/CMakeFiles/QuaZip.dir/quacrc32.cpp.o
+quazip/libquazip1-qt5.so.1.1: quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o
+quazip/libquazip1-qt5.so.1.1: quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o
+quazip/libquazip1-qt5.so.1.1: quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o
+quazip/libquazip1-qt5.so.1.1: quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o
+quazip/libquazip1-qt5.so.1.1: quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o
+quazip/libquazip1-qt5.so.1.1: quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o
+quazip/libquazip1-qt5.so.1.1: quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o
+quazip/libquazip1-qt5.so.1.1: quazip/CMakeFiles/QuaZip.dir/build.make
+quazip/libquazip1-qt5.so.1.1: /usr/lib/libQt5Core.so.5.15.2
+quazip/libquazip1-qt5.so.1.1: /usr/lib/libz.so
+quazip/libquazip1-qt5.so.1.1: quazip/CMakeFiles/QuaZip.dir/link.txt
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --bold --progress-dir=/home/dash/dev/Orayta-QT/dep/quazip/CMakeFiles --progress-num=$(CMAKE_PROGRESS_16) "Linking CXX shared library libquazip1-qt5.so"
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && $(CMAKE_COMMAND) -E cmake_link_script CMakeFiles/QuaZip.dir/link.txt --verbose=$(VERBOSE)
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && $(CMAKE_COMMAND) -E cmake_symlink_library libquazip1-qt5.so.1.1 libquazip1-qt5.so.1.0.0 libquazip1-qt5.so
+
+quazip/libquazip1-qt5.so.1.0.0: quazip/libquazip1-qt5.so.1.1
+	@$(CMAKE_COMMAND) -E touch_nocreate quazip/libquazip1-qt5.so.1.0.0
+
+quazip/libquazip1-qt5.so: quazip/libquazip1-qt5.so.1.1
+	@$(CMAKE_COMMAND) -E touch_nocreate quazip/libquazip1-qt5.so
+
+# Rule to build all files generated by this target.
+quazip/CMakeFiles/QuaZip.dir/build: quazip/libquazip1-qt5.so
+
+.PHONY : quazip/CMakeFiles/QuaZip.dir/build
+
+quazip/CMakeFiles/QuaZip.dir/clean:
+	cd /home/dash/dev/Orayta-QT/dep/quazip/quazip && $(CMAKE_COMMAND) -P CMakeFiles/QuaZip.dir/cmake_clean.cmake
+.PHONY : quazip/CMakeFiles/QuaZip.dir/clean
+
+quazip/CMakeFiles/QuaZip.dir/depend:
+	cd /home/dash/dev/Orayta-QT/dep/quazip && $(CMAKE_COMMAND) -E cmake_depends "Unix Makefiles" /home/dash/dev/Orayta-QT/dep/quazip /home/dash/dev/Orayta-QT/dep/quazip/quazip /home/dash/dev/Orayta-QT/dep/quazip /home/dash/dev/Orayta-QT/dep/quazip/quazip /home/dash/dev/Orayta-QT/dep/quazip/quazip/CMakeFiles/QuaZip.dir/DependInfo.cmake --color=$(COLOR)
+.PHONY : quazip/CMakeFiles/QuaZip.dir/depend
+
diff -ruN ./CMakeFiles/QuaZip.dir/C.includecache ../../dep/quazip/quazip/CMakeFiles/QuaZip.dir/C.includecache
--- ./CMakeFiles/QuaZip.dir/C.includecache	1970-01-01 02:00:00.000000000 +0200
+++ ../../dep/quazip/quazip/CMakeFiles/QuaZip.dir/C.includecache	2020-11-27 04:08:38.302516667 +0200
@@ -0,0 +1,248 @@
+#IncludeRegexLine: ^[ 	]*[#%][ 	]*(include|import)[ 	]*[<"]([^">]+)([">])
+
+#IncludeRegexScan: ^.*$
+
+#IncludeRegexComplain: ^$
+
+#IncludeRegexTransform: 
+
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/ioapi.h
+stdio.h
+-
+stdlib.h
+-
+zlib.h
+-
+stdint.h
+-
+mz64conf.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/mz64conf.h
+stdint.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/stdint.h
+
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/minizip_crypt.h
+quazip_global.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip_global.h
+
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip_global.h
+QtCore/QtGlobal
+-
+
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/unzip.c
+stdio.h
+-
+stdlib.h
+-
+string.h
+-
+zlib.h
+-
+unzip.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/unzip.h
+stddef.h
+-
+string.h
+-
+stdlib.h
+-
+errno.h
+-
+minizip_crypt.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/minizip_crypt.h
+
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/unzip.h
+zlib.h
+-
+ioapi.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/ioapi.h
+bzlib.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/bzlib.h
+
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/zip.c
+stdio.h
+-
+stdlib.h
+-
+string.h
+-
+time.h
+-
+zlib.h
+-
+zip.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/zip.h
+stddef.h
+-
+string.h
+-
+stdlib.h
+-
+errno.h
+-
+minizip_crypt.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/minizip_crypt.h
+
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/zip.h
+zlib.h
+-
+ioapi.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/ioapi.h
+bzlib.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/bzlib.h
+
+/usr/include/qt/QtCore/QtGlobal
+qglobal.h
+/usr/include/qt/QtCore/qglobal.h
+
+/usr/include/qt/QtCore/qatomic.h
+QtCore/qglobal.h
+-
+QtCore/qbasicatomic.h
+-
+
+/usr/include/qt/QtCore/qatomic_bootstrap.h
+QtCore/qgenericatomic.h
+-
+
+/usr/include/qt/QtCore/qatomic_cxx11.h
+QtCore/qgenericatomic.h
+-
+atomic
+-
+
+/usr/include/qt/QtCore/qatomic_msvc.h
+QtCore/qgenericatomic.h
+-
+
+/usr/include/qt/QtCore/qbasicatomic.h
+QtCore/qglobal.h
+-
+QtCore/qatomic_bootstrap.h
+-
+QtCore/qatomic_cxx11.h
+-
+QtCore/qatomic_msvc.h
+-
+
+/usr/include/qt/QtCore/qcompilerdetection.h
+QtCore/qglobal.h
+-
+utility
+-
+
+/usr/include/qt/QtCore/qconfig-bootstrapped.h
+
+/usr/include/qt/QtCore/qconfig.h
+
+/usr/include/qt/QtCore/qflags.h
+QtCore/qglobal.h
+-
+initializer_list
+-
+
+/usr/include/qt/QtCore/qgenericatomic.h
+QtCore/qglobal.h
+-
+QtCore/qtypeinfo.h
+-
+
+/usr/include/qt/QtCore/qglobal.h
+type_traits
+-
+cstddef
+-
+utility
+-
+assert.h
+-
+stddef.h
+-
+QtCore/qconfig-bootstrapped.h
+-
+QtCore/qconfig.h
+-
+QtCore/qtcore-config.h
+-
+QtCore/qsystemdetection.h
+-
+QtCore/qprocessordetection.h
+-
+QtCore/qcompilerdetection.h
+-
+algorithm
+-
+QtCore/qtypeinfo.h
+-
+QtCore/qsysinfo.h
+-
+QtCore/qlogging.h
+-
+QtCore/qflags.h
+-
+QtCore/qatomic.h
+-
+QtCore/qglobalstatic.h
+-
+QtCore/qnumeric.h
+-
+QtCore/qversiontagging.h
+-
+
+/usr/include/qt/QtCore/qglobalstatic.h
+QtCore/qglobal.h
+-
+QtCore/qatomic.h
+-
+QtCore/qmutex.h
+-
+mutex
+-
+
+/usr/include/qt/QtCore/qlogging.h
+QtCore/qglobal.h
+-
+
+/usr/include/qt/QtCore/qmutex.h
+QtCore/qglobal.h
+-
+QtCore/qatomic.h
+-
+new
+-
+chrono
+-
+limits
+-
+
+/usr/include/qt/QtCore/qnumeric.h
+QtCore/qglobal.h
+-
+
+/usr/include/qt/QtCore/qprocessordetection.h
+QtCore/qglobal.h
+-
+
+/usr/include/qt/QtCore/qsysinfo.h
+QtCore/qglobal.h
+-
+
+/usr/include/qt/QtCore/qsystemdetection.h
+QtCore/qglobal.h
+-
+TargetConditionals.h
+-
+Availability.h
+-
+AvailabilityMacros.h
+-
+
+/usr/include/qt/QtCore/qtcore-config.h
+
+/usr/include/qt/QtCore/qtypeinfo.h
+QtCore/qglobal.h
+-
+
+/usr/include/qt/QtCore/qversiontagging.h
+QtCore/qglobal.h
+-
+
diff -ruN ./CMakeFiles/QuaZip.dir/cmake_clean.cmake ../../dep/quazip/quazip/CMakeFiles/QuaZip.dir/cmake_clean.cmake
--- ./CMakeFiles/QuaZip.dir/cmake_clean.cmake	1970-01-01 02:00:00.000000000 +0200
+++ ../../dep/quazip/quazip/CMakeFiles/QuaZip.dir/cmake_clean.cmake	2020-11-27 04:08:37.015850049 +0200
@@ -0,0 +1,29 @@
+file(REMOVE_RECURSE
+  "CMakeFiles/QuaZip_autogen.dir/AutogenUsed.txt"
+  "CMakeFiles/QuaZip_autogen.dir/ParseCache.txt"
+  "QuaZip_autogen"
+  "CMakeFiles/QuaZip.dir/JlCompress.cpp.o"
+  "CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o"
+  "CMakeFiles/QuaZip.dir/qioapi.cpp.o"
+  "CMakeFiles/QuaZip.dir/quaadler32.cpp.o"
+  "CMakeFiles/QuaZip.dir/quachecksum32.cpp.o"
+  "CMakeFiles/QuaZip.dir/quacrc32.cpp.o"
+  "CMakeFiles/QuaZip.dir/quagzipfile.cpp.o"
+  "CMakeFiles/QuaZip.dir/quaziodevice.cpp.o"
+  "CMakeFiles/QuaZip.dir/quazip.cpp.o"
+  "CMakeFiles/QuaZip.dir/quazipdir.cpp.o"
+  "CMakeFiles/QuaZip.dir/quazipfile.cpp.o"
+  "CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o"
+  "CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o"
+  "CMakeFiles/QuaZip.dir/unzip.c.o"
+  "CMakeFiles/QuaZip.dir/zip.c.o"
+  "libquazip1-qt5.pdb"
+  "libquazip1-qt5.so"
+  "libquazip1-qt5.so.1.0.0"
+  "libquazip1-qt5.so.1.1"
+)
+
+# Per-language clean rules from dependency scanning.
+foreach(lang C CXX)
+  include(CMakeFiles/QuaZip.dir/cmake_clean_${lang}.cmake OPTIONAL)
+endforeach()
diff -ruN ./CMakeFiles/QuaZip.dir/CXX.includecache ../../dep/quazip/quazip/CMakeFiles/QuaZip.dir/CXX.includecache
--- ./CMakeFiles/QuaZip.dir/CXX.includecache	1970-01-01 02:00:00.000000000 +0200
+++ ../../dep/quazip/quazip/CMakeFiles/QuaZip.dir/CXX.includecache	2020-11-27 04:08:38.322516667 +0200
@@ -0,0 +1,1118 @@
+#IncludeRegexLine: ^[ 	]*[#%][ 	]*(include|import)[ 	]*[<"]([^">]+)([">])
+
+#IncludeRegexScan: ^.*$
+
+#IncludeRegexComplain: ^$
+
+#IncludeRegexTransform: 
+
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/JlCompress.cpp
+JlCompress.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/JlCompress.h
+
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/JlCompress.h
+quazip.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip.h
+quazipfile.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipfile.h
+quazipfileinfo.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipfileinfo.h
+quazip_qt_compat.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip_qt_compat.h
+QtCore/QString
+-
+QtCore/QDir
+-
+QtCore/QFileInfo
+-
+QtCore/QFile
+-
+
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/QuaZip_autogen/EWIEGA46WW/moc_quagzipfile.cpp
+memory
+-
+../../quagzipfile.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quagzipfile.h
+QtCore/qbytearray.h
+-
+QtCore/qmetatype.h
+-
+
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/QuaZip_autogen/EWIEGA46WW/moc_quaziodevice.cpp
+memory
+-
+../../quaziodevice.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quaziodevice.h
+QtCore/qbytearray.h
+-
+QtCore/qmetatype.h
+-
+
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/QuaZip_autogen/EWIEGA46WW/moc_quazipfile.cpp
+memory
+-
+../../quazipfile.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipfile.h
+QtCore/qbytearray.h
+-
+QtCore/qmetatype.h
+-
+
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/QuaZip_autogen/mocs_compilation.cpp
+EWIEGA46WW/moc_quagzipfile.cpp
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/QuaZip_autogen/EWIEGA46WW/moc_quagzipfile.cpp
+EWIEGA46WW/moc_quaziodevice.cpp
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/QuaZip_autogen/EWIEGA46WW/moc_quaziodevice.cpp
+EWIEGA46WW/moc_quazipfile.cpp
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/QuaZip_autogen/EWIEGA46WW/moc_quazipfile.cpp
+
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/ioapi.h
+stdio.h
+-
+stdlib.h
+-
+zlib.h
+-
+stdint.h
+-
+mz64conf.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/mz64conf.h
+stdint.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/stdint.h
+
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/qioapi.cpp
+stdio.h
+-
+stdlib.h
+-
+string.h
+-
+zlib.h
+-
+ioapi.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/ioapi.h
+quazip_global.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip_global.h
+QtCore/QIODevice
+-
+quazip_qt_compat.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip_qt_compat.h
+
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quaadler32.cpp
+quaadler32.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quaadler32.h
+zlib.h
+-
+
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quaadler32.h
+QtCore/QByteArray
+-
+quachecksum32.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quachecksum32.h
+
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quachecksum32.cpp
+quachecksum32.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quachecksum32.h
+
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quachecksum32.h
+QtCore/QByteArray
+-
+quazip_global.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip_global.h
+
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quacrc32.cpp
+quacrc32.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quacrc32.h
+zlib.h
+-
+
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quacrc32.h
+quachecksum32.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quachecksum32.h
+
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quagzipfile.cpp
+QtCore/QFile
+-
+quagzipfile.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quagzipfile.h
+
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quagzipfile.h
+QtCore/QIODevice
+-
+quazip_global.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip_global.h
+zlib.h
+-
+
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quaziodevice.cpp
+quaziodevice.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quaziodevice.h
+QtCore/QFile
+-
+QtCore/QFile
+-
+
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quaziodevice.h
+QtCore/QIODevice
+-
+quazip_global.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip_global.h
+zlib.h
+-
+
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip.cpp
+QtCore/QFile
+-
+QtCore/QFlags
+-
+QtCore/QHash
+-
+quazip.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip.h
+
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip.h
+QtCore/QString
+-
+QtCore/QStringList
+-
+quazip_qt_compat.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip_qt_compat.h
+zip.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/zip.h
+unzip.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/unzip.h
+quazip_global.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip_global.h
+quazipfileinfo.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipfileinfo.h
+
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip_global.h
+QtCore/QtGlobal
+-
+
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip_qt_compat.h
+QtCore/Qt
+-
+QtCore/QtGlobal
+-
+QtCore5Compat/QTextCodec
+-
+QtCore/QTextCodec
+-
+QtCore/QSaveFile
+-
+QtCore/QString
+-
+QtCore/QList
+-
+algorithm
+-
+QtCore/QtAlgorithms
+-
+QtCore/QDateTime
+-
+QtCore/QFileInfo
+-
+QtCore/QFileInfo
+-
+QtCore/QFileInfo
+-
+QtCore/QDateTime
+-
+QtCore/QDateTime
+-
+QtCore/QTextStream
+-
+
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipdir.cpp
+quazipdir.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipdir.h
+quazip_qt_compat.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip_qt_compat.h
+QtCore/QSet
+-
+QtCore/QSharedData
+-
+
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipdir.h
+quazip.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip.h
+quazipfileinfo.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipfileinfo.h
+QtCore/QDir
+-
+QtCore/QList
+-
+QtCore/QSharedDataPointer
+-
+
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipfile.cpp
+quazipfile.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipfile.h
+quazipfileinfo.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipfileinfo.h
+
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipfile.h
+QtCore/QIODevice
+-
+quazip_global.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip_global.h
+quazip.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip.h
+quazipnewinfo.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipnewinfo.h
+
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipfileinfo.cpp
+quazipfileinfo.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipfileinfo.h
+QtCore/QDataStream
+-
+
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipfileinfo.h
+QtCore/QByteArray
+-
+QtCore/QDateTime
+-
+QtCore/QFile
+-
+QtCore/QHash
+-
+quazip_global.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip_global.h
+
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipnewinfo.cpp
+QtCore/QFileInfo
+-
+quazipnewinfo.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipnewinfo.h
+quazip_qt_compat.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip_qt_compat.h
+string.h
+-
+
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipnewinfo.h
+QtCore/QDateTime
+-
+QtCore/QFile
+-
+QtCore/QString
+-
+quazip_global.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip_global.h
+quazipfileinfo.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipfileinfo.h
+
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/unzip.h
+zlib.h
+-
+ioapi.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/ioapi.h
+bzlib.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/bzlib.h
+
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/zip.h
+zlib.h
+-
+ioapi.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/ioapi.h
+bzlib.h
+/home/dash/dev/Orayta-QT/dep/quazip/quazip/bzlib.h
+
+/usr/include/qt/QtCore/QByteArray
+qbytearray.h
+/usr/include/qt/QtCore/qbytearray.h
+
+/usr/include/qt/QtCore/QDataStream
+qdatastream.h
+/usr/include/qt/QtCore/qdatastream.h
+
+/usr/include/qt/QtCore/QDateTime
+qdatetime.h
+/usr/include/qt/QtCore/qdatetime.h
+
+/usr/include/qt/QtCore/QDir
+qdir.h
+/usr/include/qt/QtCore/qdir.h
+
+/usr/include/qt/QtCore/QFile
+qfile.h
+/usr/include/qt/QtCore/qfile.h
+
+/usr/include/qt/QtCore/QFileInfo
+qfileinfo.h
+/usr/include/qt/QtCore/qfileinfo.h
+
+/usr/include/qt/QtCore/QFlags
+qflags.h
+/usr/include/qt/QtCore/qflags.h
+
+/usr/include/qt/QtCore/QHash
+qhash.h
+/usr/include/qt/QtCore/qhash.h
+
+/usr/include/qt/QtCore/QIODevice
+qiodevice.h
+/usr/include/qt/QtCore/qiodevice.h
+
+/usr/include/qt/QtCore/QList
+qlist.h
+/usr/include/qt/QtCore/qlist.h
+
+/usr/include/qt/QtCore/QSaveFile
+qsavefile.h
+/usr/include/qt/QtCore/qsavefile.h
+
+/usr/include/qt/QtCore/QSet
+qset.h
+/usr/include/qt/QtCore/qset.h
+
+/usr/include/qt/QtCore/QSharedData
+qshareddata.h
+/usr/include/qt/QtCore/qshareddata.h
+
+/usr/include/qt/QtCore/QSharedDataPointer
+qshareddata.h
+/usr/include/qt/QtCore/qshareddata.h
+
+/usr/include/qt/QtCore/QString
+qstring.h
+/usr/include/qt/QtCore/qstring.h
+
+/usr/include/qt/QtCore/QStringList
+qstringlist.h
+/usr/include/qt/QtCore/qstringlist.h
+
+/usr/include/qt/QtCore/QTextCodec
+qtextcodec.h
+/usr/include/qt/QtCore/qtextcodec.h
+
+/usr/include/qt/QtCore/QTextStream
+qtextstream.h
+/usr/include/qt/QtCore/qtextstream.h
+
+/usr/include/qt/QtCore/Qt
+qnamespace.h
+/usr/include/qt/QtCore/qnamespace.h
+
+/usr/include/qt/QtCore/QtAlgorithms
+qalgorithms.h
+/usr/include/qt/QtCore/qalgorithms.h
+
+/usr/include/qt/QtCore/QtGlobal
+qglobal.h
+/usr/include/qt/QtCore/qglobal.h
+
+/usr/include/qt/QtCore/qalgorithms.h
+QtCore/qglobal.h
+-
+intrin.h
+-
+
+/usr/include/qt/QtCore/qarraydata.h
+QtCore/qrefcount.h
+-
+string.h
+-
+
+/usr/include/qt/QtCore/qatomic.h
+QtCore/qglobal.h
+-
+QtCore/qbasicatomic.h
+-
+
+/usr/include/qt/QtCore/qatomic_bootstrap.h
+QtCore/qgenericatomic.h
+-
+
+/usr/include/qt/QtCore/qatomic_cxx11.h
+QtCore/qgenericatomic.h
+-
+atomic
+-
+
+/usr/include/qt/QtCore/qatomic_msvc.h
+QtCore/qgenericatomic.h
+-
+
+/usr/include/qt/QtCore/qbasicatomic.h
+QtCore/qglobal.h
+-
+QtCore/qatomic_bootstrap.h
+-
+QtCore/qatomic_cxx11.h
+-
+QtCore/qatomic_msvc.h
+-
+
+/usr/include/qt/QtCore/qbytearray.h
+QtCore/qrefcount.h
+-
+QtCore/qnamespace.h
+-
+QtCore/qarraydata.h
+-
+stdlib.h
+-
+string.h
+-
+stdarg.h
+-
+string
+-
+iterator
+-
+
+/usr/include/qt/QtCore/qbytearraylist.h
+QtCore/qlist.h
+-
+QtCore/qbytearray.h
+-
+
+/usr/include/qt/QtCore/qchar.h
+QtCore/qglobal.h
+-
+
+/usr/include/qt/QtCore/qcompilerdetection.h
+QtCore/qglobal.h
+-
+utility
+-
+
+/usr/include/qt/QtCore/qconfig-bootstrapped.h
+
+/usr/include/qt/QtCore/qconfig.h
+
+/usr/include/qt/QtCore/qcontainerfwd.h
+QtCore/qglobal.h
+-
+
+/usr/include/qt/QtCore/qcontainertools_impl.h
+QtCore/qglobal.h
+-
+iterator
+-
+
+/usr/include/qt/QtCore/qcontiguouscache.h
+QtCore/qatomic.h
+-
+limits.h
+-
+new
+-
+
+/usr/include/qt/QtCore/qcoreevent.h
+QtCore/qnamespace.h
+-
+QtCore/qbytearray.h
+-
+QtCore/qobjectdefs.h
+-
+
+/usr/include/qt/QtCore/qdatastream.h
+QtCore/qscopedpointer.h
+-
+QtCore/qiodevice.h
+-
+QtCore/qpair.h
+-
+
+/usr/include/qt/QtCore/qdatetime.h
+QtCore/qstring.h
+-
+QtCore/qnamespace.h
+-
+QtCore/qshareddata.h
+-
+limits
+-
+
+/usr/include/qt/QtCore/qdebug.h
+QtCore/qalgorithms.h
+-
+QtCore/qhash.h
+-
+QtCore/qlist.h
+-
+QtCore/qmap.h
+-
+QtCore/qpair.h
+-
+QtCore/qtextstream.h
+-
+QtCore/qstring.h
+-
+QtCore/qvector.h
+-
+QtCore/qset.h
+-
+QtCore/qcontiguouscache.h
+-
+QtCore/qsharedpointer.h
+-
+vector
+-
+list
+-
+map
+-
+utility
+-
+
+/usr/include/qt/QtCore/qdir.h
+QtCore/qstring.h
+-
+QtCore/qfileinfo.h
+-
+QtCore/qstringlist.h
+-
+QtCore/qshareddata.h
+-
+
+/usr/include/qt/QtCore/qfile.h
+QtCore/qfiledevice.h
+-
+QtCore/qstring.h
+-
+stdio.h
+-
+
+/usr/include/qt/QtCore/qfiledevice.h
+QtCore/qiodevice.h
+-
+QtCore/qstring.h
+-
+
+/usr/include/qt/QtCore/qfileinfo.h
+QtCore/qfile.h
+-
+QtCore/qlist.h
+-
+QtCore/qshareddata.h
+-
+QtCore/qmetatype.h
+-
+
+/usr/include/qt/QtCore/qflags.h
+QtCore/qglobal.h
+-
+initializer_list
+-
+
+/usr/include/qt/QtCore/qgenericatomic.h
+QtCore/qglobal.h
+-
+QtCore/qtypeinfo.h
+-
+
+/usr/include/qt/QtCore/qglobal.h
+type_traits
+-
+cstddef
+-
+utility
+-
+assert.h
+-
+stddef.h
+-
+QtCore/qconfig-bootstrapped.h
+-
+QtCore/qconfig.h
+-
+QtCore/qtcore-config.h
+-
+QtCore/qsystemdetection.h
+-
+QtCore/qprocessordetection.h
+-
+QtCore/qcompilerdetection.h
+-
+algorithm
+-
+QtCore/qtypeinfo.h
+-
+QtCore/qsysinfo.h
+-
+QtCore/qlogging.h
+-
+QtCore/qflags.h
+-
+QtCore/qatomic.h
+-
+QtCore/qglobalstatic.h
+-
+QtCore/qnumeric.h
+-
+QtCore/qversiontagging.h
+-
+
+/usr/include/qt/QtCore/qglobalstatic.h
+QtCore/qglobal.h
+-
+QtCore/qatomic.h
+-
+QtCore/qmutex.h
+-
+mutex
+-
+
+/usr/include/qt/QtCore/qhash.h
+QtCore/qchar.h
+-
+QtCore/qiterator.h
+-
+QtCore/qlist.h
+-
+QtCore/qrefcount.h
+-
+QtCore/qhashfunctions.h
+-
+QtCore/qcontainertools_impl.h
+-
+algorithm
+-
+initializer_list
+-
+
+/usr/include/qt/QtCore/qhashfunctions.h
+QtCore/qstring.h
+-
+QtCore/qpair.h
+-
+numeric
+-
+functional
+-
+
+/usr/include/qt/QtCore/qiodevice.h
+QtCore/qglobal.h
+-
+QtCore/qobject.h
+-
+QtCore/qobjectdefs.h
+-
+QtCore/qscopedpointer.h
+-
+QtCore/qstring.h
+-
+
+/usr/include/qt/QtCore/qiterator.h
+QtCore/qglobal.h
+-
+
+/usr/include/qt/QtCore/qlist.h
+QtCore/qalgorithms.h
+-
+QtCore/qiterator.h
+-
+QtCore/qrefcount.h
+-
+QtCore/qarraydata.h
+-
+QtCore/qhashfunctions.h
+-
+QtCore/qvector.h
+-
+QtCore/qcontainertools_impl.h
+-
+algorithm
+-
+initializer_list
+-
+iterator
+-
+list
+-
+stdlib.h
+-
+new
+-
+limits.h
+-
+string.h
+-
+QtCore/qbytearraylist.h
+-
+QtCore/qstringlist.h
+-
+
+/usr/include/qt/QtCore/qlocale.h
+QtCore/qvariant.h
+-
+QtCore/qstring.h
+-
+QtCore/qobjectdefs.h
+-
+QtCore/qshareddata.h
+-
+
+/usr/include/qt/QtCore/qlogging.h
+QtCore/qglobal.h
+-
+
+/usr/include/qt/QtCore/qmap.h
+QtCore/qiterator.h
+-
+QtCore/qlist.h
+-
+QtCore/qrefcount.h
+-
+QtCore/qpair.h
+-
+QtCore/qdebug.h
+-
+functional
+-
+initializer_list
+-
+map
+-
+new
+-
+
+/usr/include/qt/QtCore/qmetatype.h
+QtCore/qglobal.h
+-
+QtCore/qatomic.h
+-
+QtCore/qbytearray.h
+-
+QtCore/qvarlengtharray.h
+-
+QtCore/qobjectdefs.h
+-
+new
+-
+vector
+-
+list
+-
+map
+-
+
+/usr/include/qt/QtCore/qmutex.h
+QtCore/qglobal.h
+-
+QtCore/qatomic.h
+-
+new
+-
+chrono
+-
+limits
+-
+
+/usr/include/qt/QtCore/qnamespace.h
+QtCore/qglobal.h
+-
+
+/usr/include/qt/QtCore/qnumeric.h
+QtCore/qglobal.h
+-
+
+/usr/include/qt/QtCore/qobject.h
+QtCore/qobjectdefs.h
+-
+QtCore/qstring.h
+-
+QtCore/qbytearray.h
+-
+QtCore/qlist.h
+-
+QtCore/qcoreevent.h
+-
+QtCore/qscopedpointer.h
+-
+QtCore/qmetatype.h
+-
+QtCore/qobject_impl.h
+-
+chrono
+-
+
+/usr/include/qt/QtCore/qobject_impl.h
+
+/usr/include/qt/QtCore/qobjectdefs.h
+QtCore/qnamespace.h
+-
+QtCore/qobjectdefs_impl.h
+-
+
+/usr/include/qt/QtCore/qobjectdefs_impl.h
+QtCore/qnamespace.h
+-
+
+/usr/include/qt/QtCore/qpair.h
+QtCore/qglobal.h
+-
+
+/usr/include/qt/QtCore/qpoint.h
+QtCore/qnamespace.h
+-
+
+/usr/include/qt/QtCore/qprocessordetection.h
+QtCore/qglobal.h
+-
+
+/usr/include/qt/QtCore/qrefcount.h
+QtCore/qatomic.h
+-
+
+/usr/include/qt/QtCore/qregexp.h
+QtCore/qglobal.h
+-
+QtCore/qstring.h
+-
+
+/usr/include/qt/QtCore/qsavefile.h
+QtCore/qglobal.h
+-
+QtCore/qfiledevice.h
+-
+QtCore/qstring.h
+-
+
+/usr/include/qt/QtCore/qscopedpointer.h
+QtCore/qglobal.h
+-
+stdlib.h
+-
+
+/usr/include/qt/QtCore/qset.h
+QtCore/qhash.h
+-
+QtCore/qcontainertools_impl.h
+-
+initializer_list
+-
+iterator
+-
+
+/usr/include/qt/QtCore/qshareddata.h
+QtCore/qglobal.h
+-
+QtCore/qatomic.h
+-
+QtCore/qhash.h
+-
+QtCore/qhashfunctions.h
+-
+
+/usr/include/qt/QtCore/qsharedpointer.h
+QtCore/qglobal.h
+-
+QtCore/qatomic.h
+-
+QtCore/qshareddata.h
+-
+QtCore/qsharedpointer_impl.h
+-
+memory
+-
+
+/usr/include/qt/QtCore/qsharedpointer_impl.h
+new
+-
+QtCore/qatomic.h
+-
+QtCore/qobject.h
+-
+QtCore/qhash.h
+-
+QtCore/qhashfunctions.h
+-
+memory
+-
+
+/usr/include/qt/QtCore/qstring.h
+QtCore/qchar.h
+-
+QtCore/qbytearray.h
+-
+QtCore/qrefcount.h
+-
+QtCore/qnamespace.h
+-
+QtCore/qstringliteral.h
+-
+QtCore/qstringalgorithms.h
+-
+QtCore/qstringview.h
+-
+string
+-
+iterator
+-
+stdarg.h
+-
+QtCore/qstringbuilder.h
+-
+
+/usr/include/qt/QtCore/qstringalgorithms.h
+QtCore/qnamespace.h
+-
+
+/usr/include/qt/QtCore/qstringbuilder.h
+QtCore/qstring.h
+-
+QtCore/qbytearray.h
+-
+string.h
+-
+
+/usr/include/qt/QtCore/qstringlist.h
+QtCore/qlist.h
+-
+QtCore/qalgorithms.h
+-
+QtCore/qcontainertools_impl.h
+-
+QtCore/qregexp.h
+-
+QtCore/qstring.h
+-
+QtCore/qstringmatcher.h
+-
+
+/usr/include/qt/QtCore/qstringliteral.h
+QtCore/qarraydata.h
+-
+
+/usr/include/qt/QtCore/qstringmatcher.h
+QtCore/qstring.h
+-
+QtCore/qstringview.h
+-
+
+/usr/include/qt/QtCore/qstringview.h
+QtCore/qchar.h
+-
+QtCore/qbytearray.h
+-
+QtCore/qstringliteral.h
+-
+QtCore/qstringalgorithms.h
+-
+string
+-
+
+/usr/include/qt/QtCore/qsysinfo.h
+QtCore/qglobal.h
+-
+
+/usr/include/qt/QtCore/qsystemdetection.h
+QtCore/qglobal.h
+-
+TargetConditionals.h
+-
+Availability.h
+-
+AvailabilityMacros.h
+-
+
+/usr/include/qt/QtCore/qtcore-config.h
+
+/usr/include/qt/QtCore/qtextcodec.h
+QtCore/qstring.h
+-
+QtCore/qlist.h
+-
+
+/usr/include/qt/QtCore/qtextstream.h
+QtCore/qiodevice.h
+-
+QtCore/qstring.h
+-
+QtCore/qchar.h
+-
+QtCore/qlocale.h
+-
+QtCore/qscopedpointer.h
+-
+stdio.h
+-
+
+/usr/include/qt/QtCore/qtypeinfo.h
+QtCore/qglobal.h
+-
+
+/usr/include/qt/QtCore/qvariant.h
+QtCore/qatomic.h
+-
+QtCore/qbytearray.h
+-
+QtCore/qlist.h
+-
+QtCore/qmetatype.h
+-
+QtCore/qmap.h
+-
+QtCore/qhash.h
+-
+QtCore/qstring.h
+-
+QtCore/qstringlist.h
+-
+QtCore/qobject.h
+-
+QtCore/qbytearraylist.h
+-
+variant
+-
+
+/usr/include/qt/QtCore/qvarlengtharray.h
+QtCore/qcontainerfwd.h
+-
+QtCore/qglobal.h
+-
+QtCore/qalgorithms.h
+-
+QtCore/qcontainertools_impl.h
+-
+QtCore/qhashfunctions.h
+-
+algorithm
+-
+initializer_list
+-
+iterator
+-
+new
+-
+string.h
+-
+stdlib.h
+-
+
+/usr/include/qt/QtCore/qvector.h
+QtCore/qalgorithms.h
+-
+QtCore/qiterator.h
+-
+QtCore/qrefcount.h
+-
+QtCore/qarraydata.h
+-
+QtCore/qhashfunctions.h
+-
+QtCore/qcontainertools_impl.h
+-
+iterator
+-
+initializer_list
+-
+vector
+-
+stdlib.h
+-
+string.h
+-
+algorithm
+-
+QtCore/qpoint.h
+-
+
+/usr/include/qt/QtCore/qversiontagging.h
+QtCore/qglobal.h
+-
+
diff -ruN ./CMakeFiles/QuaZip.dir/DependInfo.cmake ../../dep/quazip/quazip/CMakeFiles/QuaZip.dir/DependInfo.cmake
--- ./CMakeFiles/QuaZip.dir/DependInfo.cmake	1970-01-01 02:00:00.000000000 +0200
+++ ../../dep/quazip/quazip/CMakeFiles/QuaZip.dir/DependInfo.cmake	2020-11-27 04:08:37.015850049 +0200
@@ -0,0 +1,77 @@
+# The set of languages for which implicit dependencies are needed:
+set(CMAKE_DEPENDS_LANGUAGES
+  "C"
+  "CXX"
+  )
+# The set of files for implicit dependencies of each language:
+set(CMAKE_DEPENDS_CHECK_C
+  "/home/dash/dev/Orayta-QT/dep/quazip/quazip/unzip.c" "/home/dash/dev/Orayta-QT/dep/quazip/quazip/CMakeFiles/QuaZip.dir/unzip.c.o"
+  "/home/dash/dev/Orayta-QT/dep/quazip/quazip/zip.c" "/home/dash/dev/Orayta-QT/dep/quazip/quazip/CMakeFiles/QuaZip.dir/zip.c.o"
+  )
+set(CMAKE_C_COMPILER_ID "GNU")
+
+# Preprocessor definitions for this target.
+set(CMAKE_TARGET_DEFINITIONS_C
+  "QT_CORE_LIB"
+  "QT_NO_DEBUG"
+  "QUAZIP_BUILD"
+  "QuaZip_EXPORTS"
+  )
+
+# The include file search paths:
+set(CMAKE_C_TARGET_INCLUDE_PATH
+  "quazip"
+  "quazip/QuaZip_autogen/include"
+  "."
+  "/usr/include/qt"
+  "/usr/include/qt/QtCore"
+  "/usr/lib/qt/mkspecs/linux-g++"
+  )
+set(CMAKE_DEPENDS_CHECK_CXX
+  "/home/dash/dev/Orayta-QT/dep/quazip/quazip/JlCompress.cpp" "/home/dash/dev/Orayta-QT/dep/quazip/quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o"
+  "/home/dash/dev/Orayta-QT/dep/quazip/quazip/QuaZip_autogen/mocs_compilation.cpp" "/home/dash/dev/Orayta-QT/dep/quazip/quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o"
+  "/home/dash/dev/Orayta-QT/dep/quazip/quazip/qioapi.cpp" "/home/dash/dev/Orayta-QT/dep/quazip/quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o"
+  "/home/dash/dev/Orayta-QT/dep/quazip/quazip/quaadler32.cpp" "/home/dash/dev/Orayta-QT/dep/quazip/quazip/CMakeFiles/QuaZip.dir/quaadler32.cpp.o"
+  "/home/dash/dev/Orayta-QT/dep/quazip/quazip/quachecksum32.cpp" "/home/dash/dev/Orayta-QT/dep/quazip/quazip/CMakeFiles/QuaZip.dir/quachecksum32.cpp.o"
+  "/home/dash/dev/Orayta-QT/dep/quazip/quazip/quacrc32.cpp" "/home/dash/dev/Orayta-QT/dep/quazip/quazip/CMakeFiles/QuaZip.dir/quacrc32.cpp.o"
+  "/home/dash/dev/Orayta-QT/dep/quazip/quazip/quagzipfile.cpp" "/home/dash/dev/Orayta-QT/dep/quazip/quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o"
+  "/home/dash/dev/Orayta-QT/dep/quazip/quazip/quaziodevice.cpp" "/home/dash/dev/Orayta-QT/dep/quazip/quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o"
+  "/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip.cpp" "/home/dash/dev/Orayta-QT/dep/quazip/quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o"
+  "/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipdir.cpp" "/home/dash/dev/Orayta-QT/dep/quazip/quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o"
+  "/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipfile.cpp" "/home/dash/dev/Orayta-QT/dep/quazip/quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o"
+  "/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipfileinfo.cpp" "/home/dash/dev/Orayta-QT/dep/quazip/quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o"
+  "/home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipnewinfo.cpp" "/home/dash/dev/Orayta-QT/dep/quazip/quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o"
+  )
+set(CMAKE_CXX_COMPILER_ID "GNU")
+
+# Preprocessor definitions for this target.
+set(CMAKE_TARGET_DEFINITIONS_CXX
+  "QT_CORE_LIB"
+  "QT_NO_DEBUG"
+  "QUAZIP_BUILD"
+  "QuaZip_EXPORTS"
+  )
+
+# The include file search paths:
+set(CMAKE_CXX_TARGET_INCLUDE_PATH
+  "quazip"
+  "quazip/QuaZip_autogen/include"
+  "."
+  "/usr/include/qt"
+  "/usr/include/qt/QtCore"
+  "/usr/lib/qt/mkspecs/linux-g++"
+  )
+
+# Pairs of files generated by the same build rule.
+set(CMAKE_MULTIPLE_OUTPUT_PAIRS
+  "/home/dash/dev/Orayta-QT/dep/quazip/quazip/libquazip1-qt5.so" "/home/dash/dev/Orayta-QT/dep/quazip/quazip/libquazip1-qt5.so.1.1"
+  "/home/dash/dev/Orayta-QT/dep/quazip/quazip/libquazip1-qt5.so.1.0.0" "/home/dash/dev/Orayta-QT/dep/quazip/quazip/libquazip1-qt5.so.1.1"
+  )
+
+
+# Targets to which this target links.
+set(CMAKE_TARGET_LINKED_INFO_FILES
+  )
+
+# Fortran module output directory.
+set(CMAKE_Fortran_TARGET_MODULE_DIR "")
diff -ruN ./CMakeFiles/QuaZip.dir/depend.internal ../../dep/quazip/quazip/CMakeFiles/QuaZip.dir/depend.internal
--- ./CMakeFiles/QuaZip.dir/depend.internal	1970-01-01 02:00:00.000000000 +0200
+++ ../../dep/quazip/quazip/CMakeFiles/QuaZip.dir/depend.internal	2020-11-27 04:08:38.322516667 +0200
@@ -0,0 +1,1011 @@
+# CMAKE generated file: DO NOT EDIT!
+# Generated by "Unix Makefiles" Generator, CMake Version 3.19
+
+quazip/CMakeFiles/QuaZip.dir/unzip.c.o
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/ioapi.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/minizip_crypt.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip_global.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/unzip.c
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/unzip.h
+ /usr/include/qt/QtCore/QtGlobal
+ /usr/include/qt/QtCore/qatomic.h
+ /usr/include/qt/QtCore/qatomic_bootstrap.h
+ /usr/include/qt/QtCore/qatomic_cxx11.h
+ /usr/include/qt/QtCore/qatomic_msvc.h
+ /usr/include/qt/QtCore/qbasicatomic.h
+ /usr/include/qt/QtCore/qcompilerdetection.h
+ /usr/include/qt/QtCore/qconfig-bootstrapped.h
+ /usr/include/qt/QtCore/qconfig.h
+ /usr/include/qt/QtCore/qflags.h
+ /usr/include/qt/QtCore/qgenericatomic.h
+ /usr/include/qt/QtCore/qglobal.h
+ /usr/include/qt/QtCore/qglobalstatic.h
+ /usr/include/qt/QtCore/qlogging.h
+ /usr/include/qt/QtCore/qmutex.h
+ /usr/include/qt/QtCore/qnumeric.h
+ /usr/include/qt/QtCore/qprocessordetection.h
+ /usr/include/qt/QtCore/qsysinfo.h
+ /usr/include/qt/QtCore/qsystemdetection.h
+ /usr/include/qt/QtCore/qtcore-config.h
+ /usr/include/qt/QtCore/qtypeinfo.h
+ /usr/include/qt/QtCore/qversiontagging.h
+quazip/CMakeFiles/QuaZip.dir/zip.c.o
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/ioapi.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/minizip_crypt.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip_global.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/zip.c
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/zip.h
+ /usr/include/qt/QtCore/QtGlobal
+ /usr/include/qt/QtCore/qatomic.h
+ /usr/include/qt/QtCore/qatomic_bootstrap.h
+ /usr/include/qt/QtCore/qatomic_cxx11.h
+ /usr/include/qt/QtCore/qatomic_msvc.h
+ /usr/include/qt/QtCore/qbasicatomic.h
+ /usr/include/qt/QtCore/qcompilerdetection.h
+ /usr/include/qt/QtCore/qconfig-bootstrapped.h
+ /usr/include/qt/QtCore/qconfig.h
+ /usr/include/qt/QtCore/qflags.h
+ /usr/include/qt/QtCore/qgenericatomic.h
+ /usr/include/qt/QtCore/qglobal.h
+ /usr/include/qt/QtCore/qglobalstatic.h
+ /usr/include/qt/QtCore/qlogging.h
+ /usr/include/qt/QtCore/qmutex.h
+ /usr/include/qt/QtCore/qnumeric.h
+ /usr/include/qt/QtCore/qprocessordetection.h
+ /usr/include/qt/QtCore/qsysinfo.h
+ /usr/include/qt/QtCore/qsystemdetection.h
+ /usr/include/qt/QtCore/qtcore-config.h
+ /usr/include/qt/QtCore/qtypeinfo.h
+ /usr/include/qt/QtCore/qversiontagging.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/JlCompress.cpp
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/JlCompress.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/ioapi.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip_global.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip_qt_compat.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipfile.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipfileinfo.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipnewinfo.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/unzip.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/zip.h
+ /usr/include/qt/QtCore/QByteArray
+ /usr/include/qt/QtCore/QDateTime
+ /usr/include/qt/QtCore/QDir
+ /usr/include/qt/QtCore/QFile
+ /usr/include/qt/QtCore/QFileInfo
+ /usr/include/qt/QtCore/QHash
+ /usr/include/qt/QtCore/QIODevice
+ /usr/include/qt/QtCore/QList
+ /usr/include/qt/QtCore/QSaveFile
+ /usr/include/qt/QtCore/QString
+ /usr/include/qt/QtCore/QStringList
+ /usr/include/qt/QtCore/QTextCodec
+ /usr/include/qt/QtCore/QTextStream
+ /usr/include/qt/QtCore/Qt
+ /usr/include/qt/QtCore/QtAlgorithms
+ /usr/include/qt/QtCore/QtGlobal
+ /usr/include/qt/QtCore/qalgorithms.h
+ /usr/include/qt/QtCore/qarraydata.h
+ /usr/include/qt/QtCore/qatomic.h
+ /usr/include/qt/QtCore/qatomic_bootstrap.h
+ /usr/include/qt/QtCore/qatomic_cxx11.h
+ /usr/include/qt/QtCore/qatomic_msvc.h
+ /usr/include/qt/QtCore/qbasicatomic.h
+ /usr/include/qt/QtCore/qbytearray.h
+ /usr/include/qt/QtCore/qbytearraylist.h
+ /usr/include/qt/QtCore/qchar.h
+ /usr/include/qt/QtCore/qcompilerdetection.h
+ /usr/include/qt/QtCore/qconfig-bootstrapped.h
+ /usr/include/qt/QtCore/qconfig.h
+ /usr/include/qt/QtCore/qcontainerfwd.h
+ /usr/include/qt/QtCore/qcontainertools_impl.h
+ /usr/include/qt/QtCore/qcontiguouscache.h
+ /usr/include/qt/QtCore/qcoreevent.h
+ /usr/include/qt/QtCore/qdatetime.h
+ /usr/include/qt/QtCore/qdebug.h
+ /usr/include/qt/QtCore/qdir.h
+ /usr/include/qt/QtCore/qfile.h
+ /usr/include/qt/QtCore/qfiledevice.h
+ /usr/include/qt/QtCore/qfileinfo.h
+ /usr/include/qt/QtCore/qflags.h
+ /usr/include/qt/QtCore/qgenericatomic.h
+ /usr/include/qt/QtCore/qglobal.h
+ /usr/include/qt/QtCore/qglobalstatic.h
+ /usr/include/qt/QtCore/qhash.h
+ /usr/include/qt/QtCore/qhashfunctions.h
+ /usr/include/qt/QtCore/qiodevice.h
+ /usr/include/qt/QtCore/qiterator.h
+ /usr/include/qt/QtCore/qlist.h
+ /usr/include/qt/QtCore/qlocale.h
+ /usr/include/qt/QtCore/qlogging.h
+ /usr/include/qt/QtCore/qmap.h
+ /usr/include/qt/QtCore/qmetatype.h
+ /usr/include/qt/QtCore/qmutex.h
+ /usr/include/qt/QtCore/qnamespace.h
+ /usr/include/qt/QtCore/qnumeric.h
+ /usr/include/qt/QtCore/qobject.h
+ /usr/include/qt/QtCore/qobject_impl.h
+ /usr/include/qt/QtCore/qobjectdefs.h
+ /usr/include/qt/QtCore/qobjectdefs_impl.h
+ /usr/include/qt/QtCore/qpair.h
+ /usr/include/qt/QtCore/qpoint.h
+ /usr/include/qt/QtCore/qprocessordetection.h
+ /usr/include/qt/QtCore/qrefcount.h
+ /usr/include/qt/QtCore/qregexp.h
+ /usr/include/qt/QtCore/qsavefile.h
+ /usr/include/qt/QtCore/qscopedpointer.h
+ /usr/include/qt/QtCore/qset.h
+ /usr/include/qt/QtCore/qshareddata.h
+ /usr/include/qt/QtCore/qsharedpointer.h
+ /usr/include/qt/QtCore/qsharedpointer_impl.h
+ /usr/include/qt/QtCore/qstring.h
+ /usr/include/qt/QtCore/qstringalgorithms.h
+ /usr/include/qt/QtCore/qstringbuilder.h
+ /usr/include/qt/QtCore/qstringlist.h
+ /usr/include/qt/QtCore/qstringliteral.h
+ /usr/include/qt/QtCore/qstringmatcher.h
+ /usr/include/qt/QtCore/qstringview.h
+ /usr/include/qt/QtCore/qsysinfo.h
+ /usr/include/qt/QtCore/qsystemdetection.h
+ /usr/include/qt/QtCore/qtcore-config.h
+ /usr/include/qt/QtCore/qtextcodec.h
+ /usr/include/qt/QtCore/qtextstream.h
+ /usr/include/qt/QtCore/qtypeinfo.h
+ /usr/include/qt/QtCore/qvariant.h
+ /usr/include/qt/QtCore/qvarlengtharray.h
+ /usr/include/qt/QtCore/qvector.h
+ /usr/include/qt/QtCore/qversiontagging.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/QuaZip_autogen/EWIEGA46WW/moc_quagzipfile.cpp
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/QuaZip_autogen/EWIEGA46WW/moc_quaziodevice.cpp
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/QuaZip_autogen/EWIEGA46WW/moc_quazipfile.cpp
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/QuaZip_autogen/mocs_compilation.cpp
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/ioapi.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quagzipfile.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quaziodevice.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip_global.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip_qt_compat.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipfile.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipfileinfo.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipnewinfo.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/unzip.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/zip.h
+ /usr/include/qt/QtCore/QByteArray
+ /usr/include/qt/QtCore/QDateTime
+ /usr/include/qt/QtCore/QFile
+ /usr/include/qt/QtCore/QFileInfo
+ /usr/include/qt/QtCore/QHash
+ /usr/include/qt/QtCore/QIODevice
+ /usr/include/qt/QtCore/QList
+ /usr/include/qt/QtCore/QSaveFile
+ /usr/include/qt/QtCore/QString
+ /usr/include/qt/QtCore/QStringList
+ /usr/include/qt/QtCore/QTextCodec
+ /usr/include/qt/QtCore/QTextStream
+ /usr/include/qt/QtCore/Qt
+ /usr/include/qt/QtCore/QtAlgorithms
+ /usr/include/qt/QtCore/QtGlobal
+ /usr/include/qt/QtCore/qalgorithms.h
+ /usr/include/qt/QtCore/qarraydata.h
+ /usr/include/qt/QtCore/qatomic.h
+ /usr/include/qt/QtCore/qatomic_bootstrap.h
+ /usr/include/qt/QtCore/qatomic_cxx11.h
+ /usr/include/qt/QtCore/qatomic_msvc.h
+ /usr/include/qt/QtCore/qbasicatomic.h
+ /usr/include/qt/QtCore/qbytearray.h
+ /usr/include/qt/QtCore/qbytearraylist.h
+ /usr/include/qt/QtCore/qchar.h
+ /usr/include/qt/QtCore/qcompilerdetection.h
+ /usr/include/qt/QtCore/qconfig-bootstrapped.h
+ /usr/include/qt/QtCore/qconfig.h
+ /usr/include/qt/QtCore/qcontainerfwd.h
+ /usr/include/qt/QtCore/qcontainertools_impl.h
+ /usr/include/qt/QtCore/qcontiguouscache.h
+ /usr/include/qt/QtCore/qcoreevent.h
+ /usr/include/qt/QtCore/qdatetime.h
+ /usr/include/qt/QtCore/qdebug.h
+ /usr/include/qt/QtCore/qfile.h
+ /usr/include/qt/QtCore/qfiledevice.h
+ /usr/include/qt/QtCore/qfileinfo.h
+ /usr/include/qt/QtCore/qflags.h
+ /usr/include/qt/QtCore/qgenericatomic.h
+ /usr/include/qt/QtCore/qglobal.h
+ /usr/include/qt/QtCore/qglobalstatic.h
+ /usr/include/qt/QtCore/qhash.h
+ /usr/include/qt/QtCore/qhashfunctions.h
+ /usr/include/qt/QtCore/qiodevice.h
+ /usr/include/qt/QtCore/qiterator.h
+ /usr/include/qt/QtCore/qlist.h
+ /usr/include/qt/QtCore/qlocale.h
+ /usr/include/qt/QtCore/qlogging.h
+ /usr/include/qt/QtCore/qmap.h
+ /usr/include/qt/QtCore/qmetatype.h
+ /usr/include/qt/QtCore/qmutex.h
+ /usr/include/qt/QtCore/qnamespace.h
+ /usr/include/qt/QtCore/qnumeric.h
+ /usr/include/qt/QtCore/qobject.h
+ /usr/include/qt/QtCore/qobject_impl.h
+ /usr/include/qt/QtCore/qobjectdefs.h
+ /usr/include/qt/QtCore/qobjectdefs_impl.h
+ /usr/include/qt/QtCore/qpair.h
+ /usr/include/qt/QtCore/qpoint.h
+ /usr/include/qt/QtCore/qprocessordetection.h
+ /usr/include/qt/QtCore/qrefcount.h
+ /usr/include/qt/QtCore/qregexp.h
+ /usr/include/qt/QtCore/qsavefile.h
+ /usr/include/qt/QtCore/qscopedpointer.h
+ /usr/include/qt/QtCore/qset.h
+ /usr/include/qt/QtCore/qshareddata.h
+ /usr/include/qt/QtCore/qsharedpointer.h
+ /usr/include/qt/QtCore/qsharedpointer_impl.h
+ /usr/include/qt/QtCore/qstring.h
+ /usr/include/qt/QtCore/qstringalgorithms.h
+ /usr/include/qt/QtCore/qstringbuilder.h
+ /usr/include/qt/QtCore/qstringlist.h
+ /usr/include/qt/QtCore/qstringliteral.h
+ /usr/include/qt/QtCore/qstringmatcher.h
+ /usr/include/qt/QtCore/qstringview.h
+ /usr/include/qt/QtCore/qsysinfo.h
+ /usr/include/qt/QtCore/qsystemdetection.h
+ /usr/include/qt/QtCore/qtcore-config.h
+ /usr/include/qt/QtCore/qtextcodec.h
+ /usr/include/qt/QtCore/qtextstream.h
+ /usr/include/qt/QtCore/qtypeinfo.h
+ /usr/include/qt/QtCore/qvariant.h
+ /usr/include/qt/QtCore/qvarlengtharray.h
+ /usr/include/qt/QtCore/qvector.h
+ /usr/include/qt/QtCore/qversiontagging.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/ioapi.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/qioapi.cpp
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip_global.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip_qt_compat.h
+ /usr/include/qt/QtCore/QDateTime
+ /usr/include/qt/QtCore/QFileInfo
+ /usr/include/qt/QtCore/QIODevice
+ /usr/include/qt/QtCore/QList
+ /usr/include/qt/QtCore/QSaveFile
+ /usr/include/qt/QtCore/QString
+ /usr/include/qt/QtCore/QTextCodec
+ /usr/include/qt/QtCore/QTextStream
+ /usr/include/qt/QtCore/Qt
+ /usr/include/qt/QtCore/QtAlgorithms
+ /usr/include/qt/QtCore/QtGlobal
+ /usr/include/qt/QtCore/qalgorithms.h
+ /usr/include/qt/QtCore/qarraydata.h
+ /usr/include/qt/QtCore/qatomic.h
+ /usr/include/qt/QtCore/qatomic_bootstrap.h
+ /usr/include/qt/QtCore/qatomic_cxx11.h
+ /usr/include/qt/QtCore/qatomic_msvc.h
+ /usr/include/qt/QtCore/qbasicatomic.h
+ /usr/include/qt/QtCore/qbytearray.h
+ /usr/include/qt/QtCore/qbytearraylist.h
+ /usr/include/qt/QtCore/qchar.h
+ /usr/include/qt/QtCore/qcompilerdetection.h
+ /usr/include/qt/QtCore/qconfig-bootstrapped.h
+ /usr/include/qt/QtCore/qconfig.h
+ /usr/include/qt/QtCore/qcontainerfwd.h
+ /usr/include/qt/QtCore/qcontainertools_impl.h
+ /usr/include/qt/QtCore/qcontiguouscache.h
+ /usr/include/qt/QtCore/qcoreevent.h
+ /usr/include/qt/QtCore/qdatetime.h
+ /usr/include/qt/QtCore/qdebug.h
+ /usr/include/qt/QtCore/qfile.h
+ /usr/include/qt/QtCore/qfiledevice.h
+ /usr/include/qt/QtCore/qfileinfo.h
+ /usr/include/qt/QtCore/qflags.h
+ /usr/include/qt/QtCore/qgenericatomic.h
+ /usr/include/qt/QtCore/qglobal.h
+ /usr/include/qt/QtCore/qglobalstatic.h
+ /usr/include/qt/QtCore/qhash.h
+ /usr/include/qt/QtCore/qhashfunctions.h
+ /usr/include/qt/QtCore/qiodevice.h
+ /usr/include/qt/QtCore/qiterator.h
+ /usr/include/qt/QtCore/qlist.h
+ /usr/include/qt/QtCore/qlocale.h
+ /usr/include/qt/QtCore/qlogging.h
+ /usr/include/qt/QtCore/qmap.h
+ /usr/include/qt/QtCore/qmetatype.h
+ /usr/include/qt/QtCore/qmutex.h
+ /usr/include/qt/QtCore/qnamespace.h
+ /usr/include/qt/QtCore/qnumeric.h
+ /usr/include/qt/QtCore/qobject.h
+ /usr/include/qt/QtCore/qobject_impl.h
+ /usr/include/qt/QtCore/qobjectdefs.h
+ /usr/include/qt/QtCore/qobjectdefs_impl.h
+ /usr/include/qt/QtCore/qpair.h
+ /usr/include/qt/QtCore/qpoint.h
+ /usr/include/qt/QtCore/qprocessordetection.h
+ /usr/include/qt/QtCore/qrefcount.h
+ /usr/include/qt/QtCore/qregexp.h
+ /usr/include/qt/QtCore/qsavefile.h
+ /usr/include/qt/QtCore/qscopedpointer.h
+ /usr/include/qt/QtCore/qset.h
+ /usr/include/qt/QtCore/qshareddata.h
+ /usr/include/qt/QtCore/qsharedpointer.h
+ /usr/include/qt/QtCore/qsharedpointer_impl.h
+ /usr/include/qt/QtCore/qstring.h
+ /usr/include/qt/QtCore/qstringalgorithms.h
+ /usr/include/qt/QtCore/qstringbuilder.h
+ /usr/include/qt/QtCore/qstringlist.h
+ /usr/include/qt/QtCore/qstringliteral.h
+ /usr/include/qt/QtCore/qstringmatcher.h
+ /usr/include/qt/QtCore/qstringview.h
+ /usr/include/qt/QtCore/qsysinfo.h
+ /usr/include/qt/QtCore/qsystemdetection.h
+ /usr/include/qt/QtCore/qtcore-config.h
+ /usr/include/qt/QtCore/qtextcodec.h
+ /usr/include/qt/QtCore/qtextstream.h
+ /usr/include/qt/QtCore/qtypeinfo.h
+ /usr/include/qt/QtCore/qvariant.h
+ /usr/include/qt/QtCore/qvarlengtharray.h
+ /usr/include/qt/QtCore/qvector.h
+ /usr/include/qt/QtCore/qversiontagging.h
+quazip/CMakeFiles/QuaZip.dir/quaadler32.cpp.o
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quaadler32.cpp
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quaadler32.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quachecksum32.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip_global.h
+ /usr/include/qt/QtCore/QByteArray
+ /usr/include/qt/QtCore/QtGlobal
+ /usr/include/qt/QtCore/qarraydata.h
+ /usr/include/qt/QtCore/qatomic.h
+ /usr/include/qt/QtCore/qatomic_bootstrap.h
+ /usr/include/qt/QtCore/qatomic_cxx11.h
+ /usr/include/qt/QtCore/qatomic_msvc.h
+ /usr/include/qt/QtCore/qbasicatomic.h
+ /usr/include/qt/QtCore/qbytearray.h
+ /usr/include/qt/QtCore/qcompilerdetection.h
+ /usr/include/qt/QtCore/qconfig-bootstrapped.h
+ /usr/include/qt/QtCore/qconfig.h
+ /usr/include/qt/QtCore/qflags.h
+ /usr/include/qt/QtCore/qgenericatomic.h
+ /usr/include/qt/QtCore/qglobal.h
+ /usr/include/qt/QtCore/qglobalstatic.h
+ /usr/include/qt/QtCore/qlogging.h
+ /usr/include/qt/QtCore/qmutex.h
+ /usr/include/qt/QtCore/qnamespace.h
+ /usr/include/qt/QtCore/qnumeric.h
+ /usr/include/qt/QtCore/qprocessordetection.h
+ /usr/include/qt/QtCore/qrefcount.h
+ /usr/include/qt/QtCore/qsysinfo.h
+ /usr/include/qt/QtCore/qsystemdetection.h
+ /usr/include/qt/QtCore/qtcore-config.h
+ /usr/include/qt/QtCore/qtypeinfo.h
+ /usr/include/qt/QtCore/qversiontagging.h
+quazip/CMakeFiles/QuaZip.dir/quachecksum32.cpp.o
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quachecksum32.cpp
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quachecksum32.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip_global.h
+ /usr/include/qt/QtCore/QByteArray
+ /usr/include/qt/QtCore/QtGlobal
+ /usr/include/qt/QtCore/qarraydata.h
+ /usr/include/qt/QtCore/qatomic.h
+ /usr/include/qt/QtCore/qatomic_bootstrap.h
+ /usr/include/qt/QtCore/qatomic_cxx11.h
+ /usr/include/qt/QtCore/qatomic_msvc.h
+ /usr/include/qt/QtCore/qbasicatomic.h
+ /usr/include/qt/QtCore/qbytearray.h
+ /usr/include/qt/QtCore/qcompilerdetection.h
+ /usr/include/qt/QtCore/qconfig-bootstrapped.h
+ /usr/include/qt/QtCore/qconfig.h
+ /usr/include/qt/QtCore/qflags.h
+ /usr/include/qt/QtCore/qgenericatomic.h
+ /usr/include/qt/QtCore/qglobal.h
+ /usr/include/qt/QtCore/qglobalstatic.h
+ /usr/include/qt/QtCore/qlogging.h
+ /usr/include/qt/QtCore/qmutex.h
+ /usr/include/qt/QtCore/qnamespace.h
+ /usr/include/qt/QtCore/qnumeric.h
+ /usr/include/qt/QtCore/qprocessordetection.h
+ /usr/include/qt/QtCore/qrefcount.h
+ /usr/include/qt/QtCore/qsysinfo.h
+ /usr/include/qt/QtCore/qsystemdetection.h
+ /usr/include/qt/QtCore/qtcore-config.h
+ /usr/include/qt/QtCore/qtypeinfo.h
+ /usr/include/qt/QtCore/qversiontagging.h
+quazip/CMakeFiles/QuaZip.dir/quacrc32.cpp.o
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quachecksum32.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quacrc32.cpp
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quacrc32.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip_global.h
+ /usr/include/qt/QtCore/QByteArray
+ /usr/include/qt/QtCore/QtGlobal
+ /usr/include/qt/QtCore/qarraydata.h
+ /usr/include/qt/QtCore/qatomic.h
+ /usr/include/qt/QtCore/qatomic_bootstrap.h
+ /usr/include/qt/QtCore/qatomic_cxx11.h
+ /usr/include/qt/QtCore/qatomic_msvc.h
+ /usr/include/qt/QtCore/qbasicatomic.h
+ /usr/include/qt/QtCore/qbytearray.h
+ /usr/include/qt/QtCore/qcompilerdetection.h
+ /usr/include/qt/QtCore/qconfig-bootstrapped.h
+ /usr/include/qt/QtCore/qconfig.h
+ /usr/include/qt/QtCore/qflags.h
+ /usr/include/qt/QtCore/qgenericatomic.h
+ /usr/include/qt/QtCore/qglobal.h
+ /usr/include/qt/QtCore/qglobalstatic.h
+ /usr/include/qt/QtCore/qlogging.h
+ /usr/include/qt/QtCore/qmutex.h
+ /usr/include/qt/QtCore/qnamespace.h
+ /usr/include/qt/QtCore/qnumeric.h
+ /usr/include/qt/QtCore/qprocessordetection.h
+ /usr/include/qt/QtCore/qrefcount.h
+ /usr/include/qt/QtCore/qsysinfo.h
+ /usr/include/qt/QtCore/qsystemdetection.h
+ /usr/include/qt/QtCore/qtcore-config.h
+ /usr/include/qt/QtCore/qtypeinfo.h
+ /usr/include/qt/QtCore/qversiontagging.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quagzipfile.cpp
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quagzipfile.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip_global.h
+ /usr/include/qt/QtCore/QFile
+ /usr/include/qt/QtCore/QIODevice
+ /usr/include/qt/QtCore/QtGlobal
+ /usr/include/qt/QtCore/qalgorithms.h
+ /usr/include/qt/QtCore/qarraydata.h
+ /usr/include/qt/QtCore/qatomic.h
+ /usr/include/qt/QtCore/qatomic_bootstrap.h
+ /usr/include/qt/QtCore/qatomic_cxx11.h
+ /usr/include/qt/QtCore/qatomic_msvc.h
+ /usr/include/qt/QtCore/qbasicatomic.h
+ /usr/include/qt/QtCore/qbytearray.h
+ /usr/include/qt/QtCore/qbytearraylist.h
+ /usr/include/qt/QtCore/qchar.h
+ /usr/include/qt/QtCore/qcompilerdetection.h
+ /usr/include/qt/QtCore/qconfig-bootstrapped.h
+ /usr/include/qt/QtCore/qconfig.h
+ /usr/include/qt/QtCore/qcontainerfwd.h
+ /usr/include/qt/QtCore/qcontainertools_impl.h
+ /usr/include/qt/QtCore/qcoreevent.h
+ /usr/include/qt/QtCore/qfile.h
+ /usr/include/qt/QtCore/qfiledevice.h
+ /usr/include/qt/QtCore/qflags.h
+ /usr/include/qt/QtCore/qgenericatomic.h
+ /usr/include/qt/QtCore/qglobal.h
+ /usr/include/qt/QtCore/qglobalstatic.h
+ /usr/include/qt/QtCore/qhashfunctions.h
+ /usr/include/qt/QtCore/qiodevice.h
+ /usr/include/qt/QtCore/qiterator.h
+ /usr/include/qt/QtCore/qlist.h
+ /usr/include/qt/QtCore/qlogging.h
+ /usr/include/qt/QtCore/qmetatype.h
+ /usr/include/qt/QtCore/qmutex.h
+ /usr/include/qt/QtCore/qnamespace.h
+ /usr/include/qt/QtCore/qnumeric.h
+ /usr/include/qt/QtCore/qobject.h
+ /usr/include/qt/QtCore/qobject_impl.h
+ /usr/include/qt/QtCore/qobjectdefs.h
+ /usr/include/qt/QtCore/qobjectdefs_impl.h
+ /usr/include/qt/QtCore/qpair.h
+ /usr/include/qt/QtCore/qpoint.h
+ /usr/include/qt/QtCore/qprocessordetection.h
+ /usr/include/qt/QtCore/qrefcount.h
+ /usr/include/qt/QtCore/qregexp.h
+ /usr/include/qt/QtCore/qscopedpointer.h
+ /usr/include/qt/QtCore/qstring.h
+ /usr/include/qt/QtCore/qstringalgorithms.h
+ /usr/include/qt/QtCore/qstringbuilder.h
+ /usr/include/qt/QtCore/qstringlist.h
+ /usr/include/qt/QtCore/qstringliteral.h
+ /usr/include/qt/QtCore/qstringmatcher.h
+ /usr/include/qt/QtCore/qstringview.h
+ /usr/include/qt/QtCore/qsysinfo.h
+ /usr/include/qt/QtCore/qsystemdetection.h
+ /usr/include/qt/QtCore/qtcore-config.h
+ /usr/include/qt/QtCore/qtypeinfo.h
+ /usr/include/qt/QtCore/qvarlengtharray.h
+ /usr/include/qt/QtCore/qvector.h
+ /usr/include/qt/QtCore/qversiontagging.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quaziodevice.cpp
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quaziodevice.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip_global.h
+ /usr/include/qt/QtCore/QFile
+ /usr/include/qt/QtCore/QIODevice
+ /usr/include/qt/QtCore/QtGlobal
+ /usr/include/qt/QtCore/qalgorithms.h
+ /usr/include/qt/QtCore/qarraydata.h
+ /usr/include/qt/QtCore/qatomic.h
+ /usr/include/qt/QtCore/qatomic_bootstrap.h
+ /usr/include/qt/QtCore/qatomic_cxx11.h
+ /usr/include/qt/QtCore/qatomic_msvc.h
+ /usr/include/qt/QtCore/qbasicatomic.h
+ /usr/include/qt/QtCore/qbytearray.h
+ /usr/include/qt/QtCore/qbytearraylist.h
+ /usr/include/qt/QtCore/qchar.h
+ /usr/include/qt/QtCore/qcompilerdetection.h
+ /usr/include/qt/QtCore/qconfig-bootstrapped.h
+ /usr/include/qt/QtCore/qconfig.h
+ /usr/include/qt/QtCore/qcontainerfwd.h
+ /usr/include/qt/QtCore/qcontainertools_impl.h
+ /usr/include/qt/QtCore/qcoreevent.h
+ /usr/include/qt/QtCore/qfile.h
+ /usr/include/qt/QtCore/qfiledevice.h
+ /usr/include/qt/QtCore/qflags.h
+ /usr/include/qt/QtCore/qgenericatomic.h
+ /usr/include/qt/QtCore/qglobal.h
+ /usr/include/qt/QtCore/qglobalstatic.h
+ /usr/include/qt/QtCore/qhashfunctions.h
+ /usr/include/qt/QtCore/qiodevice.h
+ /usr/include/qt/QtCore/qiterator.h
+ /usr/include/qt/QtCore/qlist.h
+ /usr/include/qt/QtCore/qlogging.h
+ /usr/include/qt/QtCore/qmetatype.h
+ /usr/include/qt/QtCore/qmutex.h
+ /usr/include/qt/QtCore/qnamespace.h
+ /usr/include/qt/QtCore/qnumeric.h
+ /usr/include/qt/QtCore/qobject.h
+ /usr/include/qt/QtCore/qobject_impl.h
+ /usr/include/qt/QtCore/qobjectdefs.h
+ /usr/include/qt/QtCore/qobjectdefs_impl.h
+ /usr/include/qt/QtCore/qpair.h
+ /usr/include/qt/QtCore/qpoint.h
+ /usr/include/qt/QtCore/qprocessordetection.h
+ /usr/include/qt/QtCore/qrefcount.h
+ /usr/include/qt/QtCore/qregexp.h
+ /usr/include/qt/QtCore/qscopedpointer.h
+ /usr/include/qt/QtCore/qstring.h
+ /usr/include/qt/QtCore/qstringalgorithms.h
+ /usr/include/qt/QtCore/qstringbuilder.h
+ /usr/include/qt/QtCore/qstringlist.h
+ /usr/include/qt/QtCore/qstringliteral.h
+ /usr/include/qt/QtCore/qstringmatcher.h
+ /usr/include/qt/QtCore/qstringview.h
+ /usr/include/qt/QtCore/qsysinfo.h
+ /usr/include/qt/QtCore/qsystemdetection.h
+ /usr/include/qt/QtCore/qtcore-config.h
+ /usr/include/qt/QtCore/qtypeinfo.h
+ /usr/include/qt/QtCore/qvarlengtharray.h
+ /usr/include/qt/QtCore/qvector.h
+ /usr/include/qt/QtCore/qversiontagging.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/ioapi.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip.cpp
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip_global.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip_qt_compat.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipfileinfo.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/unzip.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/zip.h
+ /usr/include/qt/QtCore/QByteArray
+ /usr/include/qt/QtCore/QDateTime
+ /usr/include/qt/QtCore/QFile
+ /usr/include/qt/QtCore/QFileInfo
+ /usr/include/qt/QtCore/QFlags
+ /usr/include/qt/QtCore/QHash
+ /usr/include/qt/QtCore/QList
+ /usr/include/qt/QtCore/QSaveFile
+ /usr/include/qt/QtCore/QString
+ /usr/include/qt/QtCore/QStringList
+ /usr/include/qt/QtCore/QTextCodec
+ /usr/include/qt/QtCore/QTextStream
+ /usr/include/qt/QtCore/Qt
+ /usr/include/qt/QtCore/QtAlgorithms
+ /usr/include/qt/QtCore/QtGlobal
+ /usr/include/qt/QtCore/qalgorithms.h
+ /usr/include/qt/QtCore/qarraydata.h
+ /usr/include/qt/QtCore/qatomic.h
+ /usr/include/qt/QtCore/qatomic_bootstrap.h
+ /usr/include/qt/QtCore/qatomic_cxx11.h
+ /usr/include/qt/QtCore/qatomic_msvc.h
+ /usr/include/qt/QtCore/qbasicatomic.h
+ /usr/include/qt/QtCore/qbytearray.h
+ /usr/include/qt/QtCore/qbytearraylist.h
+ /usr/include/qt/QtCore/qchar.h
+ /usr/include/qt/QtCore/qcompilerdetection.h
+ /usr/include/qt/QtCore/qconfig-bootstrapped.h
+ /usr/include/qt/QtCore/qconfig.h
+ /usr/include/qt/QtCore/qcontainerfwd.h
+ /usr/include/qt/QtCore/qcontainertools_impl.h
+ /usr/include/qt/QtCore/qcontiguouscache.h
+ /usr/include/qt/QtCore/qcoreevent.h
+ /usr/include/qt/QtCore/qdatetime.h
+ /usr/include/qt/QtCore/qdebug.h
+ /usr/include/qt/QtCore/qfile.h
+ /usr/include/qt/QtCore/qfiledevice.h
+ /usr/include/qt/QtCore/qfileinfo.h
+ /usr/include/qt/QtCore/qflags.h
+ /usr/include/qt/QtCore/qgenericatomic.h
+ /usr/include/qt/QtCore/qglobal.h
+ /usr/include/qt/QtCore/qglobalstatic.h
+ /usr/include/qt/QtCore/qhash.h
+ /usr/include/qt/QtCore/qhashfunctions.h
+ /usr/include/qt/QtCore/qiodevice.h
+ /usr/include/qt/QtCore/qiterator.h
+ /usr/include/qt/QtCore/qlist.h
+ /usr/include/qt/QtCore/qlocale.h
+ /usr/include/qt/QtCore/qlogging.h
+ /usr/include/qt/QtCore/qmap.h
+ /usr/include/qt/QtCore/qmetatype.h
+ /usr/include/qt/QtCore/qmutex.h
+ /usr/include/qt/QtCore/qnamespace.h
+ /usr/include/qt/QtCore/qnumeric.h
+ /usr/include/qt/QtCore/qobject.h
+ /usr/include/qt/QtCore/qobject_impl.h
+ /usr/include/qt/QtCore/qobjectdefs.h
+ /usr/include/qt/QtCore/qobjectdefs_impl.h
+ /usr/include/qt/QtCore/qpair.h
+ /usr/include/qt/QtCore/qpoint.h
+ /usr/include/qt/QtCore/qprocessordetection.h
+ /usr/include/qt/QtCore/qrefcount.h
+ /usr/include/qt/QtCore/qregexp.h
+ /usr/include/qt/QtCore/qsavefile.h
+ /usr/include/qt/QtCore/qscopedpointer.h
+ /usr/include/qt/QtCore/qset.h
+ /usr/include/qt/QtCore/qshareddata.h
+ /usr/include/qt/QtCore/qsharedpointer.h
+ /usr/include/qt/QtCore/qsharedpointer_impl.h
+ /usr/include/qt/QtCore/qstring.h
+ /usr/include/qt/QtCore/qstringalgorithms.h
+ /usr/include/qt/QtCore/qstringbuilder.h
+ /usr/include/qt/QtCore/qstringlist.h
+ /usr/include/qt/QtCore/qstringliteral.h
+ /usr/include/qt/QtCore/qstringmatcher.h
+ /usr/include/qt/QtCore/qstringview.h
+ /usr/include/qt/QtCore/qsysinfo.h
+ /usr/include/qt/QtCore/qsystemdetection.h
+ /usr/include/qt/QtCore/qtcore-config.h
+ /usr/include/qt/QtCore/qtextcodec.h
+ /usr/include/qt/QtCore/qtextstream.h
+ /usr/include/qt/QtCore/qtypeinfo.h
+ /usr/include/qt/QtCore/qvariant.h
+ /usr/include/qt/QtCore/qvarlengtharray.h
+ /usr/include/qt/QtCore/qvector.h
+ /usr/include/qt/QtCore/qversiontagging.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/ioapi.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip_global.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip_qt_compat.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipdir.cpp
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipdir.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipfileinfo.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/unzip.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/zip.h
+ /usr/include/qt/QtCore/QByteArray
+ /usr/include/qt/QtCore/QDateTime
+ /usr/include/qt/QtCore/QDir
+ /usr/include/qt/QtCore/QFile
+ /usr/include/qt/QtCore/QFileInfo
+ /usr/include/qt/QtCore/QHash
+ /usr/include/qt/QtCore/QList
+ /usr/include/qt/QtCore/QSaveFile
+ /usr/include/qt/QtCore/QSet
+ /usr/include/qt/QtCore/QSharedData
+ /usr/include/qt/QtCore/QSharedDataPointer
+ /usr/include/qt/QtCore/QString
+ /usr/include/qt/QtCore/QStringList
+ /usr/include/qt/QtCore/QTextCodec
+ /usr/include/qt/QtCore/QTextStream
+ /usr/include/qt/QtCore/Qt
+ /usr/include/qt/QtCore/QtAlgorithms
+ /usr/include/qt/QtCore/QtGlobal
+ /usr/include/qt/QtCore/qalgorithms.h
+ /usr/include/qt/QtCore/qarraydata.h
+ /usr/include/qt/QtCore/qatomic.h
+ /usr/include/qt/QtCore/qatomic_bootstrap.h
+ /usr/include/qt/QtCore/qatomic_cxx11.h
+ /usr/include/qt/QtCore/qatomic_msvc.h
+ /usr/include/qt/QtCore/qbasicatomic.h
+ /usr/include/qt/QtCore/qbytearray.h
+ /usr/include/qt/QtCore/qbytearraylist.h
+ /usr/include/qt/QtCore/qchar.h
+ /usr/include/qt/QtCore/qcompilerdetection.h
+ /usr/include/qt/QtCore/qconfig-bootstrapped.h
+ /usr/include/qt/QtCore/qconfig.h
+ /usr/include/qt/QtCore/qcontainerfwd.h
+ /usr/include/qt/QtCore/qcontainertools_impl.h
+ /usr/include/qt/QtCore/qcontiguouscache.h
+ /usr/include/qt/QtCore/qcoreevent.h
+ /usr/include/qt/QtCore/qdatetime.h
+ /usr/include/qt/QtCore/qdebug.h
+ /usr/include/qt/QtCore/qdir.h
+ /usr/include/qt/QtCore/qfile.h
+ /usr/include/qt/QtCore/qfiledevice.h
+ /usr/include/qt/QtCore/qfileinfo.h
+ /usr/include/qt/QtCore/qflags.h
+ /usr/include/qt/QtCore/qgenericatomic.h
+ /usr/include/qt/QtCore/qglobal.h
+ /usr/include/qt/QtCore/qglobalstatic.h
+ /usr/include/qt/QtCore/qhash.h
+ /usr/include/qt/QtCore/qhashfunctions.h
+ /usr/include/qt/QtCore/qiodevice.h
+ /usr/include/qt/QtCore/qiterator.h
+ /usr/include/qt/QtCore/qlist.h
+ /usr/include/qt/QtCore/qlocale.h
+ /usr/include/qt/QtCore/qlogging.h
+ /usr/include/qt/QtCore/qmap.h
+ /usr/include/qt/QtCore/qmetatype.h
+ /usr/include/qt/QtCore/qmutex.h
+ /usr/include/qt/QtCore/qnamespace.h
+ /usr/include/qt/QtCore/qnumeric.h
+ /usr/include/qt/QtCore/qobject.h
+ /usr/include/qt/QtCore/qobject_impl.h
+ /usr/include/qt/QtCore/qobjectdefs.h
+ /usr/include/qt/QtCore/qobjectdefs_impl.h
+ /usr/include/qt/QtCore/qpair.h
+ /usr/include/qt/QtCore/qpoint.h
+ /usr/include/qt/QtCore/qprocessordetection.h
+ /usr/include/qt/QtCore/qrefcount.h
+ /usr/include/qt/QtCore/qregexp.h
+ /usr/include/qt/QtCore/qsavefile.h
+ /usr/include/qt/QtCore/qscopedpointer.h
+ /usr/include/qt/QtCore/qset.h
+ /usr/include/qt/QtCore/qshareddata.h
+ /usr/include/qt/QtCore/qsharedpointer.h
+ /usr/include/qt/QtCore/qsharedpointer_impl.h
+ /usr/include/qt/QtCore/qstring.h
+ /usr/include/qt/QtCore/qstringalgorithms.h
+ /usr/include/qt/QtCore/qstringbuilder.h
+ /usr/include/qt/QtCore/qstringlist.h
+ /usr/include/qt/QtCore/qstringliteral.h
+ /usr/include/qt/QtCore/qstringmatcher.h
+ /usr/include/qt/QtCore/qstringview.h
+ /usr/include/qt/QtCore/qsysinfo.h
+ /usr/include/qt/QtCore/qsystemdetection.h
+ /usr/include/qt/QtCore/qtcore-config.h
+ /usr/include/qt/QtCore/qtextcodec.h
+ /usr/include/qt/QtCore/qtextstream.h
+ /usr/include/qt/QtCore/qtypeinfo.h
+ /usr/include/qt/QtCore/qvariant.h
+ /usr/include/qt/QtCore/qvarlengtharray.h
+ /usr/include/qt/QtCore/qvector.h
+ /usr/include/qt/QtCore/qversiontagging.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/ioapi.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip_global.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip_qt_compat.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipfile.cpp
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipfile.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipfileinfo.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipnewinfo.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/unzip.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/zip.h
+ /usr/include/qt/QtCore/QByteArray
+ /usr/include/qt/QtCore/QDateTime
+ /usr/include/qt/QtCore/QFile
+ /usr/include/qt/QtCore/QFileInfo
+ /usr/include/qt/QtCore/QHash
+ /usr/include/qt/QtCore/QIODevice
+ /usr/include/qt/QtCore/QList
+ /usr/include/qt/QtCore/QSaveFile
+ /usr/include/qt/QtCore/QString
+ /usr/include/qt/QtCore/QStringList
+ /usr/include/qt/QtCore/QTextCodec
+ /usr/include/qt/QtCore/QTextStream
+ /usr/include/qt/QtCore/Qt
+ /usr/include/qt/QtCore/QtAlgorithms
+ /usr/include/qt/QtCore/QtGlobal
+ /usr/include/qt/QtCore/qalgorithms.h
+ /usr/include/qt/QtCore/qarraydata.h
+ /usr/include/qt/QtCore/qatomic.h
+ /usr/include/qt/QtCore/qatomic_bootstrap.h
+ /usr/include/qt/QtCore/qatomic_cxx11.h
+ /usr/include/qt/QtCore/qatomic_msvc.h
+ /usr/include/qt/QtCore/qbasicatomic.h
+ /usr/include/qt/QtCore/qbytearray.h
+ /usr/include/qt/QtCore/qbytearraylist.h
+ /usr/include/qt/QtCore/qchar.h
+ /usr/include/qt/QtCore/qcompilerdetection.h
+ /usr/include/qt/QtCore/qconfig-bootstrapped.h
+ /usr/include/qt/QtCore/qconfig.h
+ /usr/include/qt/QtCore/qcontainerfwd.h
+ /usr/include/qt/QtCore/qcontainertools_impl.h
+ /usr/include/qt/QtCore/qcontiguouscache.h
+ /usr/include/qt/QtCore/qcoreevent.h
+ /usr/include/qt/QtCore/qdatetime.h
+ /usr/include/qt/QtCore/qdebug.h
+ /usr/include/qt/QtCore/qfile.h
+ /usr/include/qt/QtCore/qfiledevice.h
+ /usr/include/qt/QtCore/qfileinfo.h
+ /usr/include/qt/QtCore/qflags.h
+ /usr/include/qt/QtCore/qgenericatomic.h
+ /usr/include/qt/QtCore/qglobal.h
+ /usr/include/qt/QtCore/qglobalstatic.h
+ /usr/include/qt/QtCore/qhash.h
+ /usr/include/qt/QtCore/qhashfunctions.h
+ /usr/include/qt/QtCore/qiodevice.h
+ /usr/include/qt/QtCore/qiterator.h
+ /usr/include/qt/QtCore/qlist.h
+ /usr/include/qt/QtCore/qlocale.h
+ /usr/include/qt/QtCore/qlogging.h
+ /usr/include/qt/QtCore/qmap.h
+ /usr/include/qt/QtCore/qmetatype.h
+ /usr/include/qt/QtCore/qmutex.h
+ /usr/include/qt/QtCore/qnamespace.h
+ /usr/include/qt/QtCore/qnumeric.h
+ /usr/include/qt/QtCore/qobject.h
+ /usr/include/qt/QtCore/qobject_impl.h
+ /usr/include/qt/QtCore/qobjectdefs.h
+ /usr/include/qt/QtCore/qobjectdefs_impl.h
+ /usr/include/qt/QtCore/qpair.h
+ /usr/include/qt/QtCore/qpoint.h
+ /usr/include/qt/QtCore/qprocessordetection.h
+ /usr/include/qt/QtCore/qrefcount.h
+ /usr/include/qt/QtCore/qregexp.h
+ /usr/include/qt/QtCore/qsavefile.h
+ /usr/include/qt/QtCore/qscopedpointer.h
+ /usr/include/qt/QtCore/qset.h
+ /usr/include/qt/QtCore/qshareddata.h
+ /usr/include/qt/QtCore/qsharedpointer.h
+ /usr/include/qt/QtCore/qsharedpointer_impl.h
+ /usr/include/qt/QtCore/qstring.h
+ /usr/include/qt/QtCore/qstringalgorithms.h
+ /usr/include/qt/QtCore/qstringbuilder.h
+ /usr/include/qt/QtCore/qstringlist.h
+ /usr/include/qt/QtCore/qstringliteral.h
+ /usr/include/qt/QtCore/qstringmatcher.h
+ /usr/include/qt/QtCore/qstringview.h
+ /usr/include/qt/QtCore/qsysinfo.h
+ /usr/include/qt/QtCore/qsystemdetection.h
+ /usr/include/qt/QtCore/qtcore-config.h
+ /usr/include/qt/QtCore/qtextcodec.h
+ /usr/include/qt/QtCore/qtextstream.h
+ /usr/include/qt/QtCore/qtypeinfo.h
+ /usr/include/qt/QtCore/qvariant.h
+ /usr/include/qt/QtCore/qvarlengtharray.h
+ /usr/include/qt/QtCore/qvector.h
+ /usr/include/qt/QtCore/qversiontagging.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip_global.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipfileinfo.cpp
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipfileinfo.h
+ /usr/include/qt/QtCore/QByteArray
+ /usr/include/qt/QtCore/QDataStream
+ /usr/include/qt/QtCore/QDateTime
+ /usr/include/qt/QtCore/QFile
+ /usr/include/qt/QtCore/QHash
+ /usr/include/qt/QtCore/QtGlobal
+ /usr/include/qt/QtCore/qalgorithms.h
+ /usr/include/qt/QtCore/qarraydata.h
+ /usr/include/qt/QtCore/qatomic.h
+ /usr/include/qt/QtCore/qatomic_bootstrap.h
+ /usr/include/qt/QtCore/qatomic_cxx11.h
+ /usr/include/qt/QtCore/qatomic_msvc.h
+ /usr/include/qt/QtCore/qbasicatomic.h
+ /usr/include/qt/QtCore/qbytearray.h
+ /usr/include/qt/QtCore/qbytearraylist.h
+ /usr/include/qt/QtCore/qchar.h
+ /usr/include/qt/QtCore/qcompilerdetection.h
+ /usr/include/qt/QtCore/qconfig-bootstrapped.h
+ /usr/include/qt/QtCore/qconfig.h
+ /usr/include/qt/QtCore/qcontainerfwd.h
+ /usr/include/qt/QtCore/qcontainertools_impl.h
+ /usr/include/qt/QtCore/qcoreevent.h
+ /usr/include/qt/QtCore/qdatastream.h
+ /usr/include/qt/QtCore/qdatetime.h
+ /usr/include/qt/QtCore/qfile.h
+ /usr/include/qt/QtCore/qfiledevice.h
+ /usr/include/qt/QtCore/qflags.h
+ /usr/include/qt/QtCore/qgenericatomic.h
+ /usr/include/qt/QtCore/qglobal.h
+ /usr/include/qt/QtCore/qglobalstatic.h
+ /usr/include/qt/QtCore/qhash.h
+ /usr/include/qt/QtCore/qhashfunctions.h
+ /usr/include/qt/QtCore/qiodevice.h
+ /usr/include/qt/QtCore/qiterator.h
+ /usr/include/qt/QtCore/qlist.h
+ /usr/include/qt/QtCore/qlogging.h
+ /usr/include/qt/QtCore/qmetatype.h
+ /usr/include/qt/QtCore/qmutex.h
+ /usr/include/qt/QtCore/qnamespace.h
+ /usr/include/qt/QtCore/qnumeric.h
+ /usr/include/qt/QtCore/qobject.h
+ /usr/include/qt/QtCore/qobject_impl.h
+ /usr/include/qt/QtCore/qobjectdefs.h
+ /usr/include/qt/QtCore/qobjectdefs_impl.h
+ /usr/include/qt/QtCore/qpair.h
+ /usr/include/qt/QtCore/qpoint.h
+ /usr/include/qt/QtCore/qprocessordetection.h
+ /usr/include/qt/QtCore/qrefcount.h
+ /usr/include/qt/QtCore/qregexp.h
+ /usr/include/qt/QtCore/qscopedpointer.h
+ /usr/include/qt/QtCore/qshareddata.h
+ /usr/include/qt/QtCore/qstring.h
+ /usr/include/qt/QtCore/qstringalgorithms.h
+ /usr/include/qt/QtCore/qstringbuilder.h
+ /usr/include/qt/QtCore/qstringlist.h
+ /usr/include/qt/QtCore/qstringliteral.h
+ /usr/include/qt/QtCore/qstringmatcher.h
+ /usr/include/qt/QtCore/qstringview.h
+ /usr/include/qt/QtCore/qsysinfo.h
+ /usr/include/qt/QtCore/qsystemdetection.h
+ /usr/include/qt/QtCore/qtcore-config.h
+ /usr/include/qt/QtCore/qtypeinfo.h
+ /usr/include/qt/QtCore/qvarlengtharray.h
+ /usr/include/qt/QtCore/qvector.h
+ /usr/include/qt/QtCore/qversiontagging.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip_global.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazip_qt_compat.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipfileinfo.h
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipnewinfo.cpp
+ /home/dash/dev/Orayta-QT/dep/quazip/quazip/quazipnewinfo.h
+ /usr/include/qt/QtCore/QByteArray
+ /usr/include/qt/QtCore/QDateTime
+ /usr/include/qt/QtCore/QFile
+ /usr/include/qt/QtCore/QFileInfo
+ /usr/include/qt/QtCore/QHash
+ /usr/include/qt/QtCore/QList
+ /usr/include/qt/QtCore/QSaveFile
+ /usr/include/qt/QtCore/QString
+ /usr/include/qt/QtCore/QTextCodec
+ /usr/include/qt/QtCore/QTextStream
+ /usr/include/qt/QtCore/Qt
+ /usr/include/qt/QtCore/QtAlgorithms
+ /usr/include/qt/QtCore/QtGlobal
+ /usr/include/qt/QtCore/qalgorithms.h
+ /usr/include/qt/QtCore/qarraydata.h
+ /usr/include/qt/QtCore/qatomic.h
+ /usr/include/qt/QtCore/qatomic_bootstrap.h
+ /usr/include/qt/QtCore/qatomic_cxx11.h
+ /usr/include/qt/QtCore/qatomic_msvc.h
+ /usr/include/qt/QtCore/qbasicatomic.h
+ /usr/include/qt/QtCore/qbytearray.h
+ /usr/include/qt/QtCore/qbytearraylist.h
+ /usr/include/qt/QtCore/qchar.h
+ /usr/include/qt/QtCore/qcompilerdetection.h
+ /usr/include/qt/QtCore/qconfig-bootstrapped.h
+ /usr/include/qt/QtCore/qconfig.h
+ /usr/include/qt/QtCore/qcontainerfwd.h
+ /usr/include/qt/QtCore/qcontainertools_impl.h
+ /usr/include/qt/QtCore/qcontiguouscache.h
+ /usr/include/qt/QtCore/qcoreevent.h
+ /usr/include/qt/QtCore/qdatetime.h
+ /usr/include/qt/QtCore/qdebug.h
+ /usr/include/qt/QtCore/qfile.h
+ /usr/include/qt/QtCore/qfiledevice.h
+ /usr/include/qt/QtCore/qfileinfo.h
+ /usr/include/qt/QtCore/qflags.h
+ /usr/include/qt/QtCore/qgenericatomic.h
+ /usr/include/qt/QtCore/qglobal.h
+ /usr/include/qt/QtCore/qglobalstatic.h
+ /usr/include/qt/QtCore/qhash.h
+ /usr/include/qt/QtCore/qhashfunctions.h
+ /usr/include/qt/QtCore/qiodevice.h
+ /usr/include/qt/QtCore/qiterator.h
+ /usr/include/qt/QtCore/qlist.h
+ /usr/include/qt/QtCore/qlocale.h
+ /usr/include/qt/QtCore/qlogging.h
+ /usr/include/qt/QtCore/qmap.h
+ /usr/include/qt/QtCore/qmetatype.h
+ /usr/include/qt/QtCore/qmutex.h
+ /usr/include/qt/QtCore/qnamespace.h
+ /usr/include/qt/QtCore/qnumeric.h
+ /usr/include/qt/QtCore/qobject.h
+ /usr/include/qt/QtCore/qobject_impl.h
+ /usr/include/qt/QtCore/qobjectdefs.h
+ /usr/include/qt/QtCore/qobjectdefs_impl.h
+ /usr/include/qt/QtCore/qpair.h
+ /usr/include/qt/QtCore/qpoint.h
+ /usr/include/qt/QtCore/qprocessordetection.h
+ /usr/include/qt/QtCore/qrefcount.h
+ /usr/include/qt/QtCore/qregexp.h
+ /usr/include/qt/QtCore/qsavefile.h
+ /usr/include/qt/QtCore/qscopedpointer.h
+ /usr/include/qt/QtCore/qset.h
+ /usr/include/qt/QtCore/qshareddata.h
+ /usr/include/qt/QtCore/qsharedpointer.h
+ /usr/include/qt/QtCore/qsharedpointer_impl.h
+ /usr/include/qt/QtCore/qstring.h
+ /usr/include/qt/QtCore/qstringalgorithms.h
+ /usr/include/qt/QtCore/qstringbuilder.h
+ /usr/include/qt/QtCore/qstringlist.h
+ /usr/include/qt/QtCore/qstringliteral.h
+ /usr/include/qt/QtCore/qstringmatcher.h
+ /usr/include/qt/QtCore/qstringview.h
+ /usr/include/qt/QtCore/qsysinfo.h
+ /usr/include/qt/QtCore/qsystemdetection.h
+ /usr/include/qt/QtCore/qtcore-config.h
+ /usr/include/qt/QtCore/qtextcodec.h
+ /usr/include/qt/QtCore/qtextstream.h
+ /usr/include/qt/QtCore/qtypeinfo.h
+ /usr/include/qt/QtCore/qvariant.h
+ /usr/include/qt/QtCore/qvarlengtharray.h
+ /usr/include/qt/QtCore/qvector.h
+ /usr/include/qt/QtCore/qversiontagging.h
diff -ruN ./CMakeFiles/QuaZip.dir/depend.make ../../dep/quazip/quazip/CMakeFiles/QuaZip.dir/depend.make
--- ./CMakeFiles/QuaZip.dir/depend.make	1970-01-01 02:00:00.000000000 +0200
+++ ../../dep/quazip/quazip/CMakeFiles/QuaZip.dir/depend.make	2020-11-27 04:08:38.322516667 +0200
@@ -0,0 +1,1011 @@
+# CMAKE generated file: DO NOT EDIT!
+# Generated by "Unix Makefiles" Generator, CMake Version 3.19
+
+quazip/CMakeFiles/QuaZip.dir/unzip.c.o: quazip/ioapi.h
+quazip/CMakeFiles/QuaZip.dir/unzip.c.o: quazip/minizip_crypt.h
+quazip/CMakeFiles/QuaZip.dir/unzip.c.o: quazip/quazip_global.h
+quazip/CMakeFiles/QuaZip.dir/unzip.c.o: quazip/unzip.c
+quazip/CMakeFiles/QuaZip.dir/unzip.c.o: quazip/unzip.h
+quazip/CMakeFiles/QuaZip.dir/unzip.c.o: /usr/include/qt/QtCore/QtGlobal
+quazip/CMakeFiles/QuaZip.dir/unzip.c.o: /usr/include/qt/QtCore/qatomic.h
+quazip/CMakeFiles/QuaZip.dir/unzip.c.o: /usr/include/qt/QtCore/qatomic_bootstrap.h
+quazip/CMakeFiles/QuaZip.dir/unzip.c.o: /usr/include/qt/QtCore/qatomic_cxx11.h
+quazip/CMakeFiles/QuaZip.dir/unzip.c.o: /usr/include/qt/QtCore/qatomic_msvc.h
+quazip/CMakeFiles/QuaZip.dir/unzip.c.o: /usr/include/qt/QtCore/qbasicatomic.h
+quazip/CMakeFiles/QuaZip.dir/unzip.c.o: /usr/include/qt/QtCore/qcompilerdetection.h
+quazip/CMakeFiles/QuaZip.dir/unzip.c.o: /usr/include/qt/QtCore/qconfig-bootstrapped.h
+quazip/CMakeFiles/QuaZip.dir/unzip.c.o: /usr/include/qt/QtCore/qconfig.h
+quazip/CMakeFiles/QuaZip.dir/unzip.c.o: /usr/include/qt/QtCore/qflags.h
+quazip/CMakeFiles/QuaZip.dir/unzip.c.o: /usr/include/qt/QtCore/qgenericatomic.h
+quazip/CMakeFiles/QuaZip.dir/unzip.c.o: /usr/include/qt/QtCore/qglobal.h
+quazip/CMakeFiles/QuaZip.dir/unzip.c.o: /usr/include/qt/QtCore/qglobalstatic.h
+quazip/CMakeFiles/QuaZip.dir/unzip.c.o: /usr/include/qt/QtCore/qlogging.h
+quazip/CMakeFiles/QuaZip.dir/unzip.c.o: /usr/include/qt/QtCore/qmutex.h
+quazip/CMakeFiles/QuaZip.dir/unzip.c.o: /usr/include/qt/QtCore/qnumeric.h
+quazip/CMakeFiles/QuaZip.dir/unzip.c.o: /usr/include/qt/QtCore/qprocessordetection.h
+quazip/CMakeFiles/QuaZip.dir/unzip.c.o: /usr/include/qt/QtCore/qsysinfo.h
+quazip/CMakeFiles/QuaZip.dir/unzip.c.o: /usr/include/qt/QtCore/qsystemdetection.h
+quazip/CMakeFiles/QuaZip.dir/unzip.c.o: /usr/include/qt/QtCore/qtcore-config.h
+quazip/CMakeFiles/QuaZip.dir/unzip.c.o: /usr/include/qt/QtCore/qtypeinfo.h
+quazip/CMakeFiles/QuaZip.dir/unzip.c.o: /usr/include/qt/QtCore/qversiontagging.h
+
+quazip/CMakeFiles/QuaZip.dir/zip.c.o: quazip/ioapi.h
+quazip/CMakeFiles/QuaZip.dir/zip.c.o: quazip/minizip_crypt.h
+quazip/CMakeFiles/QuaZip.dir/zip.c.o: quazip/quazip_global.h
+quazip/CMakeFiles/QuaZip.dir/zip.c.o: quazip/zip.c
+quazip/CMakeFiles/QuaZip.dir/zip.c.o: quazip/zip.h
+quazip/CMakeFiles/QuaZip.dir/zip.c.o: /usr/include/qt/QtCore/QtGlobal
+quazip/CMakeFiles/QuaZip.dir/zip.c.o: /usr/include/qt/QtCore/qatomic.h
+quazip/CMakeFiles/QuaZip.dir/zip.c.o: /usr/include/qt/QtCore/qatomic_bootstrap.h
+quazip/CMakeFiles/QuaZip.dir/zip.c.o: /usr/include/qt/QtCore/qatomic_cxx11.h
+quazip/CMakeFiles/QuaZip.dir/zip.c.o: /usr/include/qt/QtCore/qatomic_msvc.h
+quazip/CMakeFiles/QuaZip.dir/zip.c.o: /usr/include/qt/QtCore/qbasicatomic.h
+quazip/CMakeFiles/QuaZip.dir/zip.c.o: /usr/include/qt/QtCore/qcompilerdetection.h
+quazip/CMakeFiles/QuaZip.dir/zip.c.o: /usr/include/qt/QtCore/qconfig-bootstrapped.h
+quazip/CMakeFiles/QuaZip.dir/zip.c.o: /usr/include/qt/QtCore/qconfig.h
+quazip/CMakeFiles/QuaZip.dir/zip.c.o: /usr/include/qt/QtCore/qflags.h
+quazip/CMakeFiles/QuaZip.dir/zip.c.o: /usr/include/qt/QtCore/qgenericatomic.h
+quazip/CMakeFiles/QuaZip.dir/zip.c.o: /usr/include/qt/QtCore/qglobal.h
+quazip/CMakeFiles/QuaZip.dir/zip.c.o: /usr/include/qt/QtCore/qglobalstatic.h
+quazip/CMakeFiles/QuaZip.dir/zip.c.o: /usr/include/qt/QtCore/qlogging.h
+quazip/CMakeFiles/QuaZip.dir/zip.c.o: /usr/include/qt/QtCore/qmutex.h
+quazip/CMakeFiles/QuaZip.dir/zip.c.o: /usr/include/qt/QtCore/qnumeric.h
+quazip/CMakeFiles/QuaZip.dir/zip.c.o: /usr/include/qt/QtCore/qprocessordetection.h
+quazip/CMakeFiles/QuaZip.dir/zip.c.o: /usr/include/qt/QtCore/qsysinfo.h
+quazip/CMakeFiles/QuaZip.dir/zip.c.o: /usr/include/qt/QtCore/qsystemdetection.h
+quazip/CMakeFiles/QuaZip.dir/zip.c.o: /usr/include/qt/QtCore/qtcore-config.h
+quazip/CMakeFiles/QuaZip.dir/zip.c.o: /usr/include/qt/QtCore/qtypeinfo.h
+quazip/CMakeFiles/QuaZip.dir/zip.c.o: /usr/include/qt/QtCore/qversiontagging.h
+
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: quazip/JlCompress.cpp
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: quazip/JlCompress.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: quazip/ioapi.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: quazip/quazip.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: quazip/quazip_global.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: quazip/quazip_qt_compat.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: quazip/quazipfile.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: quazip/quazipfileinfo.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: quazip/quazipnewinfo.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: quazip/unzip.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: quazip/zip.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/QByteArray
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/QDateTime
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/QDir
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/QFile
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/QFileInfo
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/QHash
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/QIODevice
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/QList
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/QSaveFile
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/QString
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/QStringList
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/QTextCodec
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/QTextStream
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/Qt
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/QtAlgorithms
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/QtGlobal
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qalgorithms.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qarraydata.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qatomic.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qatomic_bootstrap.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qatomic_cxx11.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qatomic_msvc.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qbasicatomic.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qbytearray.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qbytearraylist.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qchar.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qcompilerdetection.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qconfig-bootstrapped.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qconfig.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qcontainerfwd.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qcontainertools_impl.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qcontiguouscache.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qcoreevent.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qdatetime.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qdebug.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qdir.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qfile.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qfiledevice.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qfileinfo.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qflags.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qgenericatomic.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qglobal.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qglobalstatic.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qhash.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qhashfunctions.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qiodevice.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qiterator.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qlist.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qlocale.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qlogging.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qmap.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qmetatype.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qmutex.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qnamespace.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qnumeric.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qobject.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qobject_impl.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qobjectdefs.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qobjectdefs_impl.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qpair.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qpoint.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qprocessordetection.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qrefcount.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qregexp.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qsavefile.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qscopedpointer.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qset.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qshareddata.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qsharedpointer.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qsharedpointer_impl.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qstring.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qstringalgorithms.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qstringbuilder.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qstringlist.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qstringliteral.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qstringmatcher.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qstringview.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qsysinfo.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qsystemdetection.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qtcore-config.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qtextcodec.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qtextstream.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qtypeinfo.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qvariant.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qvarlengtharray.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qvector.h
+quazip/CMakeFiles/QuaZip.dir/JlCompress.cpp.o: /usr/include/qt/QtCore/qversiontagging.h
+
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: quazip/QuaZip_autogen/EWIEGA46WW/moc_quagzipfile.cpp
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: quazip/QuaZip_autogen/EWIEGA46WW/moc_quaziodevice.cpp
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: quazip/QuaZip_autogen/EWIEGA46WW/moc_quazipfile.cpp
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: quazip/QuaZip_autogen/mocs_compilation.cpp
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: quazip/ioapi.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: quazip/quagzipfile.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: quazip/quaziodevice.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: quazip/quazip.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: quazip/quazip_global.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: quazip/quazip_qt_compat.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: quazip/quazipfile.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: quazip/quazipfileinfo.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: quazip/quazipnewinfo.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: quazip/unzip.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: quazip/zip.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/QByteArray
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/QDateTime
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/QFile
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/QFileInfo
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/QHash
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/QIODevice
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/QList
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/QSaveFile
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/QString
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/QStringList
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/QTextCodec
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/QTextStream
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/Qt
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/QtAlgorithms
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/QtGlobal
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qalgorithms.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qarraydata.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qatomic.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qatomic_bootstrap.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qatomic_cxx11.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qatomic_msvc.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qbasicatomic.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qbytearray.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qbytearraylist.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qchar.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qcompilerdetection.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qconfig-bootstrapped.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qconfig.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qcontainerfwd.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qcontainertools_impl.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qcontiguouscache.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qcoreevent.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qdatetime.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qdebug.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qfile.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qfiledevice.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qfileinfo.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qflags.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qgenericatomic.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qglobal.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qglobalstatic.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qhash.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qhashfunctions.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qiodevice.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qiterator.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qlist.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qlocale.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qlogging.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qmap.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qmetatype.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qmutex.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qnamespace.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qnumeric.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qobject.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qobject_impl.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qobjectdefs.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qobjectdefs_impl.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qpair.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qpoint.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qprocessordetection.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qrefcount.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qregexp.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qsavefile.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qscopedpointer.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qset.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qshareddata.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qsharedpointer.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qsharedpointer_impl.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qstring.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qstringalgorithms.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qstringbuilder.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qstringlist.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qstringliteral.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qstringmatcher.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qstringview.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qsysinfo.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qsystemdetection.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qtcore-config.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qtextcodec.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qtextstream.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qtypeinfo.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qvariant.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qvarlengtharray.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qvector.h
+quazip/CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o: /usr/include/qt/QtCore/qversiontagging.h
+
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: quazip/ioapi.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: quazip/qioapi.cpp
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: quazip/quazip_global.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: quazip/quazip_qt_compat.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/QDateTime
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/QFileInfo
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/QIODevice
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/QList
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/QSaveFile
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/QString
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/QTextCodec
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/QTextStream
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/Qt
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/QtAlgorithms
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/QtGlobal
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qalgorithms.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qarraydata.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qatomic.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qatomic_bootstrap.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qatomic_cxx11.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qatomic_msvc.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qbasicatomic.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qbytearray.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qbytearraylist.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qchar.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qcompilerdetection.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qconfig-bootstrapped.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qconfig.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qcontainerfwd.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qcontainertools_impl.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qcontiguouscache.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qcoreevent.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qdatetime.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qdebug.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qfile.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qfiledevice.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qfileinfo.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qflags.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qgenericatomic.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qglobal.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qglobalstatic.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qhash.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qhashfunctions.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qiodevice.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qiterator.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qlist.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qlocale.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qlogging.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qmap.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qmetatype.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qmutex.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qnamespace.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qnumeric.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qobject.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qobject_impl.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qobjectdefs.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qobjectdefs_impl.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qpair.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qpoint.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qprocessordetection.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qrefcount.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qregexp.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qsavefile.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qscopedpointer.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qset.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qshareddata.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qsharedpointer.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qsharedpointer_impl.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qstring.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qstringalgorithms.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qstringbuilder.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qstringlist.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qstringliteral.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qstringmatcher.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qstringview.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qsysinfo.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qsystemdetection.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qtcore-config.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qtextcodec.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qtextstream.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qtypeinfo.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qvariant.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qvarlengtharray.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qvector.h
+quazip/CMakeFiles/QuaZip.dir/qioapi.cpp.o: /usr/include/qt/QtCore/qversiontagging.h
+
+quazip/CMakeFiles/QuaZip.dir/quaadler32.cpp.o: quazip/quaadler32.cpp
+quazip/CMakeFiles/QuaZip.dir/quaadler32.cpp.o: quazip/quaadler32.h
+quazip/CMakeFiles/QuaZip.dir/quaadler32.cpp.o: quazip/quachecksum32.h
+quazip/CMakeFiles/QuaZip.dir/quaadler32.cpp.o: quazip/quazip_global.h
+quazip/CMakeFiles/QuaZip.dir/quaadler32.cpp.o: /usr/include/qt/QtCore/QByteArray
+quazip/CMakeFiles/QuaZip.dir/quaadler32.cpp.o: /usr/include/qt/QtCore/QtGlobal
+quazip/CMakeFiles/QuaZip.dir/quaadler32.cpp.o: /usr/include/qt/QtCore/qarraydata.h
+quazip/CMakeFiles/QuaZip.dir/quaadler32.cpp.o: /usr/include/qt/QtCore/qatomic.h
+quazip/CMakeFiles/QuaZip.dir/quaadler32.cpp.o: /usr/include/qt/QtCore/qatomic_bootstrap.h
+quazip/CMakeFiles/QuaZip.dir/quaadler32.cpp.o: /usr/include/qt/QtCore/qatomic_cxx11.h
+quazip/CMakeFiles/QuaZip.dir/quaadler32.cpp.o: /usr/include/qt/QtCore/qatomic_msvc.h
+quazip/CMakeFiles/QuaZip.dir/quaadler32.cpp.o: /usr/include/qt/QtCore/qbasicatomic.h
+quazip/CMakeFiles/QuaZip.dir/quaadler32.cpp.o: /usr/include/qt/QtCore/qbytearray.h
+quazip/CMakeFiles/QuaZip.dir/quaadler32.cpp.o: /usr/include/qt/QtCore/qcompilerdetection.h
+quazip/CMakeFiles/QuaZip.dir/quaadler32.cpp.o: /usr/include/qt/QtCore/qconfig-bootstrapped.h
+quazip/CMakeFiles/QuaZip.dir/quaadler32.cpp.o: /usr/include/qt/QtCore/qconfig.h
+quazip/CMakeFiles/QuaZip.dir/quaadler32.cpp.o: /usr/include/qt/QtCore/qflags.h
+quazip/CMakeFiles/QuaZip.dir/quaadler32.cpp.o: /usr/include/qt/QtCore/qgenericatomic.h
+quazip/CMakeFiles/QuaZip.dir/quaadler32.cpp.o: /usr/include/qt/QtCore/qglobal.h
+quazip/CMakeFiles/QuaZip.dir/quaadler32.cpp.o: /usr/include/qt/QtCore/qglobalstatic.h
+quazip/CMakeFiles/QuaZip.dir/quaadler32.cpp.o: /usr/include/qt/QtCore/qlogging.h
+quazip/CMakeFiles/QuaZip.dir/quaadler32.cpp.o: /usr/include/qt/QtCore/qmutex.h
+quazip/CMakeFiles/QuaZip.dir/quaadler32.cpp.o: /usr/include/qt/QtCore/qnamespace.h
+quazip/CMakeFiles/QuaZip.dir/quaadler32.cpp.o: /usr/include/qt/QtCore/qnumeric.h
+quazip/CMakeFiles/QuaZip.dir/quaadler32.cpp.o: /usr/include/qt/QtCore/qprocessordetection.h
+quazip/CMakeFiles/QuaZip.dir/quaadler32.cpp.o: /usr/include/qt/QtCore/qrefcount.h
+quazip/CMakeFiles/QuaZip.dir/quaadler32.cpp.o: /usr/include/qt/QtCore/qsysinfo.h
+quazip/CMakeFiles/QuaZip.dir/quaadler32.cpp.o: /usr/include/qt/QtCore/qsystemdetection.h
+quazip/CMakeFiles/QuaZip.dir/quaadler32.cpp.o: /usr/include/qt/QtCore/qtcore-config.h
+quazip/CMakeFiles/QuaZip.dir/quaadler32.cpp.o: /usr/include/qt/QtCore/qtypeinfo.h
+quazip/CMakeFiles/QuaZip.dir/quaadler32.cpp.o: /usr/include/qt/QtCore/qversiontagging.h
+
+quazip/CMakeFiles/QuaZip.dir/quachecksum32.cpp.o: quazip/quachecksum32.cpp
+quazip/CMakeFiles/QuaZip.dir/quachecksum32.cpp.o: quazip/quachecksum32.h
+quazip/CMakeFiles/QuaZip.dir/quachecksum32.cpp.o: quazip/quazip_global.h
+quazip/CMakeFiles/QuaZip.dir/quachecksum32.cpp.o: /usr/include/qt/QtCore/QByteArray
+quazip/CMakeFiles/QuaZip.dir/quachecksum32.cpp.o: /usr/include/qt/QtCore/QtGlobal
+quazip/CMakeFiles/QuaZip.dir/quachecksum32.cpp.o: /usr/include/qt/QtCore/qarraydata.h
+quazip/CMakeFiles/QuaZip.dir/quachecksum32.cpp.o: /usr/include/qt/QtCore/qatomic.h
+quazip/CMakeFiles/QuaZip.dir/quachecksum32.cpp.o: /usr/include/qt/QtCore/qatomic_bootstrap.h
+quazip/CMakeFiles/QuaZip.dir/quachecksum32.cpp.o: /usr/include/qt/QtCore/qatomic_cxx11.h
+quazip/CMakeFiles/QuaZip.dir/quachecksum32.cpp.o: /usr/include/qt/QtCore/qatomic_msvc.h
+quazip/CMakeFiles/QuaZip.dir/quachecksum32.cpp.o: /usr/include/qt/QtCore/qbasicatomic.h
+quazip/CMakeFiles/QuaZip.dir/quachecksum32.cpp.o: /usr/include/qt/QtCore/qbytearray.h
+quazip/CMakeFiles/QuaZip.dir/quachecksum32.cpp.o: /usr/include/qt/QtCore/qcompilerdetection.h
+quazip/CMakeFiles/QuaZip.dir/quachecksum32.cpp.o: /usr/include/qt/QtCore/qconfig-bootstrapped.h
+quazip/CMakeFiles/QuaZip.dir/quachecksum32.cpp.o: /usr/include/qt/QtCore/qconfig.h
+quazip/CMakeFiles/QuaZip.dir/quachecksum32.cpp.o: /usr/include/qt/QtCore/qflags.h
+quazip/CMakeFiles/QuaZip.dir/quachecksum32.cpp.o: /usr/include/qt/QtCore/qgenericatomic.h
+quazip/CMakeFiles/QuaZip.dir/quachecksum32.cpp.o: /usr/include/qt/QtCore/qglobal.h
+quazip/CMakeFiles/QuaZip.dir/quachecksum32.cpp.o: /usr/include/qt/QtCore/qglobalstatic.h
+quazip/CMakeFiles/QuaZip.dir/quachecksum32.cpp.o: /usr/include/qt/QtCore/qlogging.h
+quazip/CMakeFiles/QuaZip.dir/quachecksum32.cpp.o: /usr/include/qt/QtCore/qmutex.h
+quazip/CMakeFiles/QuaZip.dir/quachecksum32.cpp.o: /usr/include/qt/QtCore/qnamespace.h
+quazip/CMakeFiles/QuaZip.dir/quachecksum32.cpp.o: /usr/include/qt/QtCore/qnumeric.h
+quazip/CMakeFiles/QuaZip.dir/quachecksum32.cpp.o: /usr/include/qt/QtCore/qprocessordetection.h
+quazip/CMakeFiles/QuaZip.dir/quachecksum32.cpp.o: /usr/include/qt/QtCore/qrefcount.h
+quazip/CMakeFiles/QuaZip.dir/quachecksum32.cpp.o: /usr/include/qt/QtCore/qsysinfo.h
+quazip/CMakeFiles/QuaZip.dir/quachecksum32.cpp.o: /usr/include/qt/QtCore/qsystemdetection.h
+quazip/CMakeFiles/QuaZip.dir/quachecksum32.cpp.o: /usr/include/qt/QtCore/qtcore-config.h
+quazip/CMakeFiles/QuaZip.dir/quachecksum32.cpp.o: /usr/include/qt/QtCore/qtypeinfo.h
+quazip/CMakeFiles/QuaZip.dir/quachecksum32.cpp.o: /usr/include/qt/QtCore/qversiontagging.h
+
+quazip/CMakeFiles/QuaZip.dir/quacrc32.cpp.o: quazip/quachecksum32.h
+quazip/CMakeFiles/QuaZip.dir/quacrc32.cpp.o: quazip/quacrc32.cpp
+quazip/CMakeFiles/QuaZip.dir/quacrc32.cpp.o: quazip/quacrc32.h
+quazip/CMakeFiles/QuaZip.dir/quacrc32.cpp.o: quazip/quazip_global.h
+quazip/CMakeFiles/QuaZip.dir/quacrc32.cpp.o: /usr/include/qt/QtCore/QByteArray
+quazip/CMakeFiles/QuaZip.dir/quacrc32.cpp.o: /usr/include/qt/QtCore/QtGlobal
+quazip/CMakeFiles/QuaZip.dir/quacrc32.cpp.o: /usr/include/qt/QtCore/qarraydata.h
+quazip/CMakeFiles/QuaZip.dir/quacrc32.cpp.o: /usr/include/qt/QtCore/qatomic.h
+quazip/CMakeFiles/QuaZip.dir/quacrc32.cpp.o: /usr/include/qt/QtCore/qatomic_bootstrap.h
+quazip/CMakeFiles/QuaZip.dir/quacrc32.cpp.o: /usr/include/qt/QtCore/qatomic_cxx11.h
+quazip/CMakeFiles/QuaZip.dir/quacrc32.cpp.o: /usr/include/qt/QtCore/qatomic_msvc.h
+quazip/CMakeFiles/QuaZip.dir/quacrc32.cpp.o: /usr/include/qt/QtCore/qbasicatomic.h
+quazip/CMakeFiles/QuaZip.dir/quacrc32.cpp.o: /usr/include/qt/QtCore/qbytearray.h
+quazip/CMakeFiles/QuaZip.dir/quacrc32.cpp.o: /usr/include/qt/QtCore/qcompilerdetection.h
+quazip/CMakeFiles/QuaZip.dir/quacrc32.cpp.o: /usr/include/qt/QtCore/qconfig-bootstrapped.h
+quazip/CMakeFiles/QuaZip.dir/quacrc32.cpp.o: /usr/include/qt/QtCore/qconfig.h
+quazip/CMakeFiles/QuaZip.dir/quacrc32.cpp.o: /usr/include/qt/QtCore/qflags.h
+quazip/CMakeFiles/QuaZip.dir/quacrc32.cpp.o: /usr/include/qt/QtCore/qgenericatomic.h
+quazip/CMakeFiles/QuaZip.dir/quacrc32.cpp.o: /usr/include/qt/QtCore/qglobal.h
+quazip/CMakeFiles/QuaZip.dir/quacrc32.cpp.o: /usr/include/qt/QtCore/qglobalstatic.h
+quazip/CMakeFiles/QuaZip.dir/quacrc32.cpp.o: /usr/include/qt/QtCore/qlogging.h
+quazip/CMakeFiles/QuaZip.dir/quacrc32.cpp.o: /usr/include/qt/QtCore/qmutex.h
+quazip/CMakeFiles/QuaZip.dir/quacrc32.cpp.o: /usr/include/qt/QtCore/qnamespace.h
+quazip/CMakeFiles/QuaZip.dir/quacrc32.cpp.o: /usr/include/qt/QtCore/qnumeric.h
+quazip/CMakeFiles/QuaZip.dir/quacrc32.cpp.o: /usr/include/qt/QtCore/qprocessordetection.h
+quazip/CMakeFiles/QuaZip.dir/quacrc32.cpp.o: /usr/include/qt/QtCore/qrefcount.h
+quazip/CMakeFiles/QuaZip.dir/quacrc32.cpp.o: /usr/include/qt/QtCore/qsysinfo.h
+quazip/CMakeFiles/QuaZip.dir/quacrc32.cpp.o: /usr/include/qt/QtCore/qsystemdetection.h
+quazip/CMakeFiles/QuaZip.dir/quacrc32.cpp.o: /usr/include/qt/QtCore/qtcore-config.h
+quazip/CMakeFiles/QuaZip.dir/quacrc32.cpp.o: /usr/include/qt/QtCore/qtypeinfo.h
+quazip/CMakeFiles/QuaZip.dir/quacrc32.cpp.o: /usr/include/qt/QtCore/qversiontagging.h
+
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: quazip/quagzipfile.cpp
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: quazip/quagzipfile.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: quazip/quazip_global.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/QFile
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/QIODevice
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/QtGlobal
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qalgorithms.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qarraydata.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qatomic.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qatomic_bootstrap.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qatomic_cxx11.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qatomic_msvc.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qbasicatomic.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qbytearray.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qbytearraylist.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qchar.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qcompilerdetection.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qconfig-bootstrapped.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qconfig.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qcontainerfwd.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qcontainertools_impl.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qcoreevent.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qfile.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qfiledevice.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qflags.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qgenericatomic.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qglobal.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qglobalstatic.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qhashfunctions.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qiodevice.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qiterator.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qlist.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qlogging.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qmetatype.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qmutex.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qnamespace.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qnumeric.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qobject.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qobject_impl.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qobjectdefs.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qobjectdefs_impl.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qpair.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qpoint.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qprocessordetection.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qrefcount.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qregexp.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qscopedpointer.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qstring.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qstringalgorithms.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qstringbuilder.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qstringlist.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qstringliteral.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qstringmatcher.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qstringview.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qsysinfo.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qsystemdetection.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qtcore-config.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qtypeinfo.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qvarlengtharray.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qvector.h
+quazip/CMakeFiles/QuaZip.dir/quagzipfile.cpp.o: /usr/include/qt/QtCore/qversiontagging.h
+
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: quazip/quaziodevice.cpp
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: quazip/quaziodevice.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: quazip/quazip_global.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/QFile
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/QIODevice
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/QtGlobal
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qalgorithms.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qarraydata.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qatomic.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qatomic_bootstrap.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qatomic_cxx11.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qatomic_msvc.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qbasicatomic.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qbytearray.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qbytearraylist.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qchar.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qcompilerdetection.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qconfig-bootstrapped.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qconfig.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qcontainerfwd.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qcontainertools_impl.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qcoreevent.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qfile.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qfiledevice.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qflags.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qgenericatomic.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qglobal.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qglobalstatic.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qhashfunctions.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qiodevice.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qiterator.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qlist.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qlogging.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qmetatype.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qmutex.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qnamespace.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qnumeric.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qobject.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qobject_impl.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qobjectdefs.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qobjectdefs_impl.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qpair.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qpoint.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qprocessordetection.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qrefcount.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qregexp.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qscopedpointer.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qstring.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qstringalgorithms.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qstringbuilder.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qstringlist.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qstringliteral.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qstringmatcher.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qstringview.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qsysinfo.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qsystemdetection.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qtcore-config.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qtypeinfo.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qvarlengtharray.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qvector.h
+quazip/CMakeFiles/QuaZip.dir/quaziodevice.cpp.o: /usr/include/qt/QtCore/qversiontagging.h
+
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: quazip/ioapi.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: quazip/quazip.cpp
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: quazip/quazip.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: quazip/quazip_global.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: quazip/quazip_qt_compat.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: quazip/quazipfileinfo.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: quazip/unzip.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: quazip/zip.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/QByteArray
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/QDateTime
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/QFile
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/QFileInfo
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/QFlags
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/QHash
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/QList
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/QSaveFile
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/QString
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/QStringList
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/QTextCodec
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/QTextStream
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/Qt
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/QtAlgorithms
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/QtGlobal
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qalgorithms.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qarraydata.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qatomic.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qatomic_bootstrap.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qatomic_cxx11.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qatomic_msvc.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qbasicatomic.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qbytearray.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qbytearraylist.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qchar.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qcompilerdetection.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qconfig-bootstrapped.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qconfig.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qcontainerfwd.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qcontainertools_impl.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qcontiguouscache.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qcoreevent.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qdatetime.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qdebug.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qfile.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qfiledevice.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qfileinfo.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qflags.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qgenericatomic.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qglobal.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qglobalstatic.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qhash.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qhashfunctions.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qiodevice.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qiterator.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qlist.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qlocale.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qlogging.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qmap.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qmetatype.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qmutex.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qnamespace.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qnumeric.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qobject.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qobject_impl.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qobjectdefs.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qobjectdefs_impl.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qpair.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qpoint.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qprocessordetection.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qrefcount.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qregexp.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qsavefile.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qscopedpointer.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qset.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qshareddata.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qsharedpointer.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qsharedpointer_impl.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qstring.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qstringalgorithms.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qstringbuilder.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qstringlist.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qstringliteral.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qstringmatcher.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qstringview.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qsysinfo.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qsystemdetection.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qtcore-config.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qtextcodec.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qtextstream.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qtypeinfo.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qvariant.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qvarlengtharray.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qvector.h
+quazip/CMakeFiles/QuaZip.dir/quazip.cpp.o: /usr/include/qt/QtCore/qversiontagging.h
+
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: quazip/ioapi.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: quazip/quazip.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: quazip/quazip_global.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: quazip/quazip_qt_compat.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: quazip/quazipdir.cpp
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: quazip/quazipdir.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: quazip/quazipfileinfo.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: quazip/unzip.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: quazip/zip.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/QByteArray
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/QDateTime
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/QDir
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/QFile
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/QFileInfo
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/QHash
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/QList
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/QSaveFile
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/QSet
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/QSharedData
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/QSharedDataPointer
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/QString
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/QStringList
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/QTextCodec
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/QTextStream
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/Qt
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/QtAlgorithms
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/QtGlobal
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qalgorithms.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qarraydata.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qatomic.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qatomic_bootstrap.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qatomic_cxx11.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qatomic_msvc.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qbasicatomic.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qbytearray.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qbytearraylist.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qchar.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qcompilerdetection.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qconfig-bootstrapped.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qconfig.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qcontainerfwd.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qcontainertools_impl.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qcontiguouscache.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qcoreevent.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qdatetime.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qdebug.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qdir.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qfile.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qfiledevice.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qfileinfo.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qflags.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qgenericatomic.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qglobal.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qglobalstatic.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qhash.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qhashfunctions.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qiodevice.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qiterator.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qlist.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qlocale.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qlogging.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qmap.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qmetatype.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qmutex.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qnamespace.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qnumeric.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qobject.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qobject_impl.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qobjectdefs.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qobjectdefs_impl.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qpair.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qpoint.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qprocessordetection.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qrefcount.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qregexp.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qsavefile.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qscopedpointer.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qset.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qshareddata.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qsharedpointer.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qsharedpointer_impl.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qstring.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qstringalgorithms.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qstringbuilder.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qstringlist.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qstringliteral.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qstringmatcher.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qstringview.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qsysinfo.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qsystemdetection.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qtcore-config.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qtextcodec.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qtextstream.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qtypeinfo.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qvariant.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qvarlengtharray.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qvector.h
+quazip/CMakeFiles/QuaZip.dir/quazipdir.cpp.o: /usr/include/qt/QtCore/qversiontagging.h
+
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: quazip/ioapi.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: quazip/quazip.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: quazip/quazip_global.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: quazip/quazip_qt_compat.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: quazip/quazipfile.cpp
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: quazip/quazipfile.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: quazip/quazipfileinfo.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: quazip/quazipnewinfo.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: quazip/unzip.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: quazip/zip.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/QByteArray
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/QDateTime
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/QFile
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/QFileInfo
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/QHash
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/QIODevice
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/QList
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/QSaveFile
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/QString
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/QStringList
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/QTextCodec
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/QTextStream
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/Qt
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/QtAlgorithms
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/QtGlobal
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qalgorithms.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qarraydata.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qatomic.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qatomic_bootstrap.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qatomic_cxx11.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qatomic_msvc.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qbasicatomic.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qbytearray.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qbytearraylist.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qchar.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qcompilerdetection.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qconfig-bootstrapped.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qconfig.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qcontainerfwd.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qcontainertools_impl.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qcontiguouscache.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qcoreevent.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qdatetime.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qdebug.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qfile.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qfiledevice.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qfileinfo.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qflags.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qgenericatomic.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qglobal.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qglobalstatic.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qhash.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qhashfunctions.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qiodevice.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qiterator.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qlist.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qlocale.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qlogging.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qmap.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qmetatype.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qmutex.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qnamespace.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qnumeric.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qobject.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qobject_impl.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qobjectdefs.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qobjectdefs_impl.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qpair.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qpoint.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qprocessordetection.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qrefcount.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qregexp.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qsavefile.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qscopedpointer.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qset.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qshareddata.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qsharedpointer.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qsharedpointer_impl.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qstring.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qstringalgorithms.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qstringbuilder.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qstringlist.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qstringliteral.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qstringmatcher.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qstringview.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qsysinfo.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qsystemdetection.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qtcore-config.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qtextcodec.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qtextstream.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qtypeinfo.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qvariant.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qvarlengtharray.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qvector.h
+quazip/CMakeFiles/QuaZip.dir/quazipfile.cpp.o: /usr/include/qt/QtCore/qversiontagging.h
+
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: quazip/quazip_global.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: quazip/quazipfileinfo.cpp
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: quazip/quazipfileinfo.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/QByteArray
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/QDataStream
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/QDateTime
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/QFile
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/QHash
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/QtGlobal
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qalgorithms.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qarraydata.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qatomic.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qatomic_bootstrap.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qatomic_cxx11.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qatomic_msvc.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qbasicatomic.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qbytearray.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qbytearraylist.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qchar.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qcompilerdetection.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qconfig-bootstrapped.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qconfig.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qcontainerfwd.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qcontainertools_impl.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qcoreevent.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qdatastream.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qdatetime.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qfile.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qfiledevice.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qflags.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qgenericatomic.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qglobal.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qglobalstatic.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qhash.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qhashfunctions.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qiodevice.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qiterator.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qlist.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qlogging.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qmetatype.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qmutex.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qnamespace.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qnumeric.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qobject.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qobject_impl.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qobjectdefs.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qobjectdefs_impl.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qpair.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qpoint.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qprocessordetection.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qrefcount.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qregexp.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qscopedpointer.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qshareddata.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qstring.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qstringalgorithms.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qstringbuilder.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qstringlist.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qstringliteral.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qstringmatcher.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qstringview.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qsysinfo.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qsystemdetection.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qtcore-config.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qtypeinfo.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qvarlengtharray.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qvector.h
+quazip/CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o: /usr/include/qt/QtCore/qversiontagging.h
+
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: quazip/quazip_global.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: quazip/quazip_qt_compat.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: quazip/quazipfileinfo.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: quazip/quazipnewinfo.cpp
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: quazip/quazipnewinfo.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/QByteArray
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/QDateTime
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/QFile
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/QFileInfo
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/QHash
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/QList
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/QSaveFile
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/QString
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/QTextCodec
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/QTextStream
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/Qt
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/QtAlgorithms
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/QtGlobal
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qalgorithms.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qarraydata.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qatomic.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qatomic_bootstrap.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qatomic_cxx11.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qatomic_msvc.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qbasicatomic.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qbytearray.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qbytearraylist.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qchar.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qcompilerdetection.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qconfig-bootstrapped.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qconfig.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qcontainerfwd.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qcontainertools_impl.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qcontiguouscache.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qcoreevent.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qdatetime.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qdebug.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qfile.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qfiledevice.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qfileinfo.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qflags.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qgenericatomic.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qglobal.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qglobalstatic.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qhash.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qhashfunctions.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qiodevice.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qiterator.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qlist.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qlocale.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qlogging.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qmap.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qmetatype.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qmutex.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qnamespace.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qnumeric.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qobject.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qobject_impl.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qobjectdefs.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qobjectdefs_impl.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qpair.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qpoint.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qprocessordetection.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qrefcount.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qregexp.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qsavefile.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qscopedpointer.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qset.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qshareddata.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qsharedpointer.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qsharedpointer_impl.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qstring.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qstringalgorithms.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qstringbuilder.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qstringlist.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qstringliteral.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qstringmatcher.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qstringview.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qsysinfo.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qsystemdetection.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qtcore-config.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qtextcodec.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qtextstream.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qtypeinfo.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qvariant.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qvarlengtharray.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qvector.h
+quazip/CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o: /usr/include/qt/QtCore/qversiontagging.h
+
diff -ruN ./CMakeFiles/QuaZip.dir/flags.make ../../dep/quazip/quazip/CMakeFiles/QuaZip.dir/flags.make
--- ./CMakeFiles/QuaZip.dir/flags.make	1970-01-01 02:00:00.000000000 +0200
+++ ../../dep/quazip/quazip/CMakeFiles/QuaZip.dir/flags.make	2020-11-27 04:08:37.015850049 +0200
@@ -0,0 +1,17 @@
+# CMAKE generated file: DO NOT EDIT!
+# Generated by "Unix Makefiles" Generator, CMake Version 3.19
+
+# compile C with /usr/bin/cc
+# compile CXX with /usr/bin/c++
+C_DEFINES = -DQT_CORE_LIB -DQT_NO_DEBUG -DQUAZIP_BUILD -DQuaZip_EXPORTS
+
+C_INCLUDES = -I/home/dash/dev/Orayta-QT/dep/quazip/quazip -I/home/dash/dev/Orayta-QT/dep/quazip/quazip/QuaZip_autogen/include -I/home/dash/dev/Orayta-QT/dep/quazip -isystem /usr/include/qt -isystem /usr/include/qt/QtCore -isystem /usr/lib/qt/mkspecs/linux-g++
+
+C_FLAGS = -O3 -DNDEBUG -fPIC -fPIC
+
+CXX_DEFINES = -DQT_CORE_LIB -DQT_NO_DEBUG -DQUAZIP_BUILD -DQuaZip_EXPORTS
+
+CXX_INCLUDES = -I/home/dash/dev/Orayta-QT/dep/quazip/quazip -I/home/dash/dev/Orayta-QT/dep/quazip/quazip/QuaZip_autogen/include -I/home/dash/dev/Orayta-QT/dep/quazip -isystem /usr/include/qt -isystem /usr/include/qt/QtCore -isystem /usr/lib/qt/mkspecs/linux-g++
+
+CXX_FLAGS = -O3 -DNDEBUG -fPIC -fPIC -std=gnu++14
+
diff -ruN ./CMakeFiles/QuaZip.dir/link.txt ../../dep/quazip/quazip/CMakeFiles/QuaZip.dir/link.txt
--- ./CMakeFiles/QuaZip.dir/link.txt	1970-01-01 02:00:00.000000000 +0200
+++ ../../dep/quazip/quazip/CMakeFiles/QuaZip.dir/link.txt	2020-11-27 04:08:37.015850049 +0200
@@ -0,0 +1 @@
+/usr/bin/c++ -fPIC -O3 -DNDEBUG -shared -Wl,-soname,libquazip1-qt5.so.1.0.0 -o libquazip1-qt5.so.1.1 CMakeFiles/QuaZip.dir/QuaZip_autogen/mocs_compilation.cpp.o CMakeFiles/QuaZip.dir/unzip.c.o CMakeFiles/QuaZip.dir/zip.c.o CMakeFiles/QuaZip.dir/JlCompress.cpp.o CMakeFiles/QuaZip.dir/qioapi.cpp.o CMakeFiles/QuaZip.dir/quaadler32.cpp.o CMakeFiles/QuaZip.dir/quachecksum32.cpp.o CMakeFiles/QuaZip.dir/quacrc32.cpp.o CMakeFiles/QuaZip.dir/quagzipfile.cpp.o CMakeFiles/QuaZip.dir/quaziodevice.cpp.o CMakeFiles/QuaZip.dir/quazip.cpp.o CMakeFiles/QuaZip.dir/quazipdir.cpp.o CMakeFiles/QuaZip.dir/quazipfile.cpp.o CMakeFiles/QuaZip.dir/quazipfileinfo.cpp.o CMakeFiles/QuaZip.dir/quazipnewinfo.cpp.o  /usr/lib/libQt5Core.so.5.15.2 /usr/lib/libz.so 
diff -ruN ./CMakeFiles/QuaZip.dir/progress.make ../../dep/quazip/quazip/CMakeFiles/QuaZip.dir/progress.make
--- ./CMakeFiles/QuaZip.dir/progress.make	1970-01-01 02:00:00.000000000 +0200
+++ ../../dep/quazip/quazip/CMakeFiles/QuaZip.dir/progress.make	2020-11-27 04:08:37.019183382 +0200
@@ -0,0 +1,17 @@
+CMAKE_PROGRESS_1 = 1
+CMAKE_PROGRESS_2 = 2
+CMAKE_PROGRESS_3 = 3
+CMAKE_PROGRESS_4 = 4
+CMAKE_PROGRESS_5 = 5
+CMAKE_PROGRESS_6 = 6
+CMAKE_PROGRESS_7 = 7
+CMAKE_PROGRESS_8 = 8
+CMAKE_PROGRESS_9 = 9
+CMAKE_PROGRESS_10 = 10
+CMAKE_PROGRESS_11 = 11
+CMAKE_PROGRESS_12 = 12
+CMAKE_PROGRESS_13 = 13
+CMAKE_PROGRESS_14 = 14
+CMAKE_PROGRESS_15 = 15
+CMAKE_PROGRESS_16 = 16
+
diff -ruN ./crypt.h ../../dep/quazip/quazip/crypt.h
--- ./crypt.h	2020-11-27 04:16:54.989164832 +0200
+++ ../../dep/quazip/quazip/crypt.h	1970-01-01 02:00:00.000000000 +0200
@@ -1,135 +0,0 @@
-/* crypt.h -- base code for crypt/uncrypt ZIPfile
-
-
-   Version 1.01e, February 12th, 2005
-
-   Copyright (C) 1998-2005 Gilles Vollant
-
-   This code is a modified version of crypting code in Infozip distribution
-
-   The encryption/decryption parts of this source code (as opposed to the
-   non-echoing password parts) were originally written in Europe.  The
-   whole source package can be freely distributed, including from the USA.
-   (Prior to January 2000, re-export from the US was a violation of US law.)
-
-   This encryption code is a direct transcription of the algorithm from
-   Roger Schlafly, described by Phil Katz in the file appnote.txt.  This
-   file (appnote.txt) is distributed with the PKZIP program (even in the
-   version without encryption capabilities).
-
-   If you don't need crypting in your application, just define symbols
-   NOCRYPT and NOUNCRYPT.
-
-   This code support the "Traditional PKWARE Encryption".
-
-   The new AES encryption added on Zip format by Winzip (see the page
-   http://www.winzip.com/aes_info.htm ) and PKWare PKZip 5.x Strong
-   Encryption is not supported.
-*/
-
-#include "quazip_global.h"
-
-#define CRC32(c, b) ((*(pcrc_32_tab+(((int)(c) ^ (b)) & 0xff))) ^ ((c) >> 8))
-
-/***********************************************************************
- * Return the next byte in the pseudo-random sequence
- */
-static int decrypt_byte(unsigned long* pkeys, const unsigned long* pcrc_32_tab UNUSED)
-{
-    //(void) pcrc_32_tab; /* avoid "unused parameter" warning */
-    unsigned temp;  /* POTENTIAL BUG:  temp*(temp^1) may overflow in an
-                     * unpredictable manner on 16-bit systems; not a problem
-                     * with any known compiler so far, though */
-
-    temp = ((unsigned)(*(pkeys+2)) & 0xffff) | 2;
-    return (int)(((temp * (temp ^ 1)) >> 8) & 0xff);
-}
-
-/***********************************************************************
- * Update the encryption keys with the next byte of plain text
- */
-static int update_keys(unsigned long* pkeys,const unsigned long* pcrc_32_tab,int c)
-{
-    (*(pkeys+0)) = CRC32((*(pkeys+0)), c);
-    (*(pkeys+1)) += (*(pkeys+0)) & 0xff;
-    (*(pkeys+1)) = (*(pkeys+1)) * 134775813L + 1;
-    {
-      register int keyshift = (int)((*(pkeys+1)) >> 24);
-      (*(pkeys+2)) = CRC32((*(pkeys+2)), keyshift);
-    }
-    return c;
-}
-
-
-/***********************************************************************
- * Initialize the encryption keys and the random header according to
- * the given password.
- */
-static void init_keys(const char* passwd,unsigned long* pkeys,const unsigned long* pcrc_32_tab)
-{
-    *(pkeys+0) = 305419896L;
-    *(pkeys+1) = 591751049L;
-    *(pkeys+2) = 878082192L;
-    while (*passwd != '\0') {
-        update_keys(pkeys,pcrc_32_tab,(int)*passwd);
-        passwd++;
-    }
-}
-
-#define zdecode(pkeys,pcrc_32_tab,c) \
-    (update_keys(pkeys,pcrc_32_tab,c ^= decrypt_byte(pkeys,pcrc_32_tab)))
-
-#define zencode(pkeys,pcrc_32_tab,c,t) \
-    (t=decrypt_byte(pkeys,pcrc_32_tab), update_keys(pkeys,pcrc_32_tab,c), t^(c))
-
-#ifdef INCLUDECRYPTINGCODE_IFCRYPTALLOWED
-
-#define RAND_HEAD_LEN  12
-   /* "last resort" source for second part of crypt seed pattern */
-#  ifndef ZCR_SEED2
-#    define ZCR_SEED2 3141592654UL     /* use PI as default pattern */
-#  endif
-
-static int crypthead(passwd, buf, bufSize, pkeys, pcrc_32_tab, crcForCrypting)
-    const char *passwd;         /* password string */
-    unsigned char *buf;         /* where to write header */
-    int bufSize;
-    unsigned long* pkeys;
-    const unsigned long* pcrc_32_tab;
-    unsigned long crcForCrypting;
-{
-    int n;                       /* index in random header */
-    int t;                       /* temporary */
-    int c;                       /* random byte */
-    unsigned char header[RAND_HEAD_LEN-2]; /* random header */
-    static unsigned calls = 0;   /* ensure different random header each time */
-
-    if (bufSize<RAND_HEAD_LEN)
-      return 0;
-
-    /* First generate RAND_HEAD_LEN-2 random bytes. We encrypt the
-     * output of rand() to get less predictability, since rand() is
-     * often poorly implemented.
-     */
-    if (++calls == 1)
-    {
-        srand((unsigned)(time(NULL) ^ ZCR_SEED2));
-    }
-    init_keys(passwd, pkeys, pcrc_32_tab);
-    for (n = 0; n < RAND_HEAD_LEN-2; n++)
-    {
-        c = (rand() >> 7) & 0xff;
-        header[n] = (unsigned char)zencode(pkeys, pcrc_32_tab, c, t);
-    }
-    /* Encrypt random header (last two bytes is high word of crc) */
-    init_keys(passwd, pkeys, pcrc_32_tab);
-    for (n = 0; n < RAND_HEAD_LEN-2; n++)
-    {
-        buf[n] = (unsigned char)zencode(pkeys, pcrc_32_tab, header[n], t);
-    }
-    buf[n++] = zencode(pkeys, pcrc_32_tab, (int)(crcForCrypting >> 16) & 0xff, t);
-    buf[n++] = zencode(pkeys, pcrc_32_tab, (int)(crcForCrypting >> 24) & 0xff, t);
-    return n;
-}
-
-#endif
diff -ruN ./ioapi.h ../../dep/quazip/quazip/ioapi.h
--- ./ioapi.h	2020-11-27 04:16:54.992498165 +0200
+++ ../../dep/quazip/quazip/ioapi.h	2020-11-27 04:08:04.062517942 +0200
@@ -1,77 +1,207 @@
-/* ioapi.h -- IO base function header for compress/uncompress .zip
-   files using zlib + zip or unzip API
-
-   Version 1.01e, February 12th, 2005
-
-   Copyright (C) 1998-2005 Gilles Vollant
-
-   Modified by Sergey A. Tachenov to integrate with Qt.
-*/
-
-#ifndef _ZLIBIOAPI_H
-#define _ZLIBIOAPI_H
-
-
-#define ZLIB_FILEFUNC_SEEK_CUR (1)
-#define ZLIB_FILEFUNC_SEEK_END (2)
-#define ZLIB_FILEFUNC_SEEK_SET (0)
-
-#define ZLIB_FILEFUNC_MODE_READ      (1)
-#define ZLIB_FILEFUNC_MODE_WRITE     (2)
-#define ZLIB_FILEFUNC_MODE_READWRITEFILTER (3)
-
-#define ZLIB_FILEFUNC_MODE_EXISTING (4)
-#define ZLIB_FILEFUNC_MODE_CREATE   (8)
-
-
-#ifndef ZCALLBACK
-
-#if (defined(WIN32) || defined (WINDOWS) || defined (_WINDOWS)) && defined(CALLBACK) && defined (USEWINDOWS_CALLBACK)
-#define ZCALLBACK CALLBACK
-#else
-#define ZCALLBACK
-#endif
-#endif
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef voidpf (ZCALLBACK *open_file_func) OF((voidpf opaque, voidpf file, int mode));
-typedef uLong  (ZCALLBACK *read_file_func) OF((voidpf opaque, voidpf stream, void* buf, uLong size));
-typedef uLong  (ZCALLBACK *write_file_func) OF((voidpf opaque, voidpf stream, const void* buf, uLong size));
-typedef uLong   (ZCALLBACK *tell_file_func) OF((voidpf opaque, voidpf stream));
-typedef int   (ZCALLBACK *seek_file_func) OF((voidpf opaque, voidpf stream, uLong offset, int origin));
-typedef int    (ZCALLBACK *close_file_func) OF((voidpf opaque, voidpf stream));
-typedef int    (ZCALLBACK *testerror_file_func) OF((voidpf opaque, voidpf stream));
-
-typedef struct zlib_filefunc_def_s
-{
-    open_file_func      zopen_file;
-    read_file_func      zread_file;
-    write_file_func     zwrite_file;
-    tell_file_func      ztell_file;
-    seek_file_func      zseek_file;
-    close_file_func     zclose_file;
-    testerror_file_func zerror_file;
-    voidpf              opaque;
-} zlib_filefunc_def;
-
-
-
-void fill_qiodevice_filefunc OF((zlib_filefunc_def* pzlib_filefunc_def));
-
-#define ZREAD(filefunc,filestream,buf,size) ((*((filefunc).zread_file))((filefunc).opaque,filestream,buf,size))
-#define ZWRITE(filefunc,filestream,buf,size) ((*((filefunc).zwrite_file))((filefunc).opaque,filestream,buf,size))
-#define ZTELL(filefunc,filestream) ((*((filefunc).ztell_file))((filefunc).opaque,filestream))
-#define ZSEEK(filefunc,filestream,pos,mode) ((*((filefunc).zseek_file))((filefunc).opaque,filestream,pos,mode))
-#define ZCLOSE(filefunc,filestream) ((*((filefunc).zclose_file))((filefunc).opaque,filestream))
-#define ZERROR(filefunc,filestream) ((*((filefunc).zerror_file))((filefunc).opaque,filestream))
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
-
+/* ioapi.h -- IO base function header for compress/uncompress .zip
+   part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )
+
+         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )
+
+         Modifications for Zip64 support
+         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )
+
+         Modified by Sergey A. Tachenov to allow QIODevice API usage.
+
+         For more info read MiniZip_info.txt
+
+         Changes
+
+    Oct-2009 - Defined ZPOS64_T to fpos_t on windows and u_int64_t on linux. (might need to find a better why for this)
+    Oct-2009 - Change to fseeko64, ftello64 and fopen64 so large files would work on linux.
+               More if/def section may be needed to support other platforms
+    Oct-2009 - Defined fxxxx64 calls to normal fopen/ftell/fseek so they would compile on windows.
+                          (but you should use iowin32.c for windows instead)
+
+*/
+
+#ifndef _ZLIBIOAPI64_H
+#define _ZLIBIOAPI64_H
+
+#if (!defined(_WIN32)) && (!defined(WIN32))
+
+  // Linux needs this to support file operation on files larger then 4+GB
+  // But might need better if/def to select just the platforms that needs them.
+
+        #ifndef __USE_FILE_OFFSET64
+                #define __USE_FILE_OFFSET64
+        #endif
+        #ifndef __USE_LARGEFILE64
+                #define __USE_LARGEFILE64
+        #endif
+        #ifndef _LARGEFILE64_SOURCE
+                #define _LARGEFILE64_SOURCE
+        #endif
+        #ifndef _FILE_OFFSET_BIT
+                #define _FILE_OFFSET_BIT 64
+        #endif
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <zlib.h>
+
+#if defined(USE_FILE32API)
+#define fopen64 fopen
+#define ftello64 ftell
+#define fseeko64 fseek
+#else
+#ifdef _MSC_VER
+ #define fopen64 fopen
+ #if (_MSC_VER >= 1400) && (!(defined(NO_MSCVER_FILE64_FUNC)))
+  #define ftello64 _ftelli64
+  #define fseeko64 _fseeki64
+ #else // old MSC
+  #define ftello64 ftell
+  #define fseeko64 fseek
+ #endif
+#endif
+#endif
+
+/*
+#ifndef ZPOS64_T
+  #ifdef _WIN32
+                #define ZPOS64_T fpos_t
+  #else
+    #include <stdint.h>
+    #define ZPOS64_T uint64_t
+  #endif
+#endif
+*/
+
+#ifdef HAVE_MINIZIP64_CONF_H
+#include "mz64conf.h"
+#endif
+
+/* a type choosen by DEFINE */
+#ifdef HAVE_64BIT_INT_CUSTOM
+typedef  64BIT_INT_CUSTOM_TYPE ZPOS64_T;
+#else
+#ifdef HAS_STDINT_H
+#include "stdint.h"
+typedef uint64_t ZPOS64_T;
+#else
+
+
+#if defined(_MSC_VER) || defined(__BORLANDC__)
+typedef unsigned __int64 ZPOS64_T;
+#else
+typedef unsigned long long int ZPOS64_T;
+#endif
+#endif
+#endif
+
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef OF
+#define OF _Z_OF
+#endif
+
+#define ZLIB_FILEFUNC_SEEK_CUR (1)
+#define ZLIB_FILEFUNC_SEEK_END (2)
+#define ZLIB_FILEFUNC_SEEK_SET (0)
+
+#define ZLIB_FILEFUNC_MODE_READ      (1)
+#define ZLIB_FILEFUNC_MODE_WRITE     (2)
+#define ZLIB_FILEFUNC_MODE_READWRITEFILTER (3)
+
+#define ZLIB_FILEFUNC_MODE_EXISTING (4)
+#define ZLIB_FILEFUNC_MODE_CREATE   (8)
+
+
+#ifndef ZCALLBACK
+ #if (defined(WIN32) || defined(_WIN32) || defined (WINDOWS) || defined (_WINDOWS)) && defined(CALLBACK) && defined (USEWINDOWS_CALLBACK)
+   #define ZCALLBACK CALLBACK
+ #else
+   #define ZCALLBACK
+ #endif
+#endif
+
+
+
+
+typedef voidpf   (ZCALLBACK *open_file_func)      OF((voidpf opaque, voidpf file, int mode));
+typedef uLong    (ZCALLBACK *read_file_func)      OF((voidpf opaque, voidpf stream, void* buf, uLong size));
+typedef uLong    (ZCALLBACK *write_file_func)     OF((voidpf opaque, voidpf stream, const void* buf, uLong size));
+typedef int      (ZCALLBACK *close_file_func)     OF((voidpf opaque, voidpf stream));
+typedef int      (ZCALLBACK *testerror_file_func) OF((voidpf opaque, voidpf stream));
+
+typedef uLong     (ZCALLBACK *tell_file_func)      OF((voidpf opaque, voidpf stream));
+typedef int     (ZCALLBACK *seek_file_func)      OF((voidpf opaque, voidpf stream, uLong offset, int origin));
+
+
+/* here is the "old" 32 bits structure structure */
+typedef struct zlib_filefunc_def_s
+{
+    open_file_func      zopen_file;
+    read_file_func      zread_file;
+    write_file_func     zwrite_file;
+    tell_file_func      ztell_file;
+    seek_file_func      zseek_file;
+    close_file_func     zclose_file;
+    testerror_file_func zerror_file;
+    voidpf              opaque;
+} zlib_filefunc_def;
+
+typedef ZPOS64_T (ZCALLBACK *tell64_file_func)    OF((voidpf opaque, voidpf stream));
+typedef int     (ZCALLBACK *seek64_file_func)    OF((voidpf opaque, voidpf stream, ZPOS64_T offset, int origin));
+typedef voidpf   (ZCALLBACK *open64_file_func)    OF((voidpf opaque, voidpf file, int mode));
+
+typedef struct zlib_filefunc64_def_s
+{
+    open64_file_func    zopen64_file;
+    read_file_func      zread_file;
+    write_file_func     zwrite_file;
+    tell64_file_func    ztell64_file;
+    seek64_file_func    zseek64_file;
+    close_file_func     zclose_file;
+    testerror_file_func zerror_file;
+    voidpf              opaque;
+    close_file_func     zfakeclose_file; // for no-auto-close flag
+} zlib_filefunc64_def;
+
+void fill_qiodevice64_filefunc OF((zlib_filefunc64_def* pzlib_filefunc_def));
+void fill_qiodevice_filefunc OF((zlib_filefunc_def* pzlib_filefunc_def));
+
+/* now internal definition, only for zip.c and unzip.h */
+typedef struct zlib_filefunc64_32_def_s
+{
+    zlib_filefunc64_def zfile_func64;
+    open_file_func      zopen32_file;
+    tell_file_func      ztell32_file;
+    seek_file_func      zseek32_file;
+} zlib_filefunc64_32_def;
+
+
+#define ZREAD64(filefunc,filestream,buf,size)     ((*((filefunc).zfile_func64.zread_file))   ((filefunc).zfile_func64.opaque,filestream,buf,size))
+#define ZWRITE64(filefunc,filestream,buf,size)    ((*((filefunc).zfile_func64.zwrite_file))  ((filefunc).zfile_func64.opaque,filestream,buf,size))
+//#define ZTELL64(filefunc,filestream)            ((*((filefunc).ztell64_file)) ((filefunc).opaque,filestream))
+//#define ZSEEK64(filefunc,filestream,pos,mode)   ((*((filefunc).zseek64_file)) ((filefunc).opaque,filestream,pos,mode))
+#define ZCLOSE64(filefunc,filestream)             ((*((filefunc).zfile_func64.zclose_file))  ((filefunc).zfile_func64.opaque,filestream))
+#define ZFAKECLOSE64(filefunc,filestream)             ((*((filefunc).zfile_func64.zfakeclose_file))  ((filefunc).zfile_func64.opaque,filestream))
+#define ZERROR64(filefunc,filestream)             ((*((filefunc).zfile_func64.zerror_file))  ((filefunc).zfile_func64.opaque,filestream))
+
+voidpf call_zopen64 OF((const zlib_filefunc64_32_def* pfilefunc,voidpf file,int mode));
+int    call_zseek64 OF((const zlib_filefunc64_32_def* pfilefunc,voidpf filestream, ZPOS64_T offset, int origin));
+ZPOS64_T call_ztell64 OF((const zlib_filefunc64_32_def* pfilefunc,voidpf filestream));
+
+void    fill_zlib_filefunc64_32_def_from_filefunc32(zlib_filefunc64_32_def* p_filefunc64_32,const zlib_filefunc_def* p_filefunc32);
+
+#define ZOPEN64(filefunc,filename,mode)         (call_zopen64((&(filefunc)),(filename),(mode)))
+#define ZTELL64(filefunc,filestream)            (call_ztell64((&(filefunc)),(filestream)))
+#define ZSEEK64(filefunc,filestream,pos,mode)   (call_zseek64((&(filefunc)),(filestream),(pos),(mode)))
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -ruN ./JlCompress.cpp ../../dep/quazip/quazip/JlCompress.cpp
--- ./JlCompress.cpp	2020-11-27 04:16:54.989164832 +0200
+++ ../../dep/quazip/quazip/JlCompress.cpp	2020-11-27 04:08:04.062517942 +0200
@@ -1,5 +1,29 @@
+/*
+Copyright (C) 2010 Roberto Pompermaier
+Copyright (C) 2005-2014 Sergey A. Tachenov
+
+This file is part of QuaZip.
+
+QuaZip is free software: you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation, either version 2.1 of the License, or
+(at your option) any later version.
+
+QuaZip is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with QuaZip.  If not, see <http://www.gnu.org/licenses/>.
+
+See COPYING file for the full LGPL text.
+
+Original ZIP package is copyrighted by Gilles Vollant and contributors,
+see quazip/(un)zip.h files for details. Basically it's the zlib license.
+*/
+
 #include "JlCompress.h"
-#include <QDebug>
 
 static bool copyData(QIODevice &inFile, QIODevice &outFile)
 {
@@ -14,17 +38,6 @@
     return true;
 }
 
-/**OK
- * Comprime il file fileName, nell'oggetto zip, con il nome fileDest.
- *
- * La funzione fallisce se:
- * * zip==NULL;
- * * l'oggetto zip e stato aperto in una modalita non compatibile con l'aggiunta di file;
- * * non e possibile aprire il file d'origine;
- * * non e possibile creare il file all'interno dell'oggetto zip;
- * * si e rilevato un errore nella copia dei dati;
- * * non e stato possibile chiudere il file all'interno dell'oggetto zip;
- */
 bool JlCompress::compressFile(QuaZip* zip, QString fileName, QString fileDest) {
     // zip: oggetto dove aggiungere il file
     // fileName: nome del file reale
@@ -36,46 +49,36 @@
         zip->getMode()!=QuaZip::mdAppend &&
         zip->getMode()!=QuaZip::mdAdd) return false;
 
-    // Apro il file originale
-    QFile inFile;
-    inFile.setFileName(fileName);
-    if(!inFile.open(QIODevice::ReadOnly)) return false;
-
     // Apro il file risulato
     QuaZipFile outFile(zip);
-    if(!outFile.open(QIODevice::WriteOnly, QuaZipNewInfo(fileDest, inFile.fileName()))) return false;
+    if(!outFile.open(QIODevice::WriteOnly, QuaZipNewInfo(fileDest, fileName))) return false;
 
-    // Copio i dati
-    if (!copyData(inFile, outFile) || outFile.getZipError()!=UNZ_OK) {
-        return false;
+    QFileInfo input(fileName);
+    if (quazip_is_symlink(input)) {
+        // Not sure if we should use any specialized codecs here.
+        // After all, a symlink IS just a byte array. And
+        // this is mostly for Linux, where UTF-8 is ubiquitous these days.
+        QString path = quazip_symlink_target(input);
+        QString relativePath = input.dir().relativeFilePath(path);
+        outFile.write(QFile::encodeName(relativePath));
+    } else {
+        QFile inFile;
+        inFile.setFileName(fileName);
+        if (!inFile.open(QIODevice::ReadOnly))
+            return false;
+        if (!copyData(inFile, outFile) || outFile.getZipError()!=UNZ_OK)
+            return false;
+        inFile.close();
     }
 
     // Chiudo i file
     outFile.close();
     if (outFile.getZipError()!=UNZ_OK) return false;
-    inFile.close();
 
     return true;
 }
 
-/**OK
- * Comprime la cartella dir nel file fileCompressed, se recursive e true allora
- * comprime anche le sotto cartelle. I nomi dei file preceduti dal path creato
- * togliendo il pat della cartella origDir al path della cartella dir.
- * Se la funzione fallisce restituisce false e cancella il file che si e tentato
- * di creare.
- *
- * La funzione fallisce se:
- * * zip==NULL;
- * * l'oggetto zip e stato aperto in una modalita non compatibile con l'aggiunta di file;
- * * la cartella dir non esiste;
- * * la compressione di una sotto cartella fallisce (1);
- * * la compressione di un file fallisce;
- * (1) La funzione si richiama in maniera ricorsiva per comprimere le sotto cartelle
- * dunque gli errori di compressione di una sotto cartella sono gli stessi di questa
- * funzione.
- */
-bool JlCompress::compressSubDir(QuaZip* zip, QString dir, QString origDir, bool recursive) {
+bool JlCompress::compressSubDir(QuaZip* zip, QString dir, QString origDir, bool recursive, QDir::Filters filters) {
     // zip: oggetto dove aggiungere il file
     // dir: cartella reale corrente
     // origDir: cartella reale originale
@@ -91,20 +94,34 @@
     QDir directory(dir);
     if (!directory.exists()) return false;
 
+    QDir origDirectory(origDir);
+	if (dir != origDir) {
+		QuaZipFile dirZipFile(zip);
+		if (!dirZipFile.open(QIODevice::WriteOnly,
+            QuaZipNewInfo(origDirectory.relativeFilePath(dir) + QLatin1String("/"), dir), nullptr, 0, 0)) {
+				return false;
+		}
+		dirZipFile.close();
+	}
+
+
     // Se comprimo anche le sotto cartelle
     if (recursive) {
         // Per ogni sotto cartella
-        QFileInfoList files = directory.entryInfoList(QDir::AllDirs|QDir::NoDotAndDotDot);
-        Q_FOREACH (QFileInfo file, files) {
+        QFileInfoList files = directory.entryInfoList(QDir::AllDirs|QDir::NoDotAndDotDot|filters);
+        for (int index = 0; index < files.size(); ++index ) {
+            const QFileInfo & file( files.at( index ) );
+            if (!file.isDir()) // needed for Qt < 4.7 because it doesn't understand AllDirs
+                continue;
             // Comprimo la sotto cartella
-            if(!compressSubDir(zip,file.absoluteFilePath(),origDir,recursive)) return false;
+            if(!compressSubDir(zip,file.absoluteFilePath(),origDir,recursive,filters)) return false;
         }
     }
 
     // Per ogni file nella cartella
-    QFileInfoList files = directory.entryInfoList(QDir::Files);
-    QDir origDirectory(origDir);
-    Q_FOREACH (QFileInfo file, files) {
+    QFileInfoList files = directory.entryInfoList(QDir::Files|filters);
+    for (int index = 0; index < files.size(); ++index ) {
+        const QFileInfo & file( files.at( index ) );
         // Se non e un file o e il file compresso che sto creando
         if(!file.isFile()||file.absoluteFilePath()==zip->getZipName()) continue;
 
@@ -118,20 +135,6 @@
     return true;
 }
 
-/**OK
- * Estrae il file fileName, contenuto nell'oggetto zip, con il nome fileDest.
- * Se la funzione fallisce restituisce false e cancella il file che si e tentato di estrarre.
- *
- * La funzione fallisce se:
- * * zip==NULL;
- * * l'oggetto zip e stato aperto in una modalita non compatibile con l'estrazione di file;
- * * non e possibile aprire il file all'interno dell'oggetto zip;
- * * non e possibile creare il file estratto;
- * * si e rilevato un errore nella copia dei dati (1);
- * * non e stato possibile chiudere il file all'interno dell'oggetto zip (1);
- *
- * (1): prima di uscire dalla funzione cancella il file estratto.
- */
 bool JlCompress::extractFile(QuaZip* zip, QString fileName, QString fileDest) {
     // zip: oggetto dove aggiungere il file
     // filename: nome del file reale
@@ -142,12 +145,41 @@
     if (zip->getMode()!=QuaZip::mdUnzip) return false;
 
     // Apro il file compresso
-    zip->setCurrentFile(fileName);
+    if (!fileName.isEmpty())
+        zip->setCurrentFile(fileName);
     QuaZipFile inFile(zip);
     if(!inFile.open(QIODevice::ReadOnly) || inFile.getZipError()!=UNZ_OK) return false;
 
     // Controllo esistenza cartella file risultato
-    QDir().mkpath(QFileInfo(fileDest).absolutePath());
+    QDir curDir;
+    if (fileDest.endsWith(QLatin1String("/"))) {
+        if (!curDir.mkpath(fileDest)) {
+            return false;
+        }
+    } else {
+        if (!curDir.mkpath(QFileInfo(fileDest).absolutePath())) {
+            return false;
+        }
+    }
+
+    QuaZipFileInfo64 info;
+    if (!zip->getCurrentFileInfo(&info))
+        return false;
+
+    QFile::Permissions srcPerm = info.getPermissions();
+    if (fileDest.endsWith(QLatin1String("/")) && QFileInfo(fileDest).isDir()) {
+        if (srcPerm != 0) {
+            QFile(fileDest).setPermissions(srcPerm);
+        }
+        return true;
+    }
+
+    if (info.isSymbolicLink()) {
+        QString target = QFile::decodeName(inFile.readAll());
+        if (!QFile::link(target, fileDest))
+            return false;
+        return true;
+    }
 
     // Apro il file risultato
     QFile outFile;
@@ -156,9 +188,11 @@
 
     // Copio i dati
     if (!copyData(inFile, outFile) || inFile.getZipError()!=UNZ_OK) {
+        outFile.close();
         removeFile(QStringList(fileDest));
         return false;
     }
+    outFile.close();
 
     // Chiudo i file
     inFile.close();
@@ -166,17 +200,13 @@
         removeFile(QStringList(fileDest));
         return false;
     }
-    outFile.close();
 
+    if (srcPerm != 0) {
+        outFile.setPermissions(srcPerm);
+    }
     return true;
 }
 
-/**
- * Rimuove i file il cui nome e specificato all'interno di listFile.
- * Restituisce true se tutti i file sono stati cancellati correttamente, attenzione
- * perche puo restituire false anche se alcuni file non esistevano e si e tentato
- * di cancellarli.
- */
 bool JlCompress::removeFile(QStringList listFile) {
     bool ret = true;
     // Per ogni file
@@ -187,269 +217,208 @@
     return ret;
 }
 
-////////////////////////////////////////////////////////////////////////////////
-////////////////////////////////////////////////////////////////////////////////
-/**OK
- * Comprime il file fileName nel file fileCompressed.
- * Se la funzione fallisce restituisce false e cancella il file che si e tentato
- * di creare.
- *
- * La funzione fallisce se:
- * * non si riesce ad aprire l'oggetto zip;
- * * la compressione del file fallisce;
- * * non si riesce a chiudere l'oggetto zip;
- */
 bool JlCompress::compressFile(QString fileCompressed, QString file) {
     // Creo lo zip
-    QuaZip* zip  = new QuaZip(QFileInfo(fileCompressed).absoluteFilePath());
+    QuaZip zip(fileCompressed);
     QDir().mkpath(QFileInfo(fileCompressed).absolutePath());
-    if(!zip->open(QuaZip::mdCreate)) {
-        delete zip;
+    if(!zip.open(QuaZip::mdCreate)) {
         QFile::remove(fileCompressed);
         return false;
     }
 
     // Aggiungo il file
-    if (!compressFile(zip,file,QFileInfo(file).fileName())) {
-        delete zip;
+    if (!compressFile(&zip,file,QFileInfo(file).fileName())) {
         QFile::remove(fileCompressed);
         return false;
     }
 
     // Chiudo il file zip
-    zip->close();
-    if(zip->getZipError()!=0) {
-        delete zip;
+    zip.close();
+    if(zip.getZipError()!=0) {
         QFile::remove(fileCompressed);
         return false;
     }
-    delete zip;
 
     return true;
 }
 
-/**OK
- * Comprime i file specificati in files nel file fileCompressed.
- * Se la funzione fallisce restituisce false e cancella il file che si e tentato
- * di creare.
- *
- * La funzione fallisce se:
- * * non si riesce ad aprire l'oggetto zip;
- * * la compressione di un file fallisce;
- * * non si riesce a chiudere l'oggetto zip;
- */
 bool JlCompress::compressFiles(QString fileCompressed, QStringList files) {
     // Creo lo zip
-    QuaZip* zip  = new QuaZip(QFileInfo(fileCompressed).absoluteFilePath());
+    QuaZip zip(fileCompressed);
     QDir().mkpath(QFileInfo(fileCompressed).absolutePath());
-    if(!zip->open(QuaZip::mdCreate)) {
-        delete zip;
+    if(!zip.open(QuaZip::mdCreate)) {
         QFile::remove(fileCompressed);
         return false;
     }
 
     // Comprimo i file
     QFileInfo info;
-    Q_FOREACH (QString file, files) {
+    for (int index = 0; index < files.size(); ++index ) {
+        const QString & file( files.at( index ) );
         info.setFile(file);
-        if (!info.exists() || !compressFile(zip,file,info.fileName())) {
-            delete zip;
+        if (!info.exists() || !compressFile(&zip,file,info.fileName())) {
             QFile::remove(fileCompressed);
             return false;
         }
     }
 
     // Chiudo il file zip
-    zip->close();
-    if(zip->getZipError()!=0) {
-        delete zip;
+    zip.close();
+    if(zip.getZipError()!=0) {
         QFile::remove(fileCompressed);
         return false;
     }
-    delete zip;
 
     return true;
 }
 
-/**OK
- * Comprime la cartella dir nel file fileCompressed, se recursive e true allora
- * comprime anche le sotto cartelle.
- * Se la funzione fallisce restituisce false e cancella il file che si e tentato
- * di creare.
- *
- * La funzione fallisce se:
- * * non si riesce ad aprire l'oggetto zip;
- * * la compressione di un file fallisce;
- * * non si riesce a chiudere l'oggetto zip;
- */
 bool JlCompress::compressDir(QString fileCompressed, QString dir, bool recursive) {
+    return compressDir(fileCompressed, dir, recursive, QDir::Filters());
+}
+
+bool JlCompress::compressDir(QString fileCompressed, QString dir,
+                             bool recursive, QDir::Filters filters)
+{
     // Creo lo zip
-    QuaZip* zip  = new QuaZip(QFileInfo(fileCompressed).absoluteFilePath());
+    QuaZip zip(fileCompressed);
     QDir().mkpath(QFileInfo(fileCompressed).absolutePath());
-    if(!zip->open(QuaZip::mdCreate)) {
-        delete zip;
+    if(!zip.open(QuaZip::mdCreate)) {
         QFile::remove(fileCompressed);
         return false;
     }
 
     // Aggiungo i file e le sotto cartelle
-    if (!compressSubDir(zip,dir,dir,recursive)<0) {
-        delete zip;
+    if (!compressSubDir(&zip,dir,dir,recursive, filters)) {
         QFile::remove(fileCompressed);
         return false;
     }
 
     // Chiudo il file zip
-    zip->close();
-    if(zip->getZipError()!=0) {
-        delete zip;
+    zip.close();
+    if(zip.getZipError()!=0) {
         QFile::remove(fileCompressed);
         return false;
     }
-    delete zip;
 
     return true;
 }
 
-////////////////////////////////////////////////////////////////////////////////
-////////////////////////////////////////////////////////////////////////////////
-/**OK
- * Estrae il file fileName, contenuto nel file fileCompressed, con il nome fileDest.
- * Se fileDest = "" allora il file viene estratto con lo stesso nome con cui e
- * stato compresso.
- * Se la funzione fallisce cancella il file che si e tentato di estrarre.
- * Restituisce il nome assoluto del file estratto.
- *
- * La funzione fallisce se:
- * * non si riesce ad aprire l'oggetto zip;
- * * l'estrazione del file fallisce;
- * * non si riesce a chiudere l'oggetto zip;
- */
 QString JlCompress::extractFile(QString fileCompressed, QString fileName, QString fileDest) {
     // Apro lo zip
-    QuaZip* zip  = new QuaZip(QFileInfo(fileCompressed).absoluteFilePath());
-    if(!zip->open(QuaZip::mdUnzip)) {
-        delete zip;
+    QuaZip zip(fileCompressed);
+    return extractFile(zip, fileName, fileDest);
+}
+
+QString JlCompress::extractFile(QuaZip &zip, QString fileName, QString fileDest)
+{
+    if(!zip.open(QuaZip::mdUnzip)) {
         return QString();
     }
 
     // Estraggo il file
-    if (fileDest.isEmpty()) fileDest = fileName;
-    if (!extractFile(zip,fileName,fileDest)) {
-        delete zip;
+    if (fileDest.isEmpty())
+        fileDest = fileName;
+    if (!extractFile(&zip,fileName,fileDest)) {
         return QString();
     }
 
     // Chiudo il file zip
-    zip->close();
-    if(zip->getZipError()!=0) {
+    zip.close();
+    if(zip.getZipError()!=0) {
         removeFile(QStringList(fileDest));
         return QString();
     }
-    delete zip;
-
     return QFileInfo(fileDest).absoluteFilePath();
 }
 
-/**OK
- * Estrae i file specificati in files, contenuti nel file fileCompressed, nella
- * cartella dir. La struttura a cartelle del file compresso viene rispettata.
- * Se dir = "" allora il file viene estratto nella cartella corrente.
- * Se la funzione fallisce cancella i file che si e tentato di estrarre.
- * Restituisce i nomi assoluti dei file estratti.
- *
- * La funzione fallisce se:
- * * non si riesce ad aprire l'oggetto zip;
- * * l'estrazione di un file fallisce;
- * * non si riesce a chiudere l'oggetto zip;
- */
 QStringList JlCompress::extractFiles(QString fileCompressed, QStringList files, QString dir) {
     // Creo lo zip
-    QuaZip* zip  = new QuaZip(QFileInfo(fileCompressed).absoluteFilePath());
-    if(!zip->open(QuaZip::mdUnzip)) {
-        delete zip;
+    QuaZip zip(fileCompressed);
+    return extractFiles(zip, files, dir);
+}
+
+QStringList JlCompress::extractFiles(QuaZip &zip, const QStringList &files, const QString &dir)
+{
+    if(!zip.open(QuaZip::mdUnzip)) {
         return QStringList();
     }
 
     // Estraggo i file
+    QStringList extracted;
     for (int i=0; i<files.count(); i++) {
-        if (!extractFile(zip, files.at(i), QDir(dir).absoluteFilePath(files.at(i)))) {
-            delete zip;
-            removeFile(files);
+        QString absPath = QDir(dir).absoluteFilePath(files.at(i));
+        if (!extractFile(&zip, files.at(i), absPath)) {
+            removeFile(extracted);
             return QStringList();
         }
-        files[i] = QDir(dir).absoluteFilePath(files.at(i));
+        extracted.append(absPath);
     }
 
     // Chiudo il file zip
-    zip->close();
-    if(zip->getZipError()!=0) {
-        delete zip;
-        removeFile(files);
+    zip.close();
+    if(zip.getZipError()!=0) {
+        removeFile(extracted);
         return QStringList();
     }
-    delete zip;
 
-    return files;
+    return extracted;
 }
 
-/**OK
- * Estrae il file fileCompressed nella cartella dir.
- * Se dir = "" allora il file viene estratto nella cartella corrente.
- * Se la funzione fallisce cancella i file che si e tentato di estrarre.
- * Restituisce i nomi assoluti dei file estratti.
- *
- * La funzione fallisce se:
- * * non si riesce ad aprire l'oggetto zip;
- * * la compressione di un file fallisce;
- * * non si riesce a chiudere l'oggetto zip;
- */
-QStringList JlCompress::extractDir(QString fileCompressed, QString dir) {
+QStringList JlCompress::extractDir(QString fileCompressed, QTextCodec* fileNameCodec, QString dir) {
     // Apro lo zip
-    QuaZip* zip = new QuaZip(QFileInfo(fileCompressed).absoluteFilePath());
-    if(!zip->open(QuaZip::mdUnzip)) {
-        delete zip;
-        return QStringList();
-    }
+    QuaZip zip(fileCompressed);
+    if (fileNameCodec)
+        zip.setFileNameCodec(fileNameCodec);
+    return extractDir(zip, dir);
+}
 
-    // Estraggo i file
-    QStringList lst = getFileList(fileCompressed);
+QStringList JlCompress::extractDir(QString fileCompressed, QString dir) {
+    return extractDir(fileCompressed, nullptr, dir);
+}
 
-    QDir directory(dir);
-    for (int i=0; i<lst.count(); i++) {
-        QString absFilePath = directory.absoluteFilePath(lst.at(i));
-        if (!extractFile(zip, lst.at(i), absFilePath)) {
-            delete zip;
-            removeFile(lst);
+QStringList JlCompress::extractDir(QuaZip &zip, const QString &dir)
+{
+    if(!zip.open(QuaZip::mdUnzip)) {
+        return QStringList();
+    }
+    QString cleanDir = QDir::cleanPath(dir);
+    QDir directory(cleanDir);
+    QString absCleanDir = directory.absolutePath();
+    QStringList extracted;
+    if (!zip.goToFirstFile()) {
+        return QStringList();
+    }
+    do {
+        QString name = zip.getCurrentFileName();
+        QString absFilePath = directory.absoluteFilePath(name);
+        QString absCleanPath = QDir::cleanPath(absFilePath);
+        if (!absCleanPath.startsWith(absCleanDir + QLatin1String("/")))
+            continue;
+        if (!extractFile(&zip, QLatin1String(""), absFilePath)) {
+            removeFile(extracted);
             return QStringList();
         }
-        lst[i] = absFilePath;
-    }
+        extracted.append(absFilePath);
+    } while (zip.goToNextFile());
 
     // Chiudo il file zip
-    zip->close();
-    if(zip->getZipError()!=0) {
-        delete zip;
-        removeFile(lst);
+    zip.close();
+    if(zip.getZipError()!=0) {
+        removeFile(extracted);
         return QStringList();
     }
-    delete zip;
 
-    return lst;
+    return extracted;
 }
 
-/**OK
- * Restituisce la lista dei file resenti nel file compresso fileCompressed.
- * Se la funzione fallisce, restituisce un elenco vuoto.
- *
- * La funzione fallisce se:
- * * non si riesce ad aprire l'oggetto zip;
- * * la richiesta di informazioni di un file fallisce;
- * * non si riesce a chiudere l'oggetto zip;
- */
 QStringList JlCompress::getFileList(QString fileCompressed) {
     // Apro lo zip
     QuaZip* zip = new QuaZip(QFileInfo(fileCompressed).absoluteFilePath());
+    return getFileList(zip);
+}
+
+QStringList JlCompress::getFileList(QuaZip *zip)
+{
     if(!zip->open(QuaZip::mdUnzip)) {
         delete zip;
         return QStringList();
@@ -457,7 +426,7 @@
 
     // Estraggo i nomi dei file
     QStringList lst;
-    QuaZipFileInfo info;
+    QuaZipFileInfo64 info;
     for(bool more=zip->goToFirstFile(); more; more=zip->goToNextFile()) {
       if(!zip->getCurrentFileInfo(&info)) {
           delete zip;
@@ -474,7 +443,36 @@
         return QStringList();
     }
     delete zip;
-
     return lst;
 }
 
+QStringList JlCompress::extractDir(QIODevice* ioDevice, QTextCodec* fileNameCodec, QString dir)
+{
+    QuaZip zip(ioDevice);
+    if (fileNameCodec)
+        zip.setFileNameCodec(fileNameCodec);
+    return extractDir(zip, dir);
+}
+
+QStringList JlCompress::extractDir(QIODevice *ioDevice, QString dir)
+{
+    return extractDir(ioDevice, nullptr, dir);
+}
+
+QStringList JlCompress::getFileList(QIODevice *ioDevice)
+{
+    QuaZip *zip = new QuaZip(ioDevice);
+    return getFileList(zip);
+}
+
+QString JlCompress::extractFile(QIODevice *ioDevice, QString fileName, QString fileDest)
+{
+    QuaZip zip(ioDevice);
+    return extractFile(zip, fileName, fileDest);
+}
+
+QStringList JlCompress::extractFiles(QIODevice *ioDevice, QStringList files, QString dir)
+{
+    QuaZip zip(ioDevice);
+    return extractFiles(zip, files, dir);
+} 
diff -ruN ./JlCompress.h ../../dep/quazip/quazip/JlCompress.h
--- ./JlCompress.h	2020-11-27 04:16:54.989164832 +0200
+++ ../../dep/quazip/quazip/JlCompress.h	2020-11-27 04:08:04.062517942 +0200
@@ -1,13 +1,39 @@
 #ifndef JLCOMPRESSFOLDER_H_
 #define JLCOMPRESSFOLDER_H_
 
+/*
+Copyright (C) 2010 Roberto Pompermaier
+Copyright (C) 2005-2016 Sergey A. Tachenov
+
+This file is part of QuaZip.
+
+QuaZip is free software: you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation, either version 2.1 of the License, or
+(at your option) any later version.
+
+QuaZip is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with QuaZip.  If not, see <http://www.gnu.org/licenses/>.
+
+See COPYING file for the full LGPL text.
+
+Original ZIP package is copyrighted by Gilles Vollant and contributors,
+see quazip/(un)zip.h files for details. Basically it's the zlib license.
+*/
+
 #include "quazip.h"
 #include "quazipfile.h"
 #include "quazipfileinfo.h"
-#include <QString>
-#include <QDir>
-#include <QFileInfo>
-#include <QFile>
+#include "quazip_qt_compat.h"
+#include <QtCore/QString>
+#include <QtCore/QDir>
+#include <QtCore/QFileInfo>
+#include <QtCore/QFile>
 
 /// Utility class for typical operations.
 /**
@@ -16,6 +42,10 @@
   */
 class QUAZIP_EXPORT JlCompress {
 private:
+    static QStringList extractDir(QuaZip &zip, const QString &dir);
+    static QStringList getFileList(QuaZip *zip);
+    static QString extractFile(QuaZip &zip, QString fileName, QString fileDest);
+    static QStringList extractFiles(QuaZip &zip, const QStringList &files, const QString &dir);
     /// Compress a single file.
     /**
       \param zip Opened zip to compress the file to.
@@ -34,7 +64,8 @@
       files.
       \return true if success, false otherwise.
       */
-    static bool compressSubDir(QuaZip* parentZip, QString dir, QString parentDir, bool recursive = true);
+    static bool compressSubDir(QuaZip* parentZip, QString dir, QString parentDir, bool recursive,
+                               QDir::Filters filters);
     /// Extract a single file.
     /**
       \param zip The opened zip archive to extract from.
@@ -67,6 +98,8 @@
     static bool compressFiles(QString fileCompressed, QStringList files);
     /// Compress a whole directory.
     /**
+      Does not compress hidden files. See compressDir(QString, QString, bool, QDir::Filters).
+
       \param fileCompressed The name of the archive.
       \param dir The directory to compress.
       \param recursive Whether to pack the subdirectories as well, or
@@ -74,6 +107,24 @@
       \return true if success, false otherwise.
       */
     static bool compressDir(QString fileCompressed, QString dir = QString(), bool recursive = true);
+    /**
+     * @brief Compress a whole directory.
+     *
+     * Unless filters are specified explicitly, packs
+     * only regular non-hidden files (and subdirs, if @c recursive is true).
+     * If filters are specified, they are OR-combined with
+     * <tt>%QDir::AllDirs|%QDir::NoDotAndDotDot</tt> when searching for dirs
+     * and with <tt>QDir::Files</tt> when searching for files.
+     *
+     * @param fileCompressed path to the resulting archive
+     * @param dir path to the directory being compressed
+     * @param recursive if true, then the subdirectories are packed as well
+     * @param filters what to pack, filters are applied both when searching
+     * for subdirs (if packing recursively) and when looking for files to pack
+     * @return true on success, false otherwise
+     */
+    static bool compressDir(QString fileCompressed, QString dir,
+                            bool recursive, QDir::Filters filters);
 
 public:
     /// Extract a single file.
@@ -102,6 +153,15 @@
       \return The list of the full paths of the files extracted, empty on failure.
       */
     static QStringList extractDir(QString fileCompressed, QString dir = QString());
+    /// Extract a whole archive.
+    /**
+      \param fileCompressed The name of the archive.
+      \param fileNameCodec The codec to use for file names.
+      \param dir The directory to extract to, the current directory if
+      left empty.
+      \return The list of the full paths of the files extracted, empty on failure.
+      */
+    static QStringList extractDir(QString fileCompressed, QTextCodec* fileNameCodec, QString dir = QString());
     /// Get the file list.
     /**
       \return The list of the files in the archive, or, more precisely, the
@@ -109,6 +169,48 @@
       are present separately.
       */
     static QStringList getFileList(QString fileCompressed);
+    /// Extract a single file.
+    /**
+      \param ioDevice pointer to device with compressed data.
+      \param fileName The file to extract.
+      \param fileDest The destination file, assumed to be identical to
+      \a file if left empty.
+      \return The list of the full paths of the files extracted, empty on failure.
+      */
+    static QString extractFile(QIODevice *ioDevice, QString fileName, QString fileDest = QString());
+    /// Extract a list of files.
+    /**
+      \param ioDevice pointer to device with compressed data.
+      \param files The file list to extract.
+      \param dir The directory to put the files to, the current
+      directory if left empty.
+      \return The list of the full paths of the files extracted, empty on failure.
+      */
+    static QStringList extractFiles(QIODevice *ioDevice, QStringList files, QString dir = QString());
+    /// Extract a whole archive.
+    /**
+      \param ioDevice pointer to device with compressed data.
+      \param dir The directory to extract to, the current directory if
+      left empty.
+      \return The list of the full paths of the files extracted, empty on failure.
+      */
+    static QStringList extractDir(QIODevice *ioDevice, QString dir = QString());
+    /// Extract a whole archive.
+    /**
+      \param ioDevice pointer to device with compressed data.
+      \param fileNameCodec The codec to use for file names.
+      \param dir The directory to extract to, the current directory if
+      left empty.
+      \return The list of the full paths of the files extracted, empty on failure.
+      */
+    static QStringList extractDir(QIODevice* ioDevice, QTextCodec* fileNameCodec, QString dir = QString());
+    /// Get the file list.
+    /**
+      \return The list of the files in the archive, or, more precisely, the
+      list of the entries, including both files and directories if they
+      are present separately.
+      */
+    static QStringList getFileList(QIODevice *ioDevice); 
 };
 
 #endif /* JLCOMPRESSFOLDER_H_ */
diff -ruN ./qioapi.cpp ../../dep/quazip/quazip/qioapi.cpp
--- ./qioapi.cpp	2020-11-27 04:16:54.992498165 +0200
+++ ../../dep/quazip/quazip/qioapi.cpp	2020-11-27 04:08:04.062517942 +0200
@@ -1,142 +1,348 @@
-/* ioapi.c -- IO base function header for compress/uncompress .zip
-   files using zlib + zip or unzip API
-
-   Version 1.01e, February 12th, 2005
-
-   Copyright (C) 1998-2005 Gilles Vollant
-
-   Modified by Sergey A. Tachenov to integrate with Qt.
-*/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include "zlib.h"
-#include "ioapi.h"
-#include "quazip_global.h"
-#include <QIODevice>
-
-
-/* I've found an old Unix (a SunOS 4.1.3_U1) without all SEEK_* defined.... */
-
-#ifndef SEEK_CUR
-#define SEEK_CUR    1
-#endif
-
-#ifndef SEEK_END
-#define SEEK_END    2
-#endif
-
-#ifndef SEEK_SET
-#define SEEK_SET    0
-#endif
-
-voidpf ZCALLBACK qiodevice_open_file_func (
-   voidpf opaque UNUSED,
-   voidpf file,
-   int mode)
-{
-    QIODevice *iodevice = reinterpret_cast<QIODevice*>(file);
-    if(iodevice->isSequential())
-        return NULL;
-    if ((mode & ZLIB_FILEFUNC_MODE_READWRITEFILTER)==ZLIB_FILEFUNC_MODE_READ)
-        iodevice->open(QIODevice::ReadOnly);
-    else
-    if (mode & ZLIB_FILEFUNC_MODE_EXISTING)
-        iodevice->open(QIODevice::ReadWrite);
-    else
-    if (mode & ZLIB_FILEFUNC_MODE_CREATE)
-        iodevice->open(QIODevice::WriteOnly);
-
-    if(iodevice->isOpen())
-        return iodevice;
-    else
-        return NULL;
-}
-
-
-uLong ZCALLBACK qiodevice_read_file_func (
-   voidpf opaque UNUSED,
-   voidpf stream,
-   void* buf,
-   uLong size)
-{
-    uLong ret;
-    ret = (uLong)((QIODevice*)stream)->read((char*)buf,size);
-    return ret;
-}
-
-
-uLong ZCALLBACK qiodevice_write_file_func (
-   voidpf opaque UNUSED,
-   voidpf stream,
-   const void* buf,
-   uLong size)
-{
-    uLong ret;
-    ret = (uLong)((QIODevice*)stream)->write((char*)buf,size);
-    return ret;
-}
-
-uLong ZCALLBACK qiodevice_tell_file_func (
-   voidpf opaque UNUSED,
-   voidpf stream)
-{
-    uLong ret;
-    ret = ((QIODevice*)stream)->pos();
-    return ret;
-}
-
-int ZCALLBACK qiodevice_seek_file_func (
-   voidpf opaque UNUSED,
-   voidpf stream,
-   uLong offset,
-   int origin)
-{
-    uLong qiodevice_seek_result=0;
-    int ret;
-    switch (origin)
-    {
-    case ZLIB_FILEFUNC_SEEK_CUR :
-        qiodevice_seek_result = ((QIODevice*)stream)->pos() + offset;
-        break;
-    case ZLIB_FILEFUNC_SEEK_END :
-        qiodevice_seek_result = ((QIODevice*)stream)->size() - offset;
-        break;
-    case ZLIB_FILEFUNC_SEEK_SET :
-        qiodevice_seek_result = offset;
-        break;
-    default: return -1;
-    }
-    ret = !((QIODevice*)stream)->seek(qiodevice_seek_result);
-    return ret;
-}
-
-int ZCALLBACK qiodevice_close_file_func (
-   voidpf opaque UNUSED,
-   voidpf stream)
-{
-    ((QIODevice*)stream)->close();
-    return 0;
-}
-
-int ZCALLBACK qiodevice_error_file_func (
-   voidpf opaque UNUSED,
-   voidpf stream)
-{
-    return !((QIODevice*)stream)->errorString().isEmpty();
-}
-
-void fill_qiodevice_filefunc (
-  zlib_filefunc_def* pzlib_filefunc_def)
-{
-    pzlib_filefunc_def->zopen_file = qiodevice_open_file_func;
-    pzlib_filefunc_def->zread_file = qiodevice_read_file_func;
-    pzlib_filefunc_def->zwrite_file = qiodevice_write_file_func;
-    pzlib_filefunc_def->ztell_file = qiodevice_tell_file_func;
-    pzlib_filefunc_def->zseek_file = qiodevice_seek_file_func;
-    pzlib_filefunc_def->zclose_file = qiodevice_close_file_func;
-    pzlib_filefunc_def->zerror_file = qiodevice_error_file_func;
-    pzlib_filefunc_def->opaque = NULL;
-}
+/* ioapi.c -- IO base function header for compress/uncompress .zip
+   files using zlib + zip or unzip API
+
+   Version 1.01e, February 12th, 2005
+
+   Copyright (C) 1998-2005 Gilles Vollant
+
+   Modified by Sergey A. Tachenov to integrate with Qt.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <zlib.h>
+
+#include "ioapi.h"
+#include "quazip_global.h"
+#include <QtCore/QIODevice>
+#include "quazip_qt_compat.h"
+
+/* I've found an old Unix (a SunOS 4.1.3_U1) without all SEEK_* defined.... */
+
+#ifndef SEEK_CUR
+#define SEEK_CUR    1
+#endif
+
+#ifndef SEEK_END
+#define SEEK_END    2
+#endif
+
+#ifndef SEEK_SET
+#define SEEK_SET    0
+#endif
+
+voidpf call_zopen64 (const zlib_filefunc64_32_def* pfilefunc,voidpf file,int mode)
+{
+    if (pfilefunc->zfile_func64.zopen64_file != nullptr)
+        return (*(pfilefunc->zfile_func64.zopen64_file)) (pfilefunc->zfile_func64.opaque,file,mode);
+    else
+    {
+        return (*(pfilefunc->zopen32_file))(pfilefunc->zfile_func64.opaque,file,mode);
+    }
+}
+
+int call_zseek64 (const zlib_filefunc64_32_def* pfilefunc,voidpf filestream, ZPOS64_T offset, int origin)
+{
+    if (pfilefunc->zfile_func64.zseek64_file != nullptr)
+        return (*(pfilefunc->zfile_func64.zseek64_file)) (pfilefunc->zfile_func64.opaque,filestream,offset,origin);
+    else
+    {
+        uLong offsetTruncated = (uLong)offset;
+        if (offsetTruncated != offset)
+            return -1;
+        else
+            return (*(pfilefunc->zseek32_file))(pfilefunc->zfile_func64.opaque,filestream,offsetTruncated,origin);
+    }
+}
+
+ZPOS64_T call_ztell64 (const zlib_filefunc64_32_def* pfilefunc,voidpf filestream)
+{
+    if (pfilefunc->zfile_func64.zseek64_file != nullptr)
+        return (*(pfilefunc->zfile_func64.ztell64_file)) (pfilefunc->zfile_func64.opaque,filestream);
+    else
+    {
+        uLong tell_uLong = (*(pfilefunc->ztell32_file))(pfilefunc->zfile_func64.opaque,filestream);
+        if ((tell_uLong) == ((uLong)-1))
+            return (ZPOS64_T)-1;
+        else
+            return tell_uLong;
+    }
+}
+
+/// @cond internal
+struct QIODevice_descriptor {
+    // Position only used for writing to sequential devices.
+    qint64 pos;
+    inline QIODevice_descriptor():
+        pos(0)
+    {}
+};
+/// @endcond
+
+voidpf ZCALLBACK qiodevice_open_file_func (
+   voidpf opaque,
+   voidpf file,
+   int mode)
+{
+    QIODevice_descriptor *d = reinterpret_cast<QIODevice_descriptor*>(opaque);
+    QIODevice *iodevice = reinterpret_cast<QIODevice*>(file);
+    QIODevice::OpenMode desiredMode;
+    if ((mode & ZLIB_FILEFUNC_MODE_READWRITEFILTER)==ZLIB_FILEFUNC_MODE_READ)
+        desiredMode = QIODevice::ReadOnly;
+    else if (mode & ZLIB_FILEFUNC_MODE_EXISTING)
+        desiredMode = QIODevice::ReadWrite;
+    else if (mode & ZLIB_FILEFUNC_MODE_CREATE)
+        desiredMode = QIODevice::WriteOnly;
+    if (iodevice->isOpen()) {
+        if ((iodevice->openMode() & desiredMode) == desiredMode) {
+            if (desiredMode != QIODevice::WriteOnly
+                    && iodevice->isSequential()) {
+                // We can use sequential devices only for writing.
+                delete d;
+                return nullptr;
+            } else {
+                if ((desiredMode & QIODevice::WriteOnly) != 0) {
+                    // open for writing, need to seek existing device
+                    if (!iodevice->isSequential()) {
+                        iodevice->seek(0);
+                    } else {
+                        d->pos = iodevice->pos();
+                    }
+                }
+            }
+            return iodevice;
+        } else {
+            delete d;
+            return nullptr;
+        }
+    }
+    iodevice->open(desiredMode);
+    if (iodevice->isOpen()) {
+        if (desiredMode != QIODevice::WriteOnly && iodevice->isSequential()) {
+            // We can use sequential devices only for writing.
+            iodevice->close();
+            delete d;
+            return nullptr;
+        } else {
+            return iodevice;
+        }
+    } else {
+        delete d;
+        return nullptr;
+    }
+}
+
+
+uLong ZCALLBACK qiodevice_read_file_func (
+   voidpf opaque,
+   voidpf stream,
+   void* buf,
+   uLong size)
+{
+    QIODevice_descriptor *d = reinterpret_cast<QIODevice_descriptor*>(opaque);
+    QIODevice *iodevice = reinterpret_cast<QIODevice*>(stream);
+    qint64 ret64 = iodevice->read((char*)buf,size);
+    uLong ret;
+    ret = (uLong) ret64;
+    if (ret64 != -1) {
+        d->pos += ret64;
+    }
+    return ret;
+}
+
+
+uLong ZCALLBACK qiodevice_write_file_func (
+   voidpf opaque,
+   voidpf stream,
+   const void* buf,
+   uLong size)
+{
+    QIODevice_descriptor *d = reinterpret_cast<QIODevice_descriptor*>(opaque);
+    QIODevice *iodevice = reinterpret_cast<QIODevice*>(stream);
+    uLong ret;
+    qint64 ret64 = iodevice->write((char*)buf,size);
+    if (ret64 != -1) {
+        d->pos += ret64;
+    }
+    ret = (uLong) ret64;
+    return ret;
+}
+
+uLong ZCALLBACK qiodevice_tell_file_func (
+   voidpf opaque,
+   voidpf stream)
+{
+    QIODevice_descriptor *d = reinterpret_cast<QIODevice_descriptor*>(opaque);
+    QIODevice *iodevice = reinterpret_cast<QIODevice*>(stream);
+    uLong ret;
+    qint64 ret64;
+    if (iodevice->isSequential()) {
+        ret64 = d->pos;
+    } else {
+        ret64 = iodevice->pos();
+    }
+    ret = static_cast<uLong>(ret64);
+    return ret;
+}
+
+ZPOS64_T ZCALLBACK qiodevice64_tell_file_func (
+   voidpf opaque,
+   voidpf stream)
+{
+    QIODevice_descriptor *d = reinterpret_cast<QIODevice_descriptor*>(opaque);
+    QIODevice *iodevice = reinterpret_cast<QIODevice*>(stream);
+    qint64 ret;
+    if (iodevice->isSequential()) {
+        ret = d->pos;
+    } else {
+        ret = iodevice->pos();
+    }
+    return static_cast<ZPOS64_T>(ret);
+}
+
+int ZCALLBACK qiodevice_seek_file_func (
+   voidpf /*opaque UNUSED*/,
+   voidpf stream,
+   uLong offset,
+   int origin)
+{
+    QIODevice *iodevice = reinterpret_cast<QIODevice*>(stream);
+    if (iodevice->isSequential()) {
+        if (origin == ZLIB_FILEFUNC_SEEK_END
+                && offset == 0) {
+            // sequential devices are always at end (needed in mdAppend)
+            return 0;
+        } else {
+            qWarning("qiodevice_seek_file_func() called for sequential device");
+            return -1;
+        }
+    }
+    uLong qiodevice_seek_result=0;
+    int ret;
+    switch (origin)
+    {
+    case ZLIB_FILEFUNC_SEEK_CUR :
+        qiodevice_seek_result = ((QIODevice*)stream)->pos() + offset;
+        break;
+    case ZLIB_FILEFUNC_SEEK_END :
+        qiodevice_seek_result = ((QIODevice*)stream)->size() - offset;
+        break;
+    case ZLIB_FILEFUNC_SEEK_SET :
+        qiodevice_seek_result = offset;
+        break;
+    default:
+        return -1;
+    }
+    ret = !iodevice->seek(qiodevice_seek_result);
+    return ret;
+}
+
+int ZCALLBACK qiodevice64_seek_file_func (
+   voidpf /*opaque UNUSED*/,
+   voidpf stream,
+   ZPOS64_T offset,
+   int origin)
+{
+    QIODevice *iodevice = reinterpret_cast<QIODevice*>(stream);
+    if (iodevice->isSequential()) {
+        if (origin == ZLIB_FILEFUNC_SEEK_END
+                && offset == 0) {
+            // sequential devices are always at end (needed in mdAppend)
+            return 0;
+        } else {
+            qWarning("qiodevice_seek_file_func() called for sequential device");
+            return -1;
+        }
+    }
+    qint64 qiodevice_seek_result=0;
+    int ret;
+    switch (origin)
+    {
+    case ZLIB_FILEFUNC_SEEK_CUR :
+        qiodevice_seek_result = ((QIODevice*)stream)->pos() + offset;
+        break;
+    case ZLIB_FILEFUNC_SEEK_END :
+        qiodevice_seek_result = ((QIODevice*)stream)->size() - offset;
+        break;
+    case ZLIB_FILEFUNC_SEEK_SET :
+        qiodevice_seek_result = offset;
+        break;
+    default:
+        return -1;
+    }
+    ret = !iodevice->seek(qiodevice_seek_result);
+    return ret;
+}
+
+int ZCALLBACK qiodevice_close_file_func (
+   voidpf opaque,
+   voidpf stream)
+{
+    QIODevice_descriptor *d = reinterpret_cast<QIODevice_descriptor*>(opaque);
+    delete d;
+    QIODevice *device = reinterpret_cast<QIODevice*>(stream);
+    return quazip_close(device) ? 0 : -1;
+}
+
+int ZCALLBACK qiodevice_fakeclose_file_func (
+   voidpf opaque,
+   voidpf /*stream*/)
+{
+    QIODevice_descriptor *d = reinterpret_cast<QIODevice_descriptor*>(opaque);
+    delete d;
+    return 0;
+}
+
+int ZCALLBACK qiodevice_error_file_func (
+   voidpf /*opaque UNUSED*/,
+   voidpf /*stream UNUSED*/)
+{
+    // can't check for error due to the QIODevice API limitation
+    return 0;
+}
+
+void fill_qiodevice_filefunc (
+  zlib_filefunc_def* pzlib_filefunc_def)
+{
+    pzlib_filefunc_def->zopen_file = qiodevice_open_file_func;
+    pzlib_filefunc_def->zread_file = qiodevice_read_file_func;
+    pzlib_filefunc_def->zwrite_file = qiodevice_write_file_func;
+    pzlib_filefunc_def->ztell_file = qiodevice_tell_file_func;
+    pzlib_filefunc_def->zseek_file = qiodevice_seek_file_func;
+    pzlib_filefunc_def->zclose_file = qiodevice_close_file_func;
+    pzlib_filefunc_def->zerror_file = qiodevice_error_file_func;
+    pzlib_filefunc_def->opaque = new QIODevice_descriptor;
+}
+
+void fill_qiodevice64_filefunc (
+  zlib_filefunc64_def* pzlib_filefunc_def)
+{
+    // Open functions are the same for Qt.
+    pzlib_filefunc_def->zopen64_file = qiodevice_open_file_func;
+    pzlib_filefunc_def->zread_file = qiodevice_read_file_func;
+    pzlib_filefunc_def->zwrite_file = qiodevice_write_file_func;
+    pzlib_filefunc_def->ztell64_file = qiodevice64_tell_file_func;
+    pzlib_filefunc_def->zseek64_file = qiodevice64_seek_file_func;
+    pzlib_filefunc_def->zclose_file = qiodevice_close_file_func;
+    pzlib_filefunc_def->zerror_file = qiodevice_error_file_func;
+    pzlib_filefunc_def->opaque = new QIODevice_descriptor;
+    pzlib_filefunc_def->zfakeclose_file = qiodevice_fakeclose_file_func;
+}
+
+void fill_zlib_filefunc64_32_def_from_filefunc32(zlib_filefunc64_32_def* p_filefunc64_32,const zlib_filefunc_def* p_filefunc32)
+{
+    p_filefunc64_32->zfile_func64.zopen64_file = nullptr;
+    p_filefunc64_32->zopen32_file = p_filefunc32->zopen_file;
+    p_filefunc64_32->zfile_func64.zerror_file = p_filefunc32->zerror_file;
+    p_filefunc64_32->zfile_func64.zread_file = p_filefunc32->zread_file;
+    p_filefunc64_32->zfile_func64.zwrite_file = p_filefunc32->zwrite_file;
+    p_filefunc64_32->zfile_func64.ztell64_file = nullptr;
+    p_filefunc64_32->zfile_func64.zseek64_file = nullptr;
+    p_filefunc64_32->zfile_func64.zclose_file = p_filefunc32->zclose_file;
+    p_filefunc64_32->zfile_func64.zerror_file = p_filefunc32->zerror_file;
+    p_filefunc64_32->zfile_func64.opaque = p_filefunc32->opaque;
+    p_filefunc64_32->zfile_func64.zfakeclose_file = nullptr;
+    p_filefunc64_32->zseek32_file = p_filefunc32->zseek_file;
+    p_filefunc64_32->ztell32_file = p_filefunc32->ztell_file;
+}
diff -ruN ./quaadler32.cpp ../../dep/quazip/quazip/quaadler32.cpp
--- ./quaadler32.cpp	2020-11-27 04:16:54.992498165 +0200
+++ ../../dep/quazip/quazip/quaadler32.cpp	2020-11-27 04:08:04.062517942 +0200
@@ -1,6 +1,31 @@
+/*
+Copyright (C) 2010 Adam Walczak
+Copyright (C) 2005-2014 Sergey A. Tachenov
+
+This file is part of QuaZip.
+
+QuaZip is free software: you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation, either version 2.1 of the License, or
+(at your option) any later version.
+
+QuaZip is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with QuaZip.  If not, see <http://www.gnu.org/licenses/>.
+
+See COPYING file for the full LGPL text.
+
+Original ZIP package is copyrighted by Gilles Vollant and contributors,
+see quazip/(un)zip.h files for details. Basically it's the zlib license.
+*/
+
 #include "quaadler32.h"
 
-#include "zlib.h"
+#include <zlib.h>
 
 QuaAdler32::QuaAdler32()
 {
diff -ruN ./quaadler32.h ../../dep/quazip/quazip/quaadler32.h
--- ./quaadler32.h	2020-11-27 04:16:54.992498165 +0200
+++ ../../dep/quazip/quazip/quaadler32.h	2020-11-27 04:08:04.062517942 +0200
@@ -1,7 +1,32 @@
 #ifndef QUAADLER32_H
 #define QUAADLER32_H
 
-#include <QByteArray>
+/*
+Copyright (C) 2010 Adam Walczak
+Copyright (C) 2005-2014 Sergey A. Tachenov
+
+This file is part of QuaZip.
+
+QuaZip is free software: you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation, either version 2.1 of the License, or
+(at your option) any later version.
+
+QuaZip is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with QuaZip.  If not, see <http://www.gnu.org/licenses/>.
+
+See COPYING file for the full LGPL text.
+
+Original ZIP package is copyrighted by Gilles Vollant and contributors,
+see quazip/(un)zip.h files for details. Basically it's the zlib license.
+*/
+
+#include <QtCore/QByteArray>
 
 #include "quachecksum32.h"
 
diff -ruN ./quachecksum32.h ../../dep/quazip/quazip/quachecksum32.h
--- ./quachecksum32.h	2020-11-27 04:16:54.992498165 +0200
+++ ../../dep/quazip/quazip/quachecksum32.h	2020-11-27 04:08:04.062517942 +0200
@@ -1,7 +1,31 @@
 #ifndef QUACHECKSUM32_H
 #define QUACHECKSUM32_H
 
-#include <QByteArray>
+/*
+Copyright (C) 2005-2014 Sergey A. Tachenov
+
+This file is part of QuaZip.
+
+QuaZip is free software: you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation, either version 2.1 of the License, or
+(at your option) any later version.
+
+QuaZip is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with QuaZip.  If not, see <http://www.gnu.org/licenses/>.
+
+See COPYING file for the full LGPL text.
+
+Original ZIP package is copyrighted by Gilles Vollant and contributors,
+see quazip/(un)zip.h files for details. Basically it's the zlib license.
+*/
+
+#include <QtCore/QByteArray>
 #include "quazip_global.h"
 
 /// Checksum interface.
@@ -29,6 +53,7 @@
 {
 
 public:
+    virtual ~QuaChecksum32();
 	///Calculates the checksum for data.
 	/** \a data source data
 	 * \return data checksum
diff -ruN ./quacrc32.cpp ../../dep/quazip/quazip/quacrc32.cpp
--- ./quacrc32.cpp	2020-11-27 04:16:54.992498165 +0200
+++ ../../dep/quazip/quazip/quacrc32.cpp	2020-11-27 04:08:04.062517942 +0200
@@ -1,6 +1,30 @@
+/*
+Copyright (C) 2005-2014 Sergey A. Tachenov
+
+This file is part of QuaZip.
+
+QuaZip is free software: you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation, either version 2.1 of the License, or
+(at your option) any later version.
+
+QuaZip is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with QuaZip.  If not, see <http://www.gnu.org/licenses/>.
+
+See COPYING file for the full LGPL text.
+
+Original ZIP package is copyrighted by Gilles Vollant and contributors,
+see quazip/(un)zip.h files for details. Basically it's the zlib license.
+*/
+
 #include "quacrc32.h"
 
-#include "zlib.h"
+#include <zlib.h>
 
 QuaCrc32::QuaCrc32()
 {
diff -ruN ./quacrc32.h ../../dep/quazip/quazip/quacrc32.h
--- ./quacrc32.h	2020-11-27 04:16:54.992498165 +0200
+++ ../../dep/quazip/quazip/quacrc32.h	2020-11-27 04:08:04.062517942 +0200
@@ -1,6 +1,30 @@
 #ifndef QUACRC32_H
 #define QUACRC32_H
 
+/*
+Copyright (C) 2005-2014 Sergey A. Tachenov
+
+This file is part of QuaZip.
+
+QuaZip is free software: you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation, either version 2.1 of the License, or
+(at your option) any later version.
+
+QuaZip is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with QuaZip.  If not, see <http://www.gnu.org/licenses/>.
+
+See COPYING file for the full LGPL text.
+
+Original ZIP package is copyrighted by Gilles Vollant and contributors,
+see quazip/(un)zip.h files for details. Basically it's the zlib license.
+*/
+
 #include "quachecksum32.h"
 
 ///CRC32 checksum
diff -ruN ./quazip.cpp ../../dep/quazip/quazip/quazip.cpp
--- ./quazip.cpp	2020-11-27 04:16:54.992498165 +0200
+++ ../../dep/quazip/quazip/quazip.cpp	2020-11-27 04:08:04.062517942 +0200
@@ -1,519 +1,846 @@
-/*
-Copyright (C) 2005-2011 Sergey A. Tachenov
-
-This program is free software; you can redistribute it and/or modify it
-under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation; either version 2 of the License, or (at
-your option) any later version.
-
-This program is distributed in the hope that it will be useful, but
-WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser
-General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this program; if not, write to the Free Software Foundation,
-Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
-
-See COPYING file for the full LGPL text.
-
-Original ZIP package is copyrighted by Gilles Vollant, see
-quazip/(un)zip.h files for details, basically it's zlib license.
- **/
-
-#include <QFile>
-#include <QFlags>
-
-#include "quazip.h"
-
-class QuaZipPrivate {
-  friend class QuaZip;
-  private:
-  QuaZip *q;
-    QTextCodec *fileNameCodec, *commentCodec;
-    QString zipName;
-    QIODevice *ioDevice;
-    QString comment;
-    QuaZip::Mode mode;
-    union {
-      unzFile unzFile_f;
-      zipFile zipFile_f;
-    };
-    bool hasCurrentFile_f;
-    int zipError;
-    bool dataDescriptorWritingEnabled;
-    inline QuaZipPrivate(QuaZip *q):
-        q(q),
-      fileNameCodec(QTextCodec::codecForLocale()),
-      commentCodec(QTextCodec::codecForLocale()),
-      ioDevice(NULL),
-      mode(QuaZip::mdNotOpen),
-      hasCurrentFile_f(false),
-      zipError(UNZ_OK),
-      dataDescriptorWritingEnabled(true) {}
-    inline QuaZipPrivate(QuaZip *q, const QString &zipName):
-        q(q),
-      fileNameCodec(QTextCodec::codecForLocale()),
-      commentCodec(QTextCodec::codecForLocale()),
-      zipName(zipName),
-      ioDevice(NULL),
-      mode(QuaZip::mdNotOpen),
-      hasCurrentFile_f(false),
-      zipError(UNZ_OK),
-      dataDescriptorWritingEnabled(true) {}
-    inline QuaZipPrivate(QuaZip *q, QIODevice *ioDevice):
-        q(q),
-      fileNameCodec(QTextCodec::codecForLocale()),
-      commentCodec(QTextCodec::codecForLocale()),
-      ioDevice(ioDevice),
-      mode(QuaZip::mdNotOpen),
-      hasCurrentFile_f(false),
-      zipError(UNZ_OK),
-      dataDescriptorWritingEnabled(true) {}
-    template<typename TFileInfo>
-        bool getFileInfoList(QList<TFileInfo> *result) const;
-};
-
-QuaZip::QuaZip():
-  p(new QuaZipPrivate(this))
-{
-}
-
-QuaZip::QuaZip(const QString& zipName):
-  p(new QuaZipPrivate(this, zipName))
-{
-}
-
-QuaZip::QuaZip(QIODevice *ioDevice):
-  p(new QuaZipPrivate(this, ioDevice))
-{
-}
-
-QuaZip::~QuaZip()
-{
-  if(isOpen())
-    close();
-  delete p;
-}
-
-bool QuaZip::open(Mode mode, zlib_filefunc_def* ioApi)
-{
-  p->zipError=UNZ_OK;
-  if(isOpen()) {
-    qWarning("QuaZip::open(): ZIP already opened");
-    return false;
-  }
-  QIODevice *ioDevice = p->ioDevice;
-  if (ioDevice == NULL) {
-    if (p->zipName.isEmpty()) {
-      qWarning("QuaZip::open(): set either ZIP file name or IO device first");
-      return false;
-    } else {
-      ioDevice = new QFile(p->zipName);
-    }
-  }
-  switch(mode) {
-    case mdUnzip:
-      p->unzFile_f=unzOpen2(ioDevice, ioApi);
-      if(p->unzFile_f!=NULL) {
-        p->mode=mode;
-        p->ioDevice = ioDevice;
-        return true;
-      } else {
-        p->zipError=UNZ_OPENERROR;
-        if (!p->zipName.isEmpty())
-          delete ioDevice;
-        return false;
-      }
-    case mdCreate:
-    case mdAppend:
-    case mdAdd:
-      p->zipFile_f=zipOpen2(ioDevice,
-          mode==mdCreate?APPEND_STATUS_CREATE:
-          mode==mdAppend?APPEND_STATUS_CREATEAFTER:
-          APPEND_STATUS_ADDINZIP,
-          NULL,
-          ioApi);
-      if(p->zipFile_f!=NULL) {
-        p->mode=mode;
-        p->ioDevice = ioDevice;
-        return true;
-      } else {
-        p->zipError=UNZ_OPENERROR;
-        if (!p->zipName.isEmpty())
-          delete ioDevice;
-        return false;
-      }
-    default:
-      qWarning("QuaZip::open(): unknown mode: %d", (int)mode);
-      if (!p->zipName.isEmpty())
-        delete ioDevice;
-      return false;
-      break;
-  }
-}
-
-void QuaZip::close()
-{
-  p->zipError=UNZ_OK;
-  switch(p->mode) {
-    case mdNotOpen:
-      qWarning("QuaZip::close(): ZIP is not open");
-      return;
-    case mdUnzip:
-      p->zipError=unzClose(p->unzFile_f);
-      break;
-    case mdCreate:
-    case mdAppend:
-    case mdAdd:
-      p->zipError=zipClose(p->zipFile_f, p->commentCodec->fromUnicode(p->comment).constData());
-      break;
-    default:
-      qWarning("QuaZip::close(): unknown mode: %d", (int)p->mode);
-      return;
-  }
-  // opened by name, need to delete the internal IO device
-  if (!p->zipName.isEmpty())
-    delete p->ioDevice;
-  if(p->zipError==UNZ_OK)
-    p->mode=mdNotOpen;
-}
-
-void QuaZip::setZipName(const QString& zipName)
-{
-  if(isOpen()) {
-    qWarning("QuaZip::setZipName(): ZIP is already open!");
-    return;
-  }
-  p->zipName=zipName;
-  p->ioDevice = NULL;
-}
-
-void QuaZip::setIoDevice(QIODevice *ioDevice)
-{
-  if(isOpen()) {
-    qWarning("QuaZip::setIoDevice(): ZIP is already open!");
-    return;
-  }
-  p->ioDevice = ioDevice;
-  p->zipName = QString();
-}
-
-int QuaZip::getEntriesCount()const
-{
-  QuaZip *fakeThis=(QuaZip*)this; // non-const
-  fakeThis->p->zipError=UNZ_OK;
-  if(p->mode!=mdUnzip) {
-    qWarning("QuaZip::getEntriesCount(): ZIP is not open in mdUnzip mode");
-    return -1;
-  }
-  unz_global_info globalInfo;
-  if((fakeThis->p->zipError=unzGetGlobalInfo(p->unzFile_f, &globalInfo))!=UNZ_OK)
-    return p->zipError;
-  return (int)globalInfo.number_entry;
-}
-
-QString QuaZip::getComment()const
-{
-  QuaZip *fakeThis=(QuaZip*)this; // non-const
-  fakeThis->p->zipError=UNZ_OK;
-  if(p->mode!=mdUnzip) {
-    qWarning("QuaZip::getComment(): ZIP is not open in mdUnzip mode");
-    return QString();
-  }
-  unz_global_info globalInfo;
-  QByteArray comment;
-  if((fakeThis->p->zipError=unzGetGlobalInfo(p->unzFile_f, &globalInfo))!=UNZ_OK)
-    return QString();
-  comment.resize(globalInfo.size_comment);
-  if((fakeThis->p->zipError=unzGetGlobalComment(p->unzFile_f, comment.data(), comment.size())) < 0)
-    return QString();
-  fakeThis->p->zipError = UNZ_OK;
-  return p->commentCodec->toUnicode(comment);
-}
-
-bool QuaZip::setCurrentFile(const QString& fileName, CaseSensitivity cs)
-{
-  p->zipError=UNZ_OK;
-  if(p->mode!=mdUnzip) {
-    qWarning("QuaZip::setCurrentFile(): ZIP is not open in mdUnzip mode");
-    return false;
-  }
-  if(fileName.isEmpty()) {
-    p->hasCurrentFile_f=false;
-    return true;
-  }
-  // Unicode-aware reimplementation of the unzLocateFile function
-  if(p->unzFile_f==NULL) {
-    p->zipError=UNZ_PARAMERROR;
-    return false;
-  }
-  if(fileName.length()>MAX_FILE_NAME_LENGTH) {
-    p->zipError=UNZ_PARAMERROR;
-    return false;
-  }
-  bool sens;
-  if(cs==csDefault) {
-#ifdef Q_WS_WIN
-    sens=false;
-#else
-    sens=true;
-#endif
-  } else sens=cs==csSensitive;
-  QString lower, current;
-  if(!sens) lower=fileName.toLower();
-  p->hasCurrentFile_f=false;
-  for(bool more=goToFirstFile(); more; more=goToNextFile()) {
-    current=getCurrentFileName();
-    if(current.isEmpty()) return false;
-    if(sens) {
-      if(current==fileName) break;
-    } else {
-      if(current.toLower()==lower) break;
-    }
-  }
-  return p->hasCurrentFile_f;
-}
-
-bool QuaZip::goToFirstFile()
-{
-  p->zipError=UNZ_OK;
-  if(p->mode!=mdUnzip) {
-    qWarning("QuaZip::goToFirstFile(): ZIP is not open in mdUnzip mode");
-    return false;
-  }
-  p->zipError=unzGoToFirstFile(p->unzFile_f);
-  p->hasCurrentFile_f=p->zipError==UNZ_OK;
-  return p->hasCurrentFile_f;
-}
-
-bool QuaZip::goToNextFile()
-{
-  p->zipError=UNZ_OK;
-  if(p->mode!=mdUnzip) {
-    qWarning("QuaZip::goToFirstFile(): ZIP is not open in mdUnzip mode");
-    return false;
-  }
-  p->zipError=unzGoToNextFile(p->unzFile_f);
-  p->hasCurrentFile_f=p->zipError==UNZ_OK;
-  if(p->zipError==UNZ_END_OF_LIST_OF_FILE)
-    p->zipError=UNZ_OK;
-  return p->hasCurrentFile_f;
-}
-
-bool QuaZip::getCurrentFileInfo(QuaZipFileInfo *info)const
-{
-  QuaZip *fakeThis=(QuaZip*)this; // non-const
-  fakeThis->p->zipError=UNZ_OK;
-  if(p->mode!=mdUnzip) {
-    qWarning("QuaZip::getCurrentFileInfo(): ZIP is not open in mdUnzip mode");
-    return false;
-  }
-  unz_file_info info_z;
-  QByteArray fileName;
-  QByteArray extra;
-  QByteArray comment;
-  if(info==NULL) return false;
-  if(!isOpen()||!hasCurrentFile()) return false;
-  if((fakeThis->p->zipError=unzGetCurrentFileInfo(p->unzFile_f, &info_z, NULL, 0, NULL, 0, NULL, 0))!=UNZ_OK)
-    return false;
-  fileName.resize(info_z.size_filename);
-  extra.resize(info_z.size_file_extra);
-  comment.resize(info_z.size_file_comment);
-  if((fakeThis->p->zipError=unzGetCurrentFileInfo(p->unzFile_f, NULL,
-      fileName.data(), fileName.size(),
-      extra.data(), extra.size(),
-      comment.data(), comment.size()))!=UNZ_OK)
-    return false;
-  info->versionCreated=info_z.version;
-  info->versionNeeded=info_z.version_needed;
-  info->flags=info_z.flag;
-  info->method=info_z.compression_method;
-  info->crc=info_z.crc;
-  info->compressedSize=info_z.compressed_size;
-  info->uncompressedSize=info_z.uncompressed_size;
-  info->diskNumberStart=info_z.disk_num_start;
-  info->internalAttr=info_z.internal_fa;
-  info->externalAttr=info_z.external_fa;
-  info->name=p->fileNameCodec->toUnicode(fileName);
-  info->comment=p->commentCodec->toUnicode(comment);
-  info->extra=extra;
-  info->dateTime=QDateTime(
-      QDate(info_z.tmu_date.tm_year, info_z.tmu_date.tm_mon+1, info_z.tmu_date.tm_mday),
-      QTime(info_z.tmu_date.tm_hour, info_z.tmu_date.tm_min, info_z.tmu_date.tm_sec));
-  return true;
-}
-
-QString QuaZip::getCurrentFileName()const
-{
-  QuaZip *fakeThis=(QuaZip*)this; // non-const
-  fakeThis->p->zipError=UNZ_OK;
-  if(p->mode!=mdUnzip) {
-    qWarning("QuaZip::getCurrentFileName(): ZIP is not open in mdUnzip mode");
-    return QString();
-  }
-  if(!isOpen()||!hasCurrentFile()) return QString();
-  QByteArray fileName(MAX_FILE_NAME_LENGTH, 0);
-  if((fakeThis->p->zipError=unzGetCurrentFileInfo(p->unzFile_f, NULL, fileName.data(), fileName.size(),
-      NULL, 0, NULL, 0))!=UNZ_OK)
-    return QString();
-  return p->fileNameCodec->toUnicode(fileName.constData());
-}
-
-void QuaZip::setFileNameCodec(QTextCodec *fileNameCodec)
-{
-  p->fileNameCodec=fileNameCodec;
-}
-
-void QuaZip::setFileNameCodec(const char *fileNameCodecName)
-{
-  p->fileNameCodec=QTextCodec::codecForName(fileNameCodecName);
-}
-
-QTextCodec *QuaZip::getFileNameCodec()const
-{
-  return p->fileNameCodec;
-}
-
-void QuaZip::setCommentCodec(QTextCodec *commentCodec)
-{
-  p->commentCodec=commentCodec;
-}
-
-void QuaZip::setCommentCodec(const char *commentCodecName)
-{
-  p->commentCodec=QTextCodec::codecForName(commentCodecName);
-}
-
-QTextCodec *QuaZip::getCommentCodec()const
-{
-  return p->commentCodec;
-}
-
-QString QuaZip::getZipName() const
-{
-  return p->zipName;
-}
-
-QIODevice *QuaZip::getIoDevice() const
-{
-  if (!p->zipName.isEmpty()) // opened by name, using an internal QIODevice
-    return NULL;
-  return p->ioDevice;
-}
-
-QuaZip::Mode QuaZip::getMode()const
-{
-  return p->mode;
-}
-
-bool QuaZip::isOpen()const
-{
-  return p->mode!=mdNotOpen;
-}
-
-int QuaZip::getZipError() const
-{
-  return p->zipError;
-}
-
-void QuaZip::setComment(const QString& comment)
-{
-  p->comment=comment;
-}
-
-bool QuaZip::hasCurrentFile()const
-{
-  return p->hasCurrentFile_f;
-}
-
-unzFile QuaZip::getUnzFile()
-{
-  return p->unzFile_f;
-}
-
-zipFile QuaZip::getZipFile()
-{
-  return p->zipFile_f;
-}
-
-void QuaZip::setDataDescriptorWritingEnabled(bool enabled)
-{
-    p->dataDescriptorWritingEnabled = enabled;
-}
-
-bool QuaZip::isDataDescriptorWritingEnabled() const
-{
-    return p->dataDescriptorWritingEnabled;
-}
-
-template<typename TFileInfo>
-static TFileInfo getFileInfo(QuaZip *zip, bool *ok);
-
-template<>
-QuaZipFileInfo getFileInfo(QuaZip *zip, bool *ok)
-{
-    QuaZipFileInfo info;
-    *ok = zip->getCurrentFileInfo(&info);
-    return info;
-}
-
-template<>
-QString getFileInfo(QuaZip *zip, bool *ok)
-{
-    QString name = zip->getCurrentFileName();
-    *ok = !name.isEmpty();
-    return name;
-}
-
-template<typename TFileInfo>
-bool QuaZipPrivate::getFileInfoList(QList<TFileInfo> *result) const
-{
-  QuaZipPrivate *fakeThis=const_cast<QuaZipPrivate*>(this);
-  fakeThis->zipError=UNZ_OK;
-  if (mode!=QuaZip::mdUnzip) {
-    qWarning("QuaZip::getFileNameList/getFileInfoList(): "
-            "ZIP is not open in mdUnzip mode");
-    return false;
-  }
-  QString currentFile;
-  if (q->hasCurrentFile()) {
-      currentFile = q->getCurrentFileName();
-  }
-  if (q->goToFirstFile()) {
-      do {
-          bool ok;
-          result->append(getFileInfo<TFileInfo>(q, &ok));
-          if (!ok)
-              return false;
-      } while (q->goToNextFile());
-  }
-  if (zipError != UNZ_OK)
-      return false;
-  if (currentFile.isEmpty()) {
-      if (!q->setCurrentFile(currentFile))
-          return false;
-  } else {
-      if (!q->goToFirstFile())
-          return false;
-  }
-  return true;
-}
-
-QStringList QuaZip::getFileNameList() const
-{
-    QStringList list;
-    if (p->getFileInfoList(&list))
-        return list;
-    else
-        return QStringList();
-}
-
-QList<QuaZipFileInfo> QuaZip::getFileInfoList() const
-{
-    QList<QuaZipFileInfo> list;
-    if (p->getFileInfoList(&list))
-        return list;
-    else
-        return QList<QuaZipFileInfo>();
-}
+/*
+Copyright (C) 2005-2014 Sergey A. Tachenov
+
+This file is part of QuaZip.
+
+QuaZip is free software: you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation, either version 2.1 of the License, or
+(at your option) any later version.
+
+QuaZip is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with QuaZip.  If not, see <http://www.gnu.org/licenses/>.
+
+See COPYING file for the full LGPL text.
+
+Original ZIP package is copyrighted by Gilles Vollant, see
+quazip/(un)zip.h files for details, basically it's zlib license.
+ **/
+
+#include <QtCore/QFile>
+#include <QtCore/QFlags>
+#include <QtCore/QHash>
+
+#include "quazip.h"
+
+#define QUAZIP_OS_UNIX 3u
+
+/// All the internal stuff for the QuaZip class.
+/**
+  \internal
+
+  This class keeps all the private stuff for the QuaZip class so it can
+  be changed without breaking binary compatibility, according to the
+  Pimpl idiom.
+  */
+class QuaZipPrivate {
+  friend class QuaZip;
+  private:
+    Q_DISABLE_COPY(QuaZipPrivate)
+    /// The pointer to the corresponding QuaZip instance.
+    QuaZip *q;
+    /// The codec for file names (used when UTF-8 is not enabled).
+    QTextCodec *fileNameCodec;
+    /// The codec for comments (used when UTF-8 is not enabled).
+    QTextCodec *commentCodec;
+    /// The archive file name.
+    QString zipName;
+    /// The device to access the archive.
+    QIODevice *ioDevice;
+    /// The global comment.
+    QString comment;
+    /// The open mode.
+    QuaZip::Mode mode;
+    union {
+      /// The internal handle for UNZIP modes.
+      unzFile unzFile_f;
+      /// The internal handle for ZIP modes.
+      zipFile zipFile_f;
+    };
+    /// Whether a current file is set.
+    bool hasCurrentFile_f;
+    /// The last error.
+    int zipError;
+    /// Whether \ref QuaZip::setDataDescriptorWritingEnabled() "the data descriptor writing mode" is enabled.
+    bool dataDescriptorWritingEnabled;
+    /// The zip64 mode.
+    bool zip64;
+    /// The auto-close flag.
+    bool autoClose;
+    /// The UTF-8 flag.
+    bool utf8;
+    /// The OS code.
+    uint osCode;
+    inline QTextCodec *getDefaultFileNameCodec()
+    {
+        if (defaultFileNameCodec == nullptr) {
+            return QTextCodec::codecForLocale();
+        } else {
+            return defaultFileNameCodec;
+        }
+    }
+    /// The constructor for the corresponding QuaZip constructor.
+    inline QuaZipPrivate(QuaZip *q):
+      q(q),
+      fileNameCodec(getDefaultFileNameCodec()),
+      commentCodec(QTextCodec::codecForLocale()),
+      ioDevice(nullptr),
+      mode(QuaZip::mdNotOpen),
+      hasCurrentFile_f(false),
+      zipError(UNZ_OK),
+      dataDescriptorWritingEnabled(true),
+      zip64(false),
+      autoClose(true),
+      utf8(false),
+      osCode(defaultOsCode)
+    {
+        unzFile_f = nullptr;
+        zipFile_f = nullptr;
+        lastMappedDirectoryEntry.num_of_file = 0;
+        lastMappedDirectoryEntry.pos_in_zip_directory = 0;
+    }
+    /// The constructor for the corresponding QuaZip constructor.
+    inline QuaZipPrivate(QuaZip *q, const QString &zipName):
+      q(q),
+      fileNameCodec(getDefaultFileNameCodec()),
+      commentCodec(QTextCodec::codecForLocale()),
+      zipName(zipName),
+      ioDevice(nullptr),
+      mode(QuaZip::mdNotOpen),
+      hasCurrentFile_f(false),
+      zipError(UNZ_OK),
+      dataDescriptorWritingEnabled(true),
+      zip64(false),
+      autoClose(true),
+      utf8(false),
+      osCode(defaultOsCode)
+    {
+        unzFile_f = nullptr;
+        zipFile_f = nullptr;
+        lastMappedDirectoryEntry.num_of_file = 0;
+        lastMappedDirectoryEntry.pos_in_zip_directory = 0;
+    }
+    /// The constructor for the corresponding QuaZip constructor.
+    inline QuaZipPrivate(QuaZip *q, QIODevice *ioDevice):
+      q(q),
+      fileNameCodec(getDefaultFileNameCodec()),
+      commentCodec(QTextCodec::codecForLocale()),
+      ioDevice(ioDevice),
+      mode(QuaZip::mdNotOpen),
+      hasCurrentFile_f(false),
+      zipError(UNZ_OK),
+      dataDescriptorWritingEnabled(true),
+      zip64(false),
+      autoClose(true),
+      utf8(false),
+      osCode(defaultOsCode)
+    {
+        unzFile_f = nullptr;
+        zipFile_f = nullptr;
+        lastMappedDirectoryEntry.num_of_file = 0;
+        lastMappedDirectoryEntry.pos_in_zip_directory = 0;
+    }
+    /// Returns either a list of file names or a list of QuaZipFileInfo.
+    template<typename TFileInfo>
+        bool getFileInfoList(QList<TFileInfo> *result) const;
+
+    /// Stores map of filenames and file locations for unzipping
+      inline void clearDirectoryMap();
+      inline void addCurrentFileToDirectoryMap(const QString &fileName);
+      bool goToFirstUnmappedFile();
+      QHash<QString, unz64_file_pos> directoryCaseSensitive;
+      QHash<QString, unz64_file_pos> directoryCaseInsensitive;
+      unz64_file_pos lastMappedDirectoryEntry;
+      static QTextCodec *defaultFileNameCodec;
+      static uint defaultOsCode;
+};
+
+QTextCodec *QuaZipPrivate::defaultFileNameCodec = nullptr;
+uint QuaZipPrivate::defaultOsCode = QUAZIP_OS_UNIX;
+
+void QuaZipPrivate::clearDirectoryMap()
+{
+    directoryCaseInsensitive.clear();
+    directoryCaseSensitive.clear();
+    lastMappedDirectoryEntry.num_of_file = 0;
+    lastMappedDirectoryEntry.pos_in_zip_directory = 0;
+}
+
+void QuaZipPrivate::addCurrentFileToDirectoryMap(const QString &fileName)
+{
+    if (!hasCurrentFile_f || fileName.isEmpty()) {
+        return;
+    }
+    // Adds current file to filename map as fileName
+    unz64_file_pos fileDirectoryPos;
+    unzGetFilePos64(unzFile_f, &fileDirectoryPos);
+    directoryCaseSensitive.insert(fileName, fileDirectoryPos);
+    // Only add lowercase to directory map if not already there
+    // ensures only map the first one seen
+    QString lower = fileName.toLower();
+    if (!directoryCaseInsensitive.contains(lower))
+        directoryCaseInsensitive.insert(lower, fileDirectoryPos);
+    // Mark last one
+    if (fileDirectoryPos.pos_in_zip_directory > lastMappedDirectoryEntry.pos_in_zip_directory)
+        lastMappedDirectoryEntry = fileDirectoryPos;
+}
+
+bool QuaZipPrivate::goToFirstUnmappedFile()
+{
+    zipError = UNZ_OK;
+    if (mode != QuaZip::mdUnzip) {
+        qWarning("QuaZipPrivate::goToNextUnmappedFile(): ZIP is not open in mdUnzip mode");
+        return false;
+    }
+    // If not mapped anything, go to beginning
+    if (lastMappedDirectoryEntry.pos_in_zip_directory == 0) {
+        unzGoToFirstFile(unzFile_f);
+    } else {
+        // Goto the last one mapped, plus one
+        unzGoToFilePos64(unzFile_f, &lastMappedDirectoryEntry);
+        unzGoToNextFile(unzFile_f);
+    }
+    hasCurrentFile_f=zipError==UNZ_OK;
+    if(zipError==UNZ_END_OF_LIST_OF_FILE)
+      zipError=UNZ_OK;
+    return hasCurrentFile_f;
+}
+
+QuaZip::QuaZip():
+  p(new QuaZipPrivate(this))
+{
+}
+
+QuaZip::QuaZip(const QString& zipName):
+  p(new QuaZipPrivate(this, zipName))
+{
+}
+
+QuaZip::QuaZip(QIODevice *ioDevice):
+  p(new QuaZipPrivate(this, ioDevice))
+{
+}
+
+QuaZip::~QuaZip()
+{
+  if(isOpen())
+    close();
+  delete p;
+}
+
+bool QuaZip::open(Mode mode, zlib_filefunc_def* ioApi)
+{
+  p->zipError=UNZ_OK;
+  if(isOpen()) {
+    qWarning("QuaZip::open(): ZIP already opened");
+    return false;
+  }
+  QIODevice *ioDevice = p->ioDevice;
+  if (ioDevice == nullptr) {
+    if (p->zipName.isEmpty()) {
+      qWarning("QuaZip::open(): set either ZIP file name or IO device first");
+      return false;
+    } else {
+      ioDevice = new QFile(p->zipName);
+    }
+  }
+  unsigned flags = 0;
+  switch(mode) {
+    case mdUnzip:
+      if (ioApi == nullptr) {
+          if (p->autoClose)
+              flags |= UNZ_AUTO_CLOSE;
+          p->unzFile_f=unzOpenInternal(ioDevice, nullptr, 1, flags);
+      } else {
+          // QuaZip pre-zip64 compatibility mode
+          p->unzFile_f=unzOpen2(ioDevice, ioApi);
+          if (p->unzFile_f != nullptr) {
+              if (p->autoClose) {
+                  unzSetFlags(p->unzFile_f, UNZ_AUTO_CLOSE);
+              } else {
+                  unzClearFlags(p->unzFile_f, UNZ_AUTO_CLOSE);
+              }
+          }
+      }
+      if(p->unzFile_f!=nullptr) {
+        if (ioDevice->isSequential()) {
+            unzClose(p->unzFile_f);
+            if (!p->zipName.isEmpty())
+                delete ioDevice;
+            qWarning("QuaZip::open(): "
+                     "only mdCreate can be used with "
+                     "sequential devices");
+            return false;
+        }
+        p->mode=mode;
+        p->ioDevice = ioDevice;
+        return true;
+      } else {
+        p->zipError=UNZ_OPENERROR;
+        if (!p->zipName.isEmpty())
+          delete ioDevice;
+        return false;
+      }
+    case mdCreate:
+    case mdAppend:
+    case mdAdd:
+      if (ioApi == nullptr) {
+          if (p->autoClose)
+              flags |= ZIP_AUTO_CLOSE;
+          if (p->dataDescriptorWritingEnabled)
+              flags |= ZIP_WRITE_DATA_DESCRIPTOR;
+          if (p->utf8)
+              flags |= ZIP_ENCODING_UTF8;
+          p->zipFile_f=zipOpen3(ioDevice,
+              mode==mdCreate?APPEND_STATUS_CREATE:
+              mode==mdAppend?APPEND_STATUS_CREATEAFTER:
+              APPEND_STATUS_ADDINZIP,
+              nullptr, nullptr, flags);
+      } else {
+          // QuaZip pre-zip64 compatibility mode
+          p->zipFile_f=zipOpen2(ioDevice,
+              mode==mdCreate?APPEND_STATUS_CREATE:
+              mode==mdAppend?APPEND_STATUS_CREATEAFTER:
+              APPEND_STATUS_ADDINZIP,
+              nullptr,
+              ioApi);
+          if (p->zipFile_f != nullptr) {
+              zipSetFlags(p->zipFile_f, flags);
+          }
+      }
+      if(p->zipFile_f!=nullptr) {
+        if (ioDevice->isSequential()) {
+            if (mode != mdCreate) {
+                zipClose(p->zipFile_f, nullptr);
+                qWarning("QuaZip::open(): "
+                        "only mdCreate can be used with "
+                         "sequential devices");
+                if (!p->zipName.isEmpty())
+                    delete ioDevice;
+                return false;
+            }
+            zipSetFlags(p->zipFile_f, ZIP_SEQUENTIAL);
+        }
+        p->mode=mode;
+        p->ioDevice = ioDevice;
+        return true;
+      } else {
+        p->zipError=UNZ_OPENERROR;
+        if (!p->zipName.isEmpty())
+          delete ioDevice;
+        return false;
+      }
+    default:
+      qWarning("QuaZip::open(): unknown mode: %d", (int)mode);
+      if (!p->zipName.isEmpty())
+        delete ioDevice;
+      return false;
+      break;
+  }
+}
+
+void QuaZip::close()
+{
+  p->zipError=UNZ_OK;
+  switch(p->mode) {
+    case mdNotOpen:
+      qWarning("QuaZip::close(): ZIP is not open");
+      return;
+    case mdUnzip:
+      p->zipError=unzClose(p->unzFile_f);
+      break;
+    case mdCreate:
+    case mdAppend:
+    case mdAdd:
+      p->zipError=zipClose(p->zipFile_f, p->comment.isNull() ? nullptr : isUtf8Enabled()
+        ? p->comment.toUtf8().constData()
+        : p->commentCodec->fromUnicode(p->comment).constData());
+      break;
+    default:
+      qWarning("QuaZip::close(): unknown mode: %d", (int)p->mode);
+      return;
+  }
+  // opened by name, need to delete the internal IO device
+  if (!p->zipName.isEmpty()) {
+      delete p->ioDevice;
+      p->ioDevice = nullptr;
+  }
+  p->clearDirectoryMap();
+  if(p->zipError==UNZ_OK)
+    p->mode=mdNotOpen;
+}
+
+void QuaZip::setZipName(const QString& zipName)
+{
+  if(isOpen()) {
+    qWarning("QuaZip::setZipName(): ZIP is already open!");
+    return;
+  }
+  p->zipName=zipName;
+  p->ioDevice = nullptr;
+}
+
+void QuaZip::setIoDevice(QIODevice *ioDevice)
+{
+  if(isOpen()) {
+    qWarning("QuaZip::setIoDevice(): ZIP is already open!");
+    return;
+  }
+  p->ioDevice = ioDevice;
+  p->zipName = QString();
+}
+
+int QuaZip::getEntriesCount()const
+{
+  QuaZip *fakeThis=(QuaZip*)this; // non-const
+  fakeThis->p->zipError=UNZ_OK;
+  if(p->mode!=mdUnzip) {
+    qWarning("QuaZip::getEntriesCount(): ZIP is not open in mdUnzip mode");
+    return -1;
+  }
+  unz_global_info64 globalInfo;
+  if((fakeThis->p->zipError=unzGetGlobalInfo64(p->unzFile_f, &globalInfo))!=UNZ_OK)
+    return p->zipError;
+  return (int)globalInfo.number_entry;
+}
+
+QString QuaZip::getComment()const
+{
+  QuaZip *fakeThis=(QuaZip*)this; // non-const
+  fakeThis->p->zipError=UNZ_OK;
+  if(p->mode!=mdUnzip) {
+    qWarning("QuaZip::getComment(): ZIP is not open in mdUnzip mode");
+    return QString();
+  }
+  unz_global_info64 globalInfo;
+  QByteArray comment;
+  if((fakeThis->p->zipError=unzGetGlobalInfo64(p->unzFile_f, &globalInfo))!=UNZ_OK)
+    return QString();
+  comment.resize(globalInfo.size_comment);
+  if((fakeThis->p->zipError=unzGetGlobalComment(p->unzFile_f, comment.data(), comment.size())) < 0)
+    return QString();
+  fakeThis->p->zipError = UNZ_OK;
+  unsigned flags = 0;
+  return (unzGetFileFlags(p->unzFile_f, &flags) == UNZ_OK) && (flags & UNZ_ENCODING_UTF8)
+    ? QString::fromUtf8(comment) : p->commentCodec->toUnicode(comment);
+}
+
+bool QuaZip::setCurrentFile(const QString& fileName, CaseSensitivity cs)
+{
+  p->zipError=UNZ_OK;
+  if(p->mode!=mdUnzip) {
+    qWarning("QuaZip::setCurrentFile(): ZIP is not open in mdUnzip mode");
+    return false;
+  }
+  if(fileName.isEmpty()) {
+    p->hasCurrentFile_f=false;
+    return true;
+  }
+  // Unicode-aware reimplementation of the unzLocateFile function
+  if(p->unzFile_f==nullptr) {
+    p->zipError=UNZ_PARAMERROR;
+    return false;
+  }
+  if(fileName.length()>MAX_FILE_NAME_LENGTH) {
+    p->zipError=UNZ_PARAMERROR;
+    return false;
+  }
+  // Find the file by name
+  bool sens = convertCaseSensitivity(cs) == Qt::CaseSensitive;
+  QString lower, current;
+  if(!sens) lower=fileName.toLower();
+  p->hasCurrentFile_f=false;
+
+  // Check the appropriate Map
+  unz64_file_pos fileDirPos;
+  fileDirPos.pos_in_zip_directory = 0;
+  if (sens) {
+      if (p->directoryCaseSensitive.contains(fileName))
+          fileDirPos = p->directoryCaseSensitive.value(fileName);
+  } else {
+      if (p->directoryCaseInsensitive.contains(lower))
+          fileDirPos = p->directoryCaseInsensitive.value(lower);
+  }
+
+  if (fileDirPos.pos_in_zip_directory != 0) {
+      p->zipError = unzGoToFilePos64(p->unzFile_f, &fileDirPos);
+      p->hasCurrentFile_f = p->zipError == UNZ_OK;
+  }
+
+  if (p->hasCurrentFile_f)
+      return p->hasCurrentFile_f;
+
+  // Not mapped yet, start from where we have got to so far
+  for(bool more=p->goToFirstUnmappedFile(); more; more=goToNextFile()) {
+    current=getCurrentFileName();
+    if(current.isEmpty()) return false;
+    if(sens) {
+      if(current==fileName) break;
+    } else {
+      if(current.toLower()==lower) break;
+    }
+  }
+  return p->hasCurrentFile_f;
+}
+
+bool QuaZip::goToFirstFile()
+{
+  p->zipError=UNZ_OK;
+  if(p->mode!=mdUnzip) {
+    qWarning("QuaZip::goToFirstFile(): ZIP is not open in mdUnzip mode");
+    return false;
+  }
+  p->zipError=unzGoToFirstFile(p->unzFile_f);
+  p->hasCurrentFile_f=p->zipError==UNZ_OK;
+  return p->hasCurrentFile_f;
+}
+
+bool QuaZip::goToNextFile()
+{
+  p->zipError=UNZ_OK;
+  if(p->mode!=mdUnzip) {
+    qWarning("QuaZip::goToFirstFile(): ZIP is not open in mdUnzip mode");
+    return false;
+  }
+  p->zipError=unzGoToNextFile(p->unzFile_f);
+  p->hasCurrentFile_f=p->zipError==UNZ_OK;
+  if(p->zipError==UNZ_END_OF_LIST_OF_FILE)
+    p->zipError=UNZ_OK;
+  return p->hasCurrentFile_f;
+}
+
+bool QuaZip::getCurrentFileInfo(QuaZipFileInfo *info)const
+{
+    QuaZipFileInfo64 info64;
+    if (info == nullptr) { // Very unlikely because of the overloads
+        return false;
+    }
+    if (getCurrentFileInfo(&info64)) {
+        info64.toQuaZipFileInfo(*info);
+        return true;
+    } else {
+        return false;
+    }
+}
+
+bool QuaZip::getCurrentFileInfo(QuaZipFileInfo64 *info)const
+{
+  QuaZip *fakeThis=(QuaZip*)this; // non-const
+  fakeThis->p->zipError=UNZ_OK;
+  if(p->mode!=mdUnzip) {
+    qWarning("QuaZip::getCurrentFileInfo(): ZIP is not open in mdUnzip mode");
+    return false;
+  }
+  unz_file_info64 info_z;
+  QByteArray fileName;
+  QByteArray extra;
+  QByteArray comment;
+  if(info==nullptr) return false;
+  if(!isOpen()||!hasCurrentFile()) return false;
+  if((fakeThis->p->zipError=unzGetCurrentFileInfo64(p->unzFile_f, &info_z, nullptr, 0, nullptr, 0, nullptr, 0))!=UNZ_OK)
+    return false;
+  fileName.resize(info_z.size_filename);
+  extra.resize(info_z.size_file_extra);
+  comment.resize(info_z.size_file_comment);
+  if((fakeThis->p->zipError=unzGetCurrentFileInfo64(p->unzFile_f, nullptr,
+      fileName.data(), fileName.size(),
+      extra.data(), extra.size(),
+      comment.data(), comment.size()))!=UNZ_OK)
+    return false;
+  info->versionCreated=info_z.version;
+  info->versionNeeded=info_z.version_needed;
+  info->flags=info_z.flag;
+  info->method=info_z.compression_method;
+  info->crc=info_z.crc;
+  info->compressedSize=info_z.compressed_size;
+  info->uncompressedSize=info_z.uncompressed_size;
+  info->diskNumberStart=info_z.disk_num_start;
+  info->internalAttr=info_z.internal_fa;
+  info->externalAttr=info_z.external_fa;
+  info->name=(info->flags & UNZ_ENCODING_UTF8) ? QString::fromUtf8(fileName) : p->fileNameCodec->toUnicode(fileName);
+  info->comment=(info->flags & UNZ_ENCODING_UTF8) ? QString::fromUtf8(comment) : p->commentCodec->toUnicode(comment);
+  info->extra=extra;
+  info->dateTime=QDateTime(
+      QDate(info_z.tmu_date.tm_year, info_z.tmu_date.tm_mon+1, info_z.tmu_date.tm_mday),
+      QTime(info_z.tmu_date.tm_hour, info_z.tmu_date.tm_min, info_z.tmu_date.tm_sec));
+  // Add to directory map
+  p->addCurrentFileToDirectoryMap(info->name);
+  return true;
+}
+
+QString QuaZip::getCurrentFileName()const
+{
+  QuaZip *fakeThis=(QuaZip*)this; // non-const
+  fakeThis->p->zipError=UNZ_OK;
+  if(p->mode!=mdUnzip) {
+    qWarning("QuaZip::getCurrentFileName(): ZIP is not open in mdUnzip mode");
+    return QString();
+  }
+  if(!isOpen()||!hasCurrentFile()) return QString();
+  QByteArray fileName(MAX_FILE_NAME_LENGTH, 0);
+  unz_file_info64 file_info;
+  if((fakeThis->p->zipError=unzGetCurrentFileInfo64(p->unzFile_f, &file_info, fileName.data(), fileName.size(),
+      nullptr, 0, nullptr, 0))!=UNZ_OK)
+    return QString();
+  fileName.resize(file_info.size_filename);
+  QString result = (file_info.flag & UNZ_ENCODING_UTF8)
+    ? QString::fromUtf8(fileName) : p->fileNameCodec->toUnicode(fileName);
+  if (result.isEmpty())
+      return result;
+  // Add to directory map
+  p->addCurrentFileToDirectoryMap(result);
+  return result;
+}
+
+void QuaZip::setFileNameCodec(QTextCodec *fileNameCodec)
+{
+  p->fileNameCodec=fileNameCodec;
+}
+
+void QuaZip::setFileNameCodec(const char *fileNameCodecName)
+{
+    p->fileNameCodec=QTextCodec::codecForName(fileNameCodecName);
+}
+
+void QuaZip::setOsCode(uint osCode)
+{
+    p->osCode = osCode;
+}
+
+uint QuaZip::getOsCode() const
+{
+    return p->osCode;
+}
+
+QTextCodec *QuaZip::getFileNameCodec()const
+{
+  return p->fileNameCodec;
+}
+
+void QuaZip::setCommentCodec(QTextCodec *commentCodec)
+{
+  p->commentCodec=commentCodec;
+}
+
+void QuaZip::setCommentCodec(const char *commentCodecName)
+{
+  p->commentCodec=QTextCodec::codecForName(commentCodecName);
+}
+
+QTextCodec *QuaZip::getCommentCodec()const
+{
+  return p->commentCodec;
+}
+
+QString QuaZip::getZipName() const
+{
+  return p->zipName;
+}
+
+QIODevice *QuaZip::getIoDevice() const
+{
+  if (!p->zipName.isEmpty()) // opened by name, using an internal QIODevice
+    return nullptr;
+  return p->ioDevice;
+}
+
+QuaZip::Mode QuaZip::getMode()const
+{
+  return p->mode;
+}
+
+bool QuaZip::isOpen()const
+{
+  return p->mode!=mdNotOpen;
+}
+
+int QuaZip::getZipError() const
+{
+  return p->zipError;
+}
+
+void QuaZip::setComment(const QString& comment)
+{
+  p->comment=comment;
+}
+
+bool QuaZip::hasCurrentFile()const
+{
+  return p->hasCurrentFile_f;
+}
+
+unzFile QuaZip::getUnzFile()
+{
+  return p->unzFile_f;
+}
+
+zipFile QuaZip::getZipFile()
+{
+  return p->zipFile_f;
+}
+
+void QuaZip::setDataDescriptorWritingEnabled(bool enabled)
+{
+    p->dataDescriptorWritingEnabled = enabled;
+}
+
+bool QuaZip::isDataDescriptorWritingEnabled() const
+{
+    return p->dataDescriptorWritingEnabled;
+}
+
+template<typename TFileInfo>
+TFileInfo QuaZip_getFileInfo(QuaZip *zip, bool *ok);
+
+template<>
+QuaZipFileInfo QuaZip_getFileInfo(QuaZip *zip, bool *ok)
+{
+    QuaZipFileInfo info;
+    *ok = zip->getCurrentFileInfo(&info);
+    return info;
+}
+
+template<>
+QuaZipFileInfo64 QuaZip_getFileInfo(QuaZip *zip, bool *ok)
+{
+    QuaZipFileInfo64 info;
+    *ok = zip->getCurrentFileInfo(&info);
+    return info;
+}
+
+template<>
+QString QuaZip_getFileInfo(QuaZip *zip, bool *ok)
+{
+    QString name = zip->getCurrentFileName();
+    *ok = !name.isEmpty();
+    return name;
+}
+
+template<typename TFileInfo>
+bool QuaZipPrivate::getFileInfoList(QList<TFileInfo> *result) const
+{
+  QuaZipPrivate *fakeThis=const_cast<QuaZipPrivate*>(this);
+  fakeThis->zipError=UNZ_OK;
+  if (mode!=QuaZip::mdUnzip) {
+    qWarning("QuaZip::getFileNameList/getFileInfoList(): "
+            "ZIP is not open in mdUnzip mode");
+    return false;
+  }
+  QString currentFile;
+  if (q->hasCurrentFile()) {
+      currentFile = q->getCurrentFileName();
+  }
+  if (q->goToFirstFile()) {
+      do {
+          bool ok;
+          result->append(QuaZip_getFileInfo<TFileInfo>(q, &ok));
+          if (!ok)
+              return false;
+      } while (q->goToNextFile());
+  }
+  if (zipError != UNZ_OK)
+      return false;
+  if (currentFile.isEmpty()) {
+      if (!q->goToFirstFile())
+          return false;
+  } else {
+      if (!q->setCurrentFile(currentFile))
+          return false;
+  }
+  return true;
+}
+
+QStringList QuaZip::getFileNameList() const
+{
+    QStringList list;
+    if (p->getFileInfoList(&list))
+        return list;
+    else
+        return QStringList();
+}
+
+QList<QuaZipFileInfo> QuaZip::getFileInfoList() const
+{
+    QList<QuaZipFileInfo> list;
+    if (p->getFileInfoList(&list))
+        return list;
+    else
+        return QList<QuaZipFileInfo>();
+}
+
+QList<QuaZipFileInfo64> QuaZip::getFileInfoList64() const
+{
+    QList<QuaZipFileInfo64> list;
+    if (p->getFileInfoList(&list))
+        return list;
+    else
+        return QList<QuaZipFileInfo64>();
+}
+
+Qt::CaseSensitivity QuaZip::convertCaseSensitivity(QuaZip::CaseSensitivity cs)
+{
+  if (cs == csDefault) {
+#ifdef Q_OS_WIN
+      return Qt::CaseInsensitive;
+#else
+      return Qt::CaseSensitive;
+#endif
+  } else {
+      return cs == csSensitive ? Qt::CaseSensitive : Qt::CaseInsensitive;
+  }
+}
+
+void QuaZip::setDefaultFileNameCodec(QTextCodec *codec)
+{
+    QuaZipPrivate::defaultFileNameCodec = codec;
+}
+
+void QuaZip::setDefaultFileNameCodec(const char *codecName)
+{
+    setDefaultFileNameCodec(QTextCodec::codecForName(codecName));
+}
+
+void QuaZip::setDefaultOsCode(uint osCode)
+{
+    QuaZipPrivate::defaultOsCode = osCode;
+}
+
+uint QuaZip::getDefaultOsCode()
+{
+    return QuaZipPrivate::defaultOsCode;
+}
+
+void QuaZip::setZip64Enabled(bool zip64)
+{
+    p->zip64 = zip64;
+}
+
+bool QuaZip::isZip64Enabled() const
+{
+    return p->zip64;
+}
+
+void QuaZip::setUtf8Enabled(bool utf8)
+{
+    p->utf8 = utf8;
+}
+
+bool QuaZip::isUtf8Enabled() const
+{
+    return p->utf8;
+}
+
+bool QuaZip::isAutoClose() const
+{
+    return p->autoClose;
+}
+
+void QuaZip::setAutoClose(bool autoClose) const
+{
+    p->autoClose = autoClose;
+}
diff -ruN ./quazipfile.cpp ../../dep/quazip/quazip/quazipfile.cpp
--- ./quazipfile.cpp	2020-11-27 04:16:54.992498165 +0200
+++ ../../dep/quazip/quazip/quazipfile.cpp	2020-11-27 04:08:04.062517942 +0200
@@ -1,440 +1,570 @@
-/*
-Copyright (C) 2005-2011 Sergey A. Tachenov
-
-This program is free software; you can redistribute it and/or modify it
-under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation; either version 2 of the License, or (at
-your option) any later version.
-
-This program is distributed in the hope that it will be useful, but
-WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser
-General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this program; if not, write to the Free Software Foundation,
-Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
-
-See COPYING file for the full LGPL text.
-
-Original ZIP package is copyrighted by Gilles Vollant, see
-quazip/(un)zip.h files for details, basically it's zlib license.
- **/
-
-#include "quazipfile.h"
-
-using namespace std;
-
-class QuaZipFilePrivate {
-  friend class QuaZipFile;
-  private:
-    QuaZipFile *q;
-    QuaZip *zip;
-    QString fileName;
-    QuaZip::CaseSensitivity caseSensitivity;
-    bool raw;
-    qint64 writePos;
-    // these two are for writing raw files
-    ulong uncompressedSize;
-    quint32 crc;
-    bool internal;
-    int zipError;
-    inline void resetZipError() const {setZipError(UNZ_OK);}
-    // const, but sets zipError!
-    void setZipError(int zipError) const;
-    inline QuaZipFilePrivate(QuaZipFile *q):
-      q(q), zip(NULL), internal(true), zipError(UNZ_OK) {}
-    inline QuaZipFilePrivate(QuaZipFile *q, const QString &zipName):
-      q(q), internal(true), zipError(UNZ_OK)
-      {
-        zip=new QuaZip(zipName);
-      }
-    inline QuaZipFilePrivate(QuaZipFile *q, const QString &zipName, const QString &fileName,
-        QuaZip::CaseSensitivity cs):
-      q(q), internal(true), zipError(UNZ_OK)
-      {
-        zip=new QuaZip(zipName);
-        this->fileName=fileName;
-        this->caseSensitivity=cs;
-      }
-    inline QuaZipFilePrivate(QuaZipFile *q, QuaZip *zip):
-      q(q), zip(zip), internal(false), zipError(UNZ_OK) {}
-    inline ~QuaZipFilePrivate()
-    {
-      if (internal)
-        delete zip;
-    }
-};
-
-QuaZipFile::QuaZipFile():
-  p(new QuaZipFilePrivate(this))
-{
-}
-
-QuaZipFile::QuaZipFile(QObject *parent):
-  QIODevice(parent),
-  p(new QuaZipFilePrivate(this))
-{
-}
-
-QuaZipFile::QuaZipFile(const QString& zipName, QObject *parent):
-  QIODevice(parent),
-  p(new QuaZipFilePrivate(this, zipName))
-{
-}
-
-QuaZipFile::QuaZipFile(const QString& zipName, const QString& fileName,
-    QuaZip::CaseSensitivity cs, QObject *parent):
-  QIODevice(parent),
-  p(new QuaZipFilePrivate(this, zipName, fileName, cs))
-{
-}
-
-QuaZipFile::QuaZipFile(QuaZip *zip, QObject *parent):
-  QIODevice(parent),
-  p(new QuaZipFilePrivate(this, zip))
-{
-}
-
-QuaZipFile::~QuaZipFile()
-{
-  if (isOpen())
-    close();
-  delete p;
-}
-
-QString QuaZipFile::getZipName() const
-{
-  return p->zip==NULL ? QString() : p->zip->getZipName();
-}
-
-QString QuaZipFile::getActualFileName()const
-{
-  p->setZipError(UNZ_OK);
-  if (p->zip == NULL || (openMode() & WriteOnly))
-    return QString();
-  QString name=p->zip->getCurrentFileName();
-  if(name.isNull())
-    p->setZipError(p->zip->getZipError());
-  return name;
-}
-
-void QuaZipFile::setZipName(const QString& zipName)
-{
-  if(isOpen()) {
-    qWarning("QuaZipFile::setZipName(): file is already open - can not set ZIP name");
-    return;
-  }
-  if(p->zip!=NULL && p->internal)
-    delete p->zip;
-  p->zip=new QuaZip(zipName);
-  p->internal=true;
-}
-
-void QuaZipFile::setZip(QuaZip *zip)
-{
-  if(isOpen()) {
-    qWarning("QuaZipFile::setZip(): file is already open - can not set ZIP");
-    return;
-  }
-  if(p->zip!=NULL && p->internal)
-    delete p->zip;
-  p->zip=zip;
-  p->fileName=QString();
-  p->internal=false;
-}
-
-void QuaZipFile::setFileName(const QString& fileName, QuaZip::CaseSensitivity cs)
-{
-  if(p->zip==NULL) {
-    qWarning("QuaZipFile::setFileName(): call setZipName() first");
-    return;
-  }
-  if(!p->internal) {
-    qWarning("QuaZipFile::setFileName(): should not be used when not using internal QuaZip");
-    return;
-  }
-  if(isOpen()) {
-    qWarning("QuaZipFile::setFileName(): can not set file name for already opened file");
-    return;
-  }
-  p->fileName=fileName;
-  p->caseSensitivity=cs;
-}
-
-void QuaZipFilePrivate::setZipError(int zipError) const
-{
-  QuaZipFilePrivate *fakeThis = const_cast<QuaZipFilePrivate*>(this); // non-const
-  fakeThis->zipError=zipError;
-  if(zipError==UNZ_OK)
-    q->setErrorString(QString());
-  else
-    q->setErrorString(q->tr("ZIP/UNZIP API error %1").arg(zipError));
-}
-
-bool QuaZipFile::open(OpenMode mode)
-{
-  return open(mode, NULL);
-}
-
-bool QuaZipFile::open(OpenMode mode, int *method, int *level, bool raw, const char *password)
-{
-  p->resetZipError();
-  if(isOpen()) {
-    qWarning("QuaZipFile::open(): already opened");
-    return false;
-  }
-  if(mode&Unbuffered) {
-    qWarning("QuaZipFile::open(): Unbuffered mode is not supported");
-    return false;
-  }
-  if((mode&ReadOnly)&&!(mode&WriteOnly)) {
-    if(p->internal) {
-      if(!p->zip->open(QuaZip::mdUnzip)) {
-        p->setZipError(p->zip->getZipError());
-        return false;
-      }
-      if(!p->zip->setCurrentFile(p->fileName, p->caseSensitivity)) {
-        p->setZipError(p->zip->getZipError());
-        p->zip->close();
-        return false;
-      }
-    } else {
-      if(p->zip==NULL) {
-        qWarning("QuaZipFile::open(): zip is NULL");
-        return false;
-      }
-      if(p->zip->getMode()!=QuaZip::mdUnzip) {
-        qWarning("QuaZipFile::open(): file open mode %d incompatible with ZIP open mode %d",
-            (int)mode, (int)p->zip->getMode());
-        return false;
-      }
-      if(!p->zip->hasCurrentFile()) {
-        qWarning("QuaZipFile::open(): zip does not have current file");
-        return false;
-      }
-    }
-    p->setZipError(unzOpenCurrentFile3(p->zip->getUnzFile(), method, level, (int)raw, password));
-    if(p->zipError==UNZ_OK) {
-      setOpenMode(mode);
-      p->raw=raw;
-      return true;
-    } else
-      return false;
-  }
-  qWarning("QuaZipFile::open(): open mode %d not supported by this function", (int)mode);
-  return false;
-}
-
-bool QuaZipFile::open(OpenMode mode, const QuaZipNewInfo& info,
-    const char *password, quint32 crc,
-    int method, int level, bool raw,
-    int windowBits, int memLevel, int strategy)
-{
-  zip_fileinfo info_z;
-  p->resetZipError();
-  if(isOpen()) {
-    qWarning("QuaZipFile::open(): already opened");
-    return false;
-  }
-  if((mode&WriteOnly)&&!(mode&ReadOnly)) {
-    if(p->internal) {
-      qWarning("QuaZipFile::open(): write mode is incompatible with internal QuaZip approach");
-      return false;
-    }
-    if(p->zip==NULL) {
-      qWarning("QuaZipFile::open(): zip is NULL");
-      return false;
-    }
-    if(p->zip->getMode()!=QuaZip::mdCreate&&p->zip->getMode()!=QuaZip::mdAppend&&p->zip->getMode()!=QuaZip::mdAdd) {
-      qWarning("QuaZipFile::open(): file open mode %d incompatible with ZIP open mode %d",
-          (int)mode, (int)p->zip->getMode());
-      return false;
-    }
-    info_z.tmz_date.tm_year=info.dateTime.date().year();
-    info_z.tmz_date.tm_mon=info.dateTime.date().month() - 1;
-    info_z.tmz_date.tm_mday=info.dateTime.date().day();
-    info_z.tmz_date.tm_hour=info.dateTime.time().hour();
-    info_z.tmz_date.tm_min=info.dateTime.time().minute();
-    info_z.tmz_date.tm_sec=info.dateTime.time().second();
-    info_z.dosDate = 0;
-    info_z.internal_fa=(uLong)info.internalAttr;
-    info_z.external_fa=(uLong)info.externalAttr;
-    if (!p->zip->isDataDescriptorWritingEnabled())
-        zipClearFlags(p->zip->getZipFile(), ZIP_WRITE_DATA_DESCRIPTOR);
-    p->setZipError(zipOpenNewFileInZip3(p->zip->getZipFile(),
-          p->zip->getFileNameCodec()->fromUnicode(info.name).constData(), &info_z,
-          info.extraLocal.constData(), info.extraLocal.length(),
-          info.extraGlobal.constData(), info.extraGlobal.length(),
-          p->zip->getCommentCodec()->fromUnicode(info.comment).constData(),
-          method, level, (int)raw,
-          windowBits, memLevel, strategy,
-          password, (uLong)crc));
-    if(p->zipError==UNZ_OK) {
-      p->writePos=0;
-      setOpenMode(mode);
-      p->raw=raw;
-      if(raw) {
-        p->crc=crc;
-        p->uncompressedSize=info.uncompressedSize;
-      }
-      return true;
-    } else
-      return false;
-  }
-  qWarning("QuaZipFile::open(): open mode %d not supported by this function", (int)mode);
-  return false;
-}
-
-bool QuaZipFile::isSequential()const
-{
-  return true;
-}
-
-qint64 QuaZipFile::pos()const
-{
-  if(p->zip==NULL) {
-    qWarning("QuaZipFile::pos(): call setZipName() or setZip() first");
-    return -1;
-  }
-  if(!isOpen()) {
-    qWarning("QuaZipFile::pos(): file is not open");
-    return -1;
-  }
-  if(openMode()&ReadOnly)
-      // QIODevice::pos() is broken for sequential devices,
-      // but thankfully bytesAvailable() returns the number of
-      // bytes buffered, so we know how far ahead we are.
-    return unztell(p->zip->getUnzFile()) - QIODevice::bytesAvailable();
-  else
-    return p->writePos;
-}
-
-bool QuaZipFile::atEnd()const
-{
-  if(p->zip==NULL) {
-    qWarning("QuaZipFile::atEnd(): call setZipName() or setZip() first");
-    return false;
-  }
-  if(!isOpen()) {
-    qWarning("QuaZipFile::atEnd(): file is not open");
-    return false;
-  }
-  if(openMode()&ReadOnly)
-      // the same problem as with pos()
-    return QIODevice::bytesAvailable() == 0
-        && unzeof(p->zip->getUnzFile())==1;
-  else
-    return true;
-}
-
-qint64 QuaZipFile::size()const
-{
-  if(!isOpen()) {
-    qWarning("QuaZipFile::atEnd(): file is not open");
-    return -1;
-  }
-  if(openMode()&ReadOnly)
-    return p->raw?csize():usize();
-  else
-    return p->writePos;
-}
-
-qint64 QuaZipFile::csize()const
-{
-  unz_file_info info_z;
-  p->setZipError(UNZ_OK);
-  if(p->zip==NULL||p->zip->getMode()!=QuaZip::mdUnzip) return -1;
-  p->setZipError(unzGetCurrentFileInfo(p->zip->getUnzFile(), &info_z, NULL, 0, NULL, 0, NULL, 0));
-  if(p->zipError!=UNZ_OK)
-    return -1;
-  return info_z.compressed_size;
-}
-
-qint64 QuaZipFile::usize()const
-{
-  unz_file_info info_z;
-  p->setZipError(UNZ_OK);
-  if(p->zip==NULL||p->zip->getMode()!=QuaZip::mdUnzip) return -1;
-  p->setZipError(unzGetCurrentFileInfo(p->zip->getUnzFile(), &info_z, NULL, 0, NULL, 0, NULL, 0));
-  if(p->zipError!=UNZ_OK)
-    return -1;
-  return info_z.uncompressed_size;
-}
-
-bool QuaZipFile::getFileInfo(QuaZipFileInfo *info)
-{
-  if(p->zip==NULL||p->zip->getMode()!=QuaZip::mdUnzip) return false;
-  p->zip->getCurrentFileInfo(info);
-  p->setZipError(p->zip->getZipError());
-  return p->zipError==UNZ_OK;
-}
-
-void QuaZipFile::close()
-{
-  p->resetZipError();
-  if(p->zip==NULL||!p->zip->isOpen()) return;
-  if(!isOpen()) {
-    qWarning("QuaZipFile::close(): file isn't open");
-    return;
-  }
-  if(openMode()&ReadOnly)
-    p->setZipError(unzCloseCurrentFile(p->zip->getUnzFile()));
-  else if(openMode()&WriteOnly)
-    if(isRaw()) p->setZipError(zipCloseFileInZipRaw(p->zip->getZipFile(), p->uncompressedSize, p->crc));
-    else p->setZipError(zipCloseFileInZip(p->zip->getZipFile()));
-  else {
-    qWarning("Wrong open mode: %d", (int)openMode());
-    return;
-  }
-  if(p->zipError==UNZ_OK) setOpenMode(QIODevice::NotOpen);
-  else return;
-  if(p->internal) {
-    p->zip->close();
-    p->setZipError(p->zip->getZipError());
-  }
-}
-
-qint64 QuaZipFile::readData(char *data, qint64 maxSize)
-{
-  p->setZipError(UNZ_OK);
-  qint64 bytesRead=unzReadCurrentFile(p->zip->getUnzFile(), data, (unsigned)maxSize);
-  if(bytesRead<0) p->setZipError((int)bytesRead);
-  return bytesRead;
-}
-
-qint64 QuaZipFile::writeData(const char* data, qint64 maxSize)
-{
-  p->setZipError(ZIP_OK);
-  p->setZipError(zipWriteInFileInZip(p->zip->getZipFile(), data, (uint)maxSize));
-  if(p->zipError!=ZIP_OK) return -1;
-  else {
-    p->writePos+=maxSize;
-    return maxSize;
-  }
-}
-
-QString QuaZipFile::getFileName() const
-{
-  return p->fileName;
-}
-
-QuaZip::CaseSensitivity QuaZipFile::getCaseSensitivity() const
-{
-  return p->caseSensitivity;
-}
-
-bool QuaZipFile::isRaw() const
-{
-  return p->raw;
-}
-
-int QuaZipFile::getZipError() const
-{
-  return p->zipError;
-}
-
-qint64 QuaZipFile::bytesAvailable() const
-{
-    return size() - pos();
-}
+/*
+Copyright (C) 2005-2014 Sergey A. Tachenov
+
+This file is part of QuaZip.
+
+QuaZip is free software: you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation, either version 2.1 of the License, or
+(at your option) any later version.
+
+QuaZip is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with QuaZip.  If not, see <http://www.gnu.org/licenses/>.
+
+See COPYING file for the full LGPL text.
+
+Original ZIP package is copyrighted by Gilles Vollant, see
+quazip/(un)zip.h files for details, basically it's zlib license.
+ **/
+
+#include "quazipfile.h"
+
+#include "quazipfileinfo.h"
+
+using namespace std;
+
+#define QUAZIP_VERSION_MADE_BY 0x1Eu
+
+/// The implementation class for QuaZip.
+/**
+\internal
+
+This class contains all the private stuff for the QuaZipFile class, thus
+allowing to preserve binary compatibility between releases, the
+technique known as the Pimpl (private implementation) idiom.
+*/
+class QuaZipFilePrivate {
+  friend class QuaZipFile;
+  private:
+    Q_DISABLE_COPY(QuaZipFilePrivate)
+    /// The pointer to the associated QuaZipFile instance.
+    QuaZipFile *q;
+    /// The QuaZip object to work with.
+    QuaZip *zip;
+    /// The file name.
+    QString fileName;
+    /// Case sensitivity mode.
+    QuaZip::CaseSensitivity caseSensitivity;
+    /// Whether this file is opened in the raw mode.
+    bool raw;
+    /// Write position to keep track of.
+    /**
+      QIODevice::pos() is broken for non-seekable devices, so we need
+      our own position.
+      */
+    qint64 writePos;
+    /// Uncompressed size to write along with a raw file.
+    quint64 uncompressedSize;
+    /// CRC to write along with a raw file.
+    quint32 crc;
+    /// Whether \ref zip points to an internal QuaZip instance.
+    /**
+      This is true if the archive was opened by name, rather than by
+      supplying an existing QuaZip instance.
+      */
+    bool internal;
+    /// The last error.
+    int zipError;
+    /// Resets \ref zipError.
+    inline void resetZipError() const {setZipError(UNZ_OK);}
+    /// Sets the zip error.
+    /**
+      This function is marked as const although it changes one field.
+      This allows to call it from const functions that don't change
+      anything by themselves.
+      */
+    void setZipError(int zipError) const;
+    /// The constructor for the corresponding QuaZipFile constructor.
+    inline QuaZipFilePrivate(QuaZipFile *q):
+      q(q),
+      zip(nullptr),
+      caseSensitivity(QuaZip::csDefault),
+      raw(false),
+      writePos(0),
+      uncompressedSize(0),
+      crc(0),
+      internal(true),
+      zipError(UNZ_OK) {}
+    /// The constructor for the corresponding QuaZipFile constructor.
+    inline QuaZipFilePrivate(QuaZipFile *q, const QString &zipName):
+      q(q),
+      caseSensitivity(QuaZip::csDefault),
+      raw(false),
+      writePos(0),
+      uncompressedSize(0),
+      crc(0),
+      internal(true),
+      zipError(UNZ_OK)
+      {
+        zip=new QuaZip(zipName);
+      }
+    /// The constructor for the corresponding QuaZipFile constructor.
+    inline QuaZipFilePrivate(QuaZipFile *q, const QString &zipName, const QString &fileName,
+        QuaZip::CaseSensitivity cs):
+      q(q),
+      raw(false),
+      writePos(0),
+      uncompressedSize(0),
+      crc(0),
+      internal(true),
+      zipError(UNZ_OK)
+      {
+        zip=new QuaZip(zipName);
+        this->fileName=fileName;
+        if (this->fileName.startsWith(QLatin1String("/")))
+            this->fileName = this->fileName.mid(1);
+        this->caseSensitivity=cs;
+      }
+    /// The constructor for the QuaZipFile constructor accepting a file name.
+    inline QuaZipFilePrivate(QuaZipFile *q, QuaZip *zip):
+      q(q),
+      zip(zip),
+      raw(false),
+      writePos(0),
+      uncompressedSize(0),
+      crc(0),
+      internal(false),
+      zipError(UNZ_OK) {}
+    /// The destructor.
+    inline ~QuaZipFilePrivate()
+    {
+      if (internal)
+        delete zip;
+    }
+};
+
+QuaZipFile::QuaZipFile():
+  p(new QuaZipFilePrivate(this))
+{
+}
+
+QuaZipFile::QuaZipFile(QObject *parent):
+  QIODevice(parent),
+  p(new QuaZipFilePrivate(this))
+{
+}
+
+QuaZipFile::QuaZipFile(const QString& zipName, QObject *parent):
+  QIODevice(parent),
+  p(new QuaZipFilePrivate(this, zipName))
+{
+}
+
+QuaZipFile::QuaZipFile(const QString& zipName, const QString& fileName,
+    QuaZip::CaseSensitivity cs, QObject *parent):
+  QIODevice(parent),
+  p(new QuaZipFilePrivate(this, zipName, fileName, cs))
+{
+}
+
+QuaZipFile::QuaZipFile(QuaZip *zip, QObject *parent):
+  QIODevice(parent),
+  p(new QuaZipFilePrivate(this, zip))
+{
+}
+
+QuaZipFile::~QuaZipFile()
+{
+  if (isOpen())
+    close();
+  delete p;
+}
+
+QString QuaZipFile::getZipName() const
+{
+  return p->zip==nullptr ? QString() : p->zip->getZipName();
+}
+
+QuaZip *QuaZipFile::getZip() const
+{
+    return p->internal ? nullptr : p->zip;
+}
+
+QString QuaZipFile::getActualFileName()const
+{
+  p->setZipError(UNZ_OK);
+  if (p->zip == nullptr || (openMode() & WriteOnly))
+    return QString();
+  QString name=p->zip->getCurrentFileName();
+  if(name.isNull())
+    p->setZipError(p->zip->getZipError());
+  return name;
+}
+
+void QuaZipFile::setZipName(const QString& zipName)
+{
+  if(isOpen()) {
+    qWarning("QuaZipFile::setZipName(): file is already open - can not set ZIP name");
+    return;
+  }
+  if(p->zip!=nullptr && p->internal)
+    delete p->zip;
+  p->zip=new QuaZip(zipName);
+  p->internal=true;
+}
+
+void QuaZipFile::setZip(QuaZip *zip)
+{
+  if(isOpen()) {
+    qWarning("QuaZipFile::setZip(): file is already open - can not set ZIP");
+    return;
+  }
+  if(p->zip!=nullptr && p->internal)
+    delete p->zip;
+  p->zip=zip;
+  p->fileName=QString();
+  p->internal=false;
+}
+
+void QuaZipFile::setFileName(const QString& fileName, QuaZip::CaseSensitivity cs)
+{
+  if(p->zip==nullptr) {
+    qWarning("QuaZipFile::setFileName(): call setZipName() first");
+    return;
+  }
+  if(!p->internal) {
+    qWarning("QuaZipFile::setFileName(): should not be used when not using internal QuaZip");
+    return;
+  }
+  if(isOpen()) {
+    qWarning("QuaZipFile::setFileName(): can not set file name for already opened file");
+    return;
+  }
+  p->fileName=fileName;
+  if (p->fileName.startsWith(QLatin1String("/")))
+      p->fileName = p->fileName.mid(1);
+  p->caseSensitivity=cs;
+}
+
+void QuaZipFilePrivate::setZipError(int zipError) const
+{
+  QuaZipFilePrivate *fakeThis = const_cast<QuaZipFilePrivate*>(this); // non-const
+  fakeThis->zipError=zipError;
+  if(zipError==UNZ_OK)
+    q->setErrorString(QString());
+  else
+    q->setErrorString(QuaZipFile::tr("ZIP/UNZIP API error %1").arg(zipError));
+}
+
+bool QuaZipFile::open(OpenMode mode)
+{
+  return open(mode, nullptr);
+}
+
+bool QuaZipFile::open(OpenMode mode, int *method, int *level, bool raw, const char *password)
+{
+  p->resetZipError();
+  if(isOpen()) {
+    qWarning("QuaZipFile::open(): already opened");
+    return false;
+  }
+  if(mode&Unbuffered) {
+    qWarning("QuaZipFile::open(): Unbuffered mode is not supported");
+    return false;
+  }
+  if((mode&ReadOnly)&&!(mode&WriteOnly)) {
+    if(p->internal) {
+      if(!p->zip->open(QuaZip::mdUnzip)) {
+        p->setZipError(p->zip->getZipError());
+        return false;
+      }
+      if(!p->zip->setCurrentFile(p->fileName, p->caseSensitivity)) {
+        p->setZipError(p->zip->getZipError());
+        p->zip->close();
+        return false;
+      }
+    } else {
+      if(p->zip==nullptr) {
+        qWarning("QuaZipFile::open(): zip is null");
+        return false;
+      }
+      if(p->zip->getMode()!=QuaZip::mdUnzip) {
+        qWarning("QuaZipFile::open(): file open mode %d incompatible with ZIP open mode %d",
+            (int)mode, (int)p->zip->getMode());
+        return false;
+      }
+      if(!p->zip->hasCurrentFile()) {
+        qWarning("QuaZipFile::open(): zip does not have current file");
+        return false;
+      }
+    }
+    p->setZipError(unzOpenCurrentFile3(p->zip->getUnzFile(), method, level, (int)raw, password));
+    if(p->zipError==UNZ_OK) {
+      setOpenMode(mode);
+      p->raw=raw;
+      return true;
+    } else
+      return false;
+  }
+  qWarning("QuaZipFile::open(): open mode %d not supported by this function", (int)mode);
+  return false;
+}
+
+bool QuaZipFile::open(OpenMode mode, const QuaZipNewInfo& info,
+    const char *password, quint32 crc,
+    int method, int level, bool raw,
+    int windowBits, int memLevel, int strategy)
+{
+  zip_fileinfo info_z;
+  p->resetZipError();
+  if(isOpen()) {
+    qWarning("QuaZipFile::open(): already opened");
+    return false;
+  }
+  if((mode&WriteOnly)&&!(mode&ReadOnly)) {
+    if(p->internal) {
+      qWarning("QuaZipFile::open(): write mode is incompatible with internal QuaZip approach");
+      return false;
+    }
+    if(p->zip==nullptr) {
+      qWarning("QuaZipFile::open(): zip is null");
+      return false;
+    }
+    if(p->zip->getMode()!=QuaZip::mdCreate&&p->zip->getMode()!=QuaZip::mdAppend&&p->zip->getMode()!=QuaZip::mdAdd) {
+      qWarning("QuaZipFile::open(): file open mode %d incompatible with ZIP open mode %d",
+          (int)mode, (int)p->zip->getMode());
+      return false;
+    }
+    info_z.tmz_date.tm_year=info.dateTime.date().year();
+    info_z.tmz_date.tm_mon=info.dateTime.date().month() - 1;
+    info_z.tmz_date.tm_mday=info.dateTime.date().day();
+    info_z.tmz_date.tm_hour=info.dateTime.time().hour();
+    info_z.tmz_date.tm_min=info.dateTime.time().minute();
+    info_z.tmz_date.tm_sec=info.dateTime.time().second();
+    info_z.dosDate = 0;
+    info_z.internal_fa=(uLong)info.internalAttr;
+    info_z.external_fa=(uLong)info.externalAttr;
+    if (p->zip->isDataDescriptorWritingEnabled())
+        zipSetFlags(p->zip->getZipFile(), ZIP_WRITE_DATA_DESCRIPTOR);
+    else
+        zipClearFlags(p->zip->getZipFile(), ZIP_WRITE_DATA_DESCRIPTOR);
+    p->setZipError(zipOpenNewFileInZip4_64(p->zip->getZipFile(),
+          p->zip->isUtf8Enabled()
+            ? info.name.toUtf8().constData()
+            : p->zip->getFileNameCodec()->fromUnicode(info.name).constData(),
+          &info_z,
+          info.extraLocal.constData(), info.extraLocal.length(),
+          info.extraGlobal.constData(), info.extraGlobal.length(),
+          p->zip->isUtf8Enabled()
+            ? info.comment.toUtf8().constData()
+            : p->zip->getCommentCodec()->fromUnicode(info.comment).constData(),
+          method, level, (int)raw,
+          windowBits, memLevel, strategy,
+          password, (uLong)crc,
+          (p->zip->getOsCode() << 8) | QUAZIP_VERSION_MADE_BY,
+          0,
+          p->zip->isZip64Enabled()));
+    if(p->zipError==UNZ_OK) {
+      p->writePos=0;
+      setOpenMode(mode);
+      p->raw=raw;
+      if(raw) {
+        p->crc=crc;
+        p->uncompressedSize=info.uncompressedSize;
+      }
+      return true;
+    } else
+      return false;
+  }
+  qWarning("QuaZipFile::open(): open mode %d not supported by this function", (int)mode);
+  return false;
+}
+
+bool QuaZipFile::isSequential()const
+{
+  return true;
+}
+
+qint64 QuaZipFile::pos()const
+{
+  if(p->zip==nullptr) {
+    qWarning("QuaZipFile::pos(): call setZipName() or setZip() first");
+    return -1;
+  }
+  if(!isOpen()) {
+    qWarning("QuaZipFile::pos(): file is not open");
+    return -1;
+  }
+  if(openMode()&ReadOnly)
+      // QIODevice::pos() is broken for sequential devices,
+      // but thankfully bytesAvailable() returns the number of
+      // bytes buffered, so we know how far ahead we are.
+    return unztell64(p->zip->getUnzFile()) - QIODevice::bytesAvailable();
+  else
+    return p->writePos;
+}
+
+bool QuaZipFile::atEnd()const
+{
+  if(p->zip==nullptr) {
+    qWarning("QuaZipFile::atEnd(): call setZipName() or setZip() first");
+    return false;
+  }
+  if(!isOpen()) {
+    qWarning("QuaZipFile::atEnd(): file is not open");
+    return false;
+  }
+  if(openMode()&ReadOnly)
+      // the same problem as with pos()
+    return QIODevice::bytesAvailable() == 0
+        && unzeof(p->zip->getUnzFile())==1;
+  else
+    return true;
+}
+
+qint64 QuaZipFile::size()const
+{
+  if(!isOpen()) {
+    qWarning("QuaZipFile::atEnd(): file is not open");
+    return -1;
+  }
+  if(openMode()&ReadOnly)
+    return p->raw?csize():usize();
+  else
+    return p->writePos;
+}
+
+qint64 QuaZipFile::csize()const
+{
+  unz_file_info64 info_z;
+  p->setZipError(UNZ_OK);
+  if(p->zip==nullptr||p->zip->getMode()!=QuaZip::mdUnzip) return -1;
+  p->setZipError(unzGetCurrentFileInfo64(p->zip->getUnzFile(), &info_z, nullptr, 0, nullptr, 0, nullptr, 0));
+  if(p->zipError!=UNZ_OK)
+    return -1;
+  return info_z.compressed_size;
+}
+
+qint64 QuaZipFile::usize()const
+{
+  unz_file_info64 info_z;
+  p->setZipError(UNZ_OK);
+  if(p->zip==nullptr||p->zip->getMode()!=QuaZip::mdUnzip) return -1;
+  p->setZipError(unzGetCurrentFileInfo64(p->zip->getUnzFile(), &info_z, nullptr, 0, nullptr, 0, nullptr, 0));
+  if(p->zipError!=UNZ_OK)
+    return -1;
+  return info_z.uncompressed_size;
+}
+
+bool QuaZipFile::getFileInfo(QuaZipFileInfo *info)
+{
+    QuaZipFileInfo64 info64;
+    if (getFileInfo(&info64)) {
+        info64.toQuaZipFileInfo(*info);
+        return true;
+    } else {
+        return false;
+    }
+}
+
+bool QuaZipFile::getFileInfo(QuaZipFileInfo64 *info)
+{
+    if(p->zip==nullptr||p->zip->getMode()!=QuaZip::mdUnzip) return false;
+    p->zip->getCurrentFileInfo(info);
+    p->setZipError(p->zip->getZipError());
+    return p->zipError==UNZ_OK;
+}
+
+void QuaZipFile::close()
+{
+  p->resetZipError();
+  if(p->zip==nullptr||!p->zip->isOpen()) return;
+  if(!isOpen()) {
+    qWarning("QuaZipFile::close(): file isn't open");
+    return;
+  }
+  if(openMode()&ReadOnly)
+    p->setZipError(unzCloseCurrentFile(p->zip->getUnzFile()));
+  else if(openMode()&WriteOnly)
+    if(isRaw()) p->setZipError(zipCloseFileInZipRaw64(p->zip->getZipFile(), p->uncompressedSize, p->crc));
+    else p->setZipError(zipCloseFileInZip(p->zip->getZipFile()));
+  else {
+    qWarning("Wrong open mode: %d", (int)openMode());
+    return;
+  }
+  if(p->zipError==UNZ_OK) setOpenMode(QIODevice::NotOpen);
+  else return;
+  if(p->internal) {
+    p->zip->close();
+    p->setZipError(p->zip->getZipError());
+  }
+}
+
+qint64 QuaZipFile::readData(char *data, qint64 maxSize)
+{
+  p->setZipError(UNZ_OK);
+  qint64 bytesRead=unzReadCurrentFile(p->zip->getUnzFile(), data, (unsigned)maxSize);
+  if (bytesRead < 0) {
+    p->setZipError((int) bytesRead);
+    return -1;
+  }
+  return bytesRead;
+}
+
+qint64 QuaZipFile::writeData(const char* data, qint64 maxSize)
+{
+  p->setZipError(ZIP_OK);
+  p->setZipError(zipWriteInFileInZip(p->zip->getZipFile(), data, (uint)maxSize));
+  if(p->zipError!=ZIP_OK) return -1;
+  else {
+    p->writePos+=maxSize;
+    return maxSize;
+  }
+}
+
+QString QuaZipFile::getFileName() const
+{
+  return p->fileName;
+}
+
+QuaZip::CaseSensitivity QuaZipFile::getCaseSensitivity() const
+{
+  return p->caseSensitivity;
+}
+
+bool QuaZipFile::isRaw() const
+{
+  return p->raw;
+}
+
+int QuaZipFile::getZipError() const
+{
+  return p->zipError;
+}
+
+qint64 QuaZipFile::bytesAvailable() const
+{
+    return size() - pos();
+}
+
+QByteArray QuaZipFile::getLocalExtraField()
+{
+    int size = unzGetLocalExtrafield(p->zip->getUnzFile(), nullptr, 0);
+    QByteArray extra(size, '\0');
+    int err = unzGetLocalExtrafield(p->zip->getUnzFile(), extra.data(), static_cast<uint>(extra.size()));
+    if (err < 0) {
+        p->setZipError(err);
+        return QByteArray();
+    }
+    return extra;
+}
+
+QDateTime QuaZipFile::getExtModTime()
+{
+    return QuaZipFileInfo64::getExtTime(getLocalExtraField(), QUAZIP_EXTRA_EXT_MOD_TIME_FLAG);
+}
+
+QDateTime QuaZipFile::getExtAcTime()
+{
+    return QuaZipFileInfo64::getExtTime(getLocalExtraField(), QUAZIP_EXTRA_EXT_AC_TIME_FLAG);
+}
+
+QDateTime QuaZipFile::getExtCrTime()
+{
+    return QuaZipFileInfo64::getExtTime(getLocalExtraField(), QUAZIP_EXTRA_EXT_CR_TIME_FLAG);
+}
diff -ruN ./quazipfile.h ../../dep/quazip/quazip/quazipfile.h
--- ./quazipfile.h	2020-11-27 04:16:54.992498165 +0200
+++ ../../dep/quazip/quazip/quazipfile.h	2020-11-27 04:08:04.062517942 +0200
@@ -1,442 +1,508 @@
-#ifndef QUA_ZIPFILE_H
-#define QUA_ZIPFILE_H
-
-/*
-Copyright (C) 2005-2011 Sergey A. Tachenov
-
-This program is free software; you can redistribute it and/or modify it
-under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation; either version 2 of the License, or (at
-your option) any later version.
-
-This program is distributed in the hope that it will be useful, but
-WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser
-General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this program; if not, write to the Free Software Foundation,
-Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
-
-See COPYING file for the full LGPL text.
-
-Original ZIP package is copyrighted by Gilles Vollant, see
-quazip/(un)zip.h files for details, basically it's zlib license.
- **/
-
-#include <QIODevice>
-
-#include "quazip_global.h"
-#include "quazip.h"
-#include "quazipnewinfo.h"
-
-class QuaZipFilePrivate;
-
-/// A file inside ZIP archive.
-/** \class QuaZipFile quazipfile.h <quazip/quazipfile.h>
- * This is the most interesting class. Not only it provides C++
- * interface to the ZIP/UNZIP package, but also integrates it with Qt by
- * subclassing QIODevice. This makes possible to access files inside ZIP
- * archive using QTextStream or QDataStream, for example. Actually, this
- * is the main purpose of the whole QuaZIP library.
- *
- * You can either use existing QuaZip instance to create instance of
- * this class or pass ZIP archive file name to this class, in which case
- * it will create internal QuaZip object. See constructors' descriptions
- * for details. Writing is only possible with the existing instance.
- *
- * Note that due to the underlying library's limitation it is not
- * possible to use multiple QuaZipFile instances to open several files
- * in the same archive at the same time. If you need to write to
- * multiple files in parallel, then you should write to temporary files
- * first, then pack them all at once when you have finished writing. If
- * you need to read multiple files inside the same archive in parallel,
- * you should extract them all into a temporary directory first.
- *
- * \section quazipfile-sequential Sequential or random-access?
- *
- * At the first thought, QuaZipFile has fixed size, the start and the
- * end and should be therefore considered random-access device. But
- * there is one major obstacle to making it random-access: ZIP/UNZIP API
- * does not support seek() operation and the only way to implement it is
- * through reopening the file and re-reading to the required position,
- * but this is prohibitively slow.
- *
- * Therefore, QuaZipFile is considered to be a sequential device. This
- * has advantage of availability of the ungetChar() operation (QIODevice
- * does not implement it properly for non-sequential devices unless they
- * support seek()). Disadvantage is a somewhat strange behaviour of the
- * size() and pos() functions. This should be kept in mind while using
- * this class.
- *
- **/
-class QUAZIP_EXPORT QuaZipFile: public QIODevice {
-  friend class QuaZipFilePrivate;
-  Q_OBJECT
-  private:
-    QuaZipFilePrivate *p;
-    // these are not supported nor implemented
-    QuaZipFile(const QuaZipFile& that);
-    QuaZipFile& operator=(const QuaZipFile& that);
-  protected:
-    /// Implementation of the QIODevice::readData().
-    qint64 readData(char *data, qint64 maxSize);
-    /// Implementation of the QIODevice::writeData().
-    qint64 writeData(const char *data, qint64 maxSize);
-  public:
-    /// Constructs a QuaZipFile instance.
-    /** You should use setZipName() and setFileName() or setZip() before
-     * trying to call open() on the constructed object.
-     **/
-    QuaZipFile();
-    /// Constructs a QuaZipFile instance.
-    /** \a parent argument specifies this object's parent object.
-     *
-     * You should use setZipName() and setFileName() or setZip() before
-     * trying to call open() on the constructed object.
-     **/
-    QuaZipFile(QObject *parent);
-    /// Constructs a QuaZipFile instance.
-    /** \a parent argument specifies this object's parent object and \a
-     * zipName specifies ZIP archive file name.
-     *
-     * You should use setFileName() before trying to call open() on the
-     * constructed object.
-     *
-     * QuaZipFile constructed by this constructor can be used for read
-     * only access. Use QuaZipFile(QuaZip*,QObject*) for writing.
-     **/
-    QuaZipFile(const QString& zipName, QObject *parent =NULL);
-    /// Constructs a QuaZipFile instance.
-    /** \a parent argument specifies this object's parent object, \a
-     * zipName specifies ZIP archive file name and \a fileName and \a cs
-     * specify a name of the file to open inside archive.
-     *
-     * QuaZipFile constructed by this constructor can be used for read
-     * only access. Use QuaZipFile(QuaZip*,QObject*) for writing.
-     *
-     * \sa QuaZip::setCurrentFile()
-     **/
-    QuaZipFile(const QString& zipName, const QString& fileName,
-        QuaZip::CaseSensitivity cs =QuaZip::csDefault, QObject *parent =NULL);
-    /// Constructs a QuaZipFile instance.
-    /** \a parent argument specifies this object's parent object.
-     *
-     * \a zip is the pointer to the existing QuaZip object. This
-     * QuaZipFile object then can be used to read current file in the
-     * \a zip or to write to the file inside it.
-     *
-     * \warning Using this constructor for reading current file can be
-     * tricky. Let's take the following example:
-     * \code
-     * QuaZip zip("archive.zip");
-     * zip.open(QuaZip::mdUnzip);
-     * zip.setCurrentFile("file-in-archive");
-     * QuaZipFile file(&zip);
-     * file.open(QIODevice::ReadOnly);
-     * // ok, now we can read from the file
-     * file.read(somewhere, some);
-     * zip.setCurrentFile("another-file-in-archive"); // oops...
-     * QuaZipFile anotherFile(&zip);
-     * anotherFile.open(QIODevice::ReadOnly);
-     * anotherFile.read(somewhere, some); // this is still ok...
-     * file.read(somewhere, some); // and this is NOT
-     * \endcode
-     * So, what exactly happens here? When we change current file in the
-     * \c zip archive, \c file that references it becomes invalid
-     * (actually, as far as I understand ZIP/UNZIP sources, it becomes
-     * closed, but QuaZipFile has no means to detect it).
-     *
-     * Summary: do not close \c zip object or change its current file as
-     * long as QuaZipFile is open. Even better - use another constructors
-     * which create internal QuaZip instances, one per object, and
-     * therefore do not cause unnecessary trouble. This constructor may
-     * be useful, though, if you already have a QuaZip instance and do
-     * not want to access several files at once. Good example:
-     * \code
-     * QuaZip zip("archive.zip");
-     * zip.open(QuaZip::mdUnzip);
-     * // first, we need some information about archive itself
-     * QByteArray comment=zip.getComment();
-     * // and now we are going to access files inside it
-     * QuaZipFile file(&zip);
-     * for(bool more=zip.goToFirstFile(); more; more=zip.goToNextFile()) {
-     *   file.open(QIODevice::ReadOnly);
-     *   // do something cool with file here
-     *   file.close(); // do not forget to close!
-     * }
-     * zip.close();
-     * \endcode
-     **/
-    QuaZipFile(QuaZip *zip, QObject *parent =NULL);
-    /// Destroys a QuaZipFile instance.
-    /** Closes file if open, destructs internal QuaZip object (if it
-     * exists and \em is internal, of course).
-     **/
-    virtual ~QuaZipFile();
-    /// Returns the ZIP archive file name.
-    /** If this object was created by passing QuaZip pointer to the
-     * constructor, this function will return that QuaZip's file name
-     * (or null string if that object does not have file name yet).
-     *
-     * Otherwise, returns associated ZIP archive file name or null
-     * string if there are no name set yet.
-     *
-     * \sa setZipName() getFileName()
-     **/
-    QString getZipName()const;
-    /// Returns a pointer to the associated QuaZip object.
-    /** Returns \c NULL if there is no associated QuaZip or it is
-     * internal (so you will not mess with it).
-     **/
-    QuaZip* getZip()const;
-    /// Returns file name.
-    /** This function returns file name you passed to this object either
-     * by using
-     * QuaZipFile(const QString&,const QString&,QuaZip::CaseSensitivity,QObject*)
-     * or by calling setFileName(). Real name of the file may differ in
-     * case if you used case-insensitivity.
-     *
-     * Returns null string if there is no file name set yet. This is the
-     * case when this QuaZipFile operates on the existing QuaZip object
-     * (constructor QuaZipFile(QuaZip*,QObject*) or setZip() was used).
-     * 
-     * \sa getActualFileName
-     **/
-    QString getFileName() const;
-    /// Returns case sensitivity of the file name.
-    /** This function returns case sensitivity argument you passed to
-     * this object either by using
-     * QuaZipFile(const QString&,const QString&,QuaZip::CaseSensitivity,QObject*)
-     * or by calling setFileName().
-     *
-     * Returns unpredictable value if getFileName() returns null string
-     * (this is the case when you did not used setFileName() or
-     * constructor above).
-     *
-     * \sa getFileName
-     **/
-    QuaZip::CaseSensitivity getCaseSensitivity() const;
-    /// Returns the actual file name in the archive.
-    /** This is \em not a ZIP archive file name, but a name of file inside
-     * archive. It is not necessary the same name that you have passed
-     * to the
-     * QuaZipFile(const QString&,const QString&,QuaZip::CaseSensitivity,QObject*),
-     * setFileName() or QuaZip::setCurrentFile() - this is the real file
-     * name inside archive, so it may differ in case if the file name
-     * search was case-insensitive.
-     *
-     * Equivalent to calling getCurrentFileName() on the associated
-     * QuaZip object. Returns null string if there is no associated
-     * QuaZip object or if it does not have a current file yet. And this
-     * is the case if you called setFileName() but did not open the
-     * file yet. So this is perfectly fine:
-     * \code
-     * QuaZipFile file("somezip.zip");
-     * file.setFileName("somefile");
-     * QString name=file.getName(); // name=="somefile"
-     * QString actual=file.getActualFileName(); // actual is null string
-     * file.open(QIODevice::ReadOnly);
-     * QString actual=file.getActualFileName(); // actual can be "SoMeFiLe" on Windows
-     * \endcode
-     *
-     * \sa getZipName(), getFileName(), QuaZip::CaseSensitivity
-     **/
-    QString getActualFileName()const;
-    /// Sets the ZIP archive file name.
-    /** Automatically creates internal QuaZip object and destroys
-     * previously created internal QuaZip object, if any.
-     *
-     * Will do nothing if this file is already open. You must close() it
-     * first.
-     **/
-    void setZipName(const QString& zipName);
-    /// Returns \c true if the file was opened in raw mode.
-    /** If the file is not open, the returned value is undefined.
-     *
-     * \sa open(OpenMode,int*,int*,bool,const char*)
-     **/
-    bool isRaw() const;
-    /// Binds to the existing QuaZip instance.
-    /** This function destroys internal QuaZip object, if any, and makes
-     * this QuaZipFile to use current file in the \a zip object for any
-     * further operations. See QuaZipFile(QuaZip*,QObject*) for the
-     * possible pitfalls.
-     *
-     * Will do nothing if the file is currently open. You must close()
-     * it first.
-     **/
-    void setZip(QuaZip *zip);
-    /// Sets the file name.
-    /** Will do nothing if at least one of the following conditions is
-     * met:
-     * - ZIP name has not been set yet (getZipName() returns null
-     *   string).
-     * - This QuaZipFile is associated with external QuaZip. In this
-     *   case you should call that QuaZip's setCurrentFile() function
-     *   instead!
-     * - File is already open so setting the name is meaningless.
-     *
-     * \sa QuaZip::setCurrentFile
-     **/
-    void setFileName(const QString& fileName, QuaZip::CaseSensitivity cs =QuaZip::csDefault);
-    /// Opens a file for reading.
-    /** Returns \c true on success, \c false otherwise.
-     * Call getZipError() to get error code.
-     *
-     * \note Since ZIP/UNZIP API provides buffered reading only,
-     * QuaZipFile does not support unbuffered reading. So do not pass
-     * QIODevice::Unbuffered flag in \a mode, or open will fail.
-     **/
-    virtual bool open(OpenMode mode);
-    /// Opens a file for reading.
-    /** \overload
-     * Argument \a password specifies a password to decrypt the file. If
-     * it is NULL then this function behaves just like open(OpenMode).
-     **/
-    inline bool open(OpenMode mode, const char *password)
-    {return open(mode, NULL, NULL, false, password);}
-    /// Opens a file for reading.
-    /** \overload
-     * Argument \a password specifies a password to decrypt the file.
-     *
-     * An integers pointed by \a method and \a level will receive codes
-     * of the compression method and level used. See unzip.h.
-     *
-     * If raw is \c true then no decompression is performed.
-     *
-     * \a method should not be \c NULL. \a level can be \c NULL if you
-     * don't want to know the compression level.
-     **/
-    bool open(OpenMode mode, int *method, int *level, bool raw, const char *password =NULL);
-    /// Opens a file for writing.
-    /** \a info argument specifies information about file. It should at
-     * least specify a correct file name. Also, it is a good idea to
-     * specify correct timestamp (by default, current time will be
-     * used). See QuaZipNewInfo.
-     *
-     * The \a password argument specifies the password for crypting. Pass NULL
-     * if you don't need any crypting. The \a crc argument was supposed
-     * to be used for crypting too, but then it turned out that it's
-     * false information, so you need to set it to 0 unless you want to
-     * use the raw mode (see below).
-     *
-     * Arguments \a method and \a level specify compression method and
-     * level. The only method supported is Z_DEFLATED, but you may also
-     * specify 0 for no compression. If all of the files in the archive
-     * use both method 0 and either level 0 is explicitly specified or
-     * data descriptor writing is disabled with
-     * QuaZip::setDataDescriptorWritingEnabled(), then the
-     * resulting archive is supposed to be compatible with the 1.0 ZIP
-     * format version, should you need that. Except for this, \a level
-     * has no other effects with method 0.
-     *
-     * If \a raw is \c true, no compression is performed. In this case,
-     * \a crc and uncompressedSize field of the \a info are required.
-     *
-     * Arguments \a windowBits, \a memLevel, \a strategy provide zlib
-     * algorithms tuning. See deflateInit2() in zlib.
-     **/
-    bool open(OpenMode mode, const QuaZipNewInfo& info,
-        const char *password =NULL, quint32 crc =0,
-        int method =Z_DEFLATED, int level =Z_DEFAULT_COMPRESSION, bool raw =false,
-        int windowBits =-MAX_WBITS, int memLevel =DEF_MEM_LEVEL, int strategy =Z_DEFAULT_STRATEGY);
-    /// Returns \c true, but \ref quazipfile-sequential "beware"!
-    virtual bool isSequential()const;
-    /// Returns current position in the file.
-    /** Implementation of the QIODevice::pos(). When reading, this
-     * function is a wrapper to the ZIP/UNZIP unztell(), therefore it is
-     * unable to keep track of the ungetChar() calls (which is
-     * non-virtual and therefore is dangerous to reimplement). So if you
-     * are using ungetChar() feature of the QIODevice, this function
-     * reports incorrect value until you get back characters which you
-     * ungot.
-     *
-     * When writing, pos() returns number of bytes already written
-     * (uncompressed unless you use raw mode).
-     *
-     * \note Although
-     * \ref quazipfile-sequential "QuaZipFile is a sequential device"
-     * and therefore pos() should always return zero, it does not,
-     * because it would be misguiding. Keep this in mind.
-     *
-     * This function returns -1 if the file or archive is not open.
-     *
-     * Error code returned by getZipError() is not affected by this
-     * function call.
-     **/
-    virtual qint64 pos()const;
-    /// Returns \c true if the end of file was reached.
-    /** This function returns \c false in the case of error. This means
-     * that you called this function on either not open file, or a file
-     * in the not open archive or even on a QuaZipFile instance that
-     * does not even have QuaZip instance associated. Do not do that
-     * because there is no means to determine whether \c false is
-     * returned because of error or because end of file was reached.
-     * Well, on the other side you may interpret \c false return value
-     * as "there is no file open to check for end of file and there is
-     * no end of file therefore".
-     *
-     * When writing, this function always returns \c true (because you
-     * are always writing to the end of file).
-     *
-     * Error code returned by getZipError() is not affected by this
-     * function call.
-     **/
-    virtual bool atEnd()const;
-    /// Returns file size.
-    /** This function returns csize() if the file is open for reading in
-     * raw mode, usize() if it is open for reading in normal mode and
-     * pos() if it is open for writing.
-     *
-     * Returns -1 on error, call getZipError() to get error code.
-     *
-     * \note This function returns file size despite that
-     * \ref quazipfile-sequential "QuaZipFile is considered to be sequential device",
-     * for which size() should return bytesAvailable() instead. But its
-     * name would be very misguiding otherwise, so just keep in mind
-     * this inconsistence.
-     **/
-    virtual qint64 size()const;
-    /// Returns compressed file size.
-    /** Equivalent to calling getFileInfo() and then getting
-     * compressedSize field, but more convenient and faster.
-     *
-     * File must be open for reading before calling this function.
-     *
-     * Returns -1 on error, call getZipError() to get error code.
-     **/
-    qint64 csize()const;
-    /// Returns uncompressed file size.
-    /** Equivalent to calling getFileInfo() and then getting
-     * uncompressedSize field, but more convenient and faster. See
-     * getFileInfo() for a warning.
-     *
-     * File must be open for reading before calling this function.
-     *
-     * Returns -1 on error, call getZipError() to get error code.
-     **/
-    qint64 usize()const;
-    /// Gets information about current file.
-    /** This function does the same thing as calling
-     * QuaZip::getCurrentFileInfo() on the associated QuaZip object,
-     * but you can not call getCurrentFileInfo() if the associated
-     * QuaZip is internal (because you do not have access to it), while
-     * you still can call this function in that case.
-     *
-     * File must be open for reading before calling this function.
-     *
-     * Returns \c false in the case of an error.
-     **/
-    bool getFileInfo(QuaZipFileInfo *info);
-    /// Closes the file.
-    /** Call getZipError() to determine if the close was successful.
-     **/
-    virtual void close();
-    /// Returns the error code returned by the last ZIP/UNZIP API call.
-    int getZipError() const;
-    /// Returns the number of bytes available for reading.
-    virtual qint64 bytesAvailable() const;
-};
-
-#endif
+#ifndef QUA_ZIPFILE_H
+#define QUA_ZIPFILE_H
+
+/*
+Copyright (C) 2005-2014 Sergey A. Tachenov
+
+This file is part of QuaZip.
+
+QuaZip is free software: you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation, either version 2.1 of the License, or
+(at your option) any later version.
+
+QuaZip is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with QuaZip.  If not, see <http://www.gnu.org/licenses/>.
+
+See COPYING file for the full LGPL text.
+
+Original ZIP package is copyrighted by Gilles Vollant, see
+quazip/(un)zip.h files for details, basically it's zlib license.
+ **/
+
+#include <QtCore/QIODevice>
+
+#include "quazip_global.h"
+#include "quazip.h"
+#include "quazipnewinfo.h"
+
+class QuaZipFilePrivate;
+
+/// A file inside ZIP archive.
+/** \class QuaZipFile quazipfile.h <quazip/quazipfile.h>
+ * This is the most interesting class. Not only it provides C++
+ * interface to the ZIP/UNZIP package, but also integrates it with Qt by
+ * subclassing QIODevice. This makes possible to access files inside ZIP
+ * archive using QTextStream or QDataStream, for example. Actually, this
+ * is the main purpose of the whole QuaZip library.
+ *
+ * You can either use existing QuaZip instance to create instance of
+ * this class or pass ZIP archive file name to this class, in which case
+ * it will create internal QuaZip object. See constructors' descriptions
+ * for details. Writing is only possible with the existing instance.
+ *
+ * Note that due to the underlying library's limitation it is not
+ * possible to use multiple QuaZipFile instances to open several files
+ * in the same archive at the same time. If you need to write to
+ * multiple files in parallel, then you should write to temporary files
+ * first, then pack them all at once when you have finished writing. If
+ * you need to read multiple files inside the same archive in parallel,
+ * you should extract them all into a temporary directory first.
+ *
+ * \section quazipfile-sequential Sequential or random-access?
+ *
+ * At the first thought, QuaZipFile has fixed size, the start and the
+ * end and should be therefore considered random-access device. But
+ * there is one major obstacle to making it random-access: ZIP/UNZIP API
+ * does not support seek() operation and the only way to implement it is
+ * through reopening the file and re-reading to the required position,
+ * but this is prohibitively slow.
+ *
+ * Therefore, QuaZipFile is considered to be a sequential device. This
+ * has advantage of availability of the ungetChar() operation (QIODevice
+ * does not implement it properly for non-sequential devices unless they
+ * support seek()). Disadvantage is a somewhat strange behaviour of the
+ * size() and pos() functions. This should be kept in mind while using
+ * this class.
+ *
+ **/
+class QUAZIP_EXPORT QuaZipFile: public QIODevice {
+  friend class QuaZipFilePrivate;
+  Q_OBJECT
+  private:
+    QuaZipFilePrivate *p;
+    // these are not supported nor implemented
+    QuaZipFile(const QuaZipFile& that);
+    QuaZipFile& operator=(const QuaZipFile& that);
+  protected:
+    /// Implementation of the QIODevice::readData().
+    qint64 readData(char *data, qint64 maxSize);
+    /// Implementation of the QIODevice::writeData().
+    qint64 writeData(const char *data, qint64 maxSize);
+  public:
+    /// Constructs a QuaZipFile instance.
+    /** You should use setZipName() and setFileName() or setZip() before
+     * trying to call open() on the constructed object.
+     **/
+    QuaZipFile();
+    /// Constructs a QuaZipFile instance.
+    /** \a parent argument specifies this object's parent object.
+     *
+     * You should use setZipName() and setFileName() or setZip() before
+     * trying to call open() on the constructed object.
+     **/
+    QuaZipFile(QObject *parent);
+    /// Constructs a QuaZipFile instance.
+    /** \a parent argument specifies this object's parent object and \a
+     * zipName specifies ZIP archive file name.
+     *
+     * You should use setFileName() before trying to call open() on the
+     * constructed object.
+     *
+     * QuaZipFile constructed by this constructor can be used for read
+     * only access. Use QuaZipFile(QuaZip*,QObject*) for writing.
+     **/
+    QuaZipFile(const QString& zipName, QObject *parent =nullptr);
+    /// Constructs a QuaZipFile instance.
+    /** \a parent argument specifies this object's parent object, \a
+     * zipName specifies ZIP archive file name and \a fileName and \a cs
+     * specify a name of the file to open inside archive.
+     *
+     * QuaZipFile constructed by this constructor can be used for read
+     * only access. Use QuaZipFile(QuaZip*,QObject*) for writing.
+     *
+     * \sa QuaZip::setCurrentFile()
+     **/
+    QuaZipFile(const QString& zipName, const QString& fileName,
+        QuaZip::CaseSensitivity cs =QuaZip::csDefault, QObject *parent =nullptr);
+    /// Constructs a QuaZipFile instance.
+    /** \a parent argument specifies this object's parent object.
+     *
+     * \a zip is the pointer to the existing QuaZip object. This
+     * QuaZipFile object then can be used to read current file in the
+     * \a zip or to write to the file inside it.
+     *
+     * \warning Using this constructor for reading current file can be
+     * tricky. Let's take the following example:
+     * \code
+     * QuaZip zip("archive.zip");
+     * zip.open(QuaZip::mdUnzip);
+     * zip.setCurrentFile("file-in-archive");
+     * QuaZipFile file(&zip);
+     * file.open(QIODevice::ReadOnly);
+     * // ok, now we can read from the file
+     * file.read(somewhere, some);
+     * zip.setCurrentFile("another-file-in-archive"); // oops...
+     * QuaZipFile anotherFile(&zip);
+     * anotherFile.open(QIODevice::ReadOnly);
+     * anotherFile.read(somewhere, some); // this is still ok...
+     * file.read(somewhere, some); // and this is NOT
+     * \endcode
+     * So, what exactly happens here? When we change current file in the
+     * \c zip archive, \c file that references it becomes invalid
+     * (actually, as far as I understand ZIP/UNZIP sources, it becomes
+     * closed, but QuaZipFile has no means to detect it).
+     *
+     * Summary: do not close \c zip object or change its current file as
+     * long as QuaZipFile is open. Even better - use another constructors
+     * which create internal QuaZip instances, one per object, and
+     * therefore do not cause unnecessary trouble. This constructor may
+     * be useful, though, if you already have a QuaZip instance and do
+     * not want to access several files at once. Good example:
+     * \code
+     * QuaZip zip("archive.zip");
+     * zip.open(QuaZip::mdUnzip);
+     * // first, we need some information about archive itself
+     * QByteArray comment=zip.getComment();
+     * // and now we are going to access files inside it
+     * QuaZipFile file(&zip);
+     * for(bool more=zip.goToFirstFile(); more; more=zip.goToNextFile()) {
+     *   file.open(QIODevice::ReadOnly);
+     *   // do something cool with file here
+     *   file.close(); // do not forget to close!
+     * }
+     * zip.close();
+     * \endcode
+     **/
+    QuaZipFile(QuaZip *zip, QObject *parent =nullptr);
+    /// Destroys a QuaZipFile instance.
+    /** Closes file if open, destructs internal QuaZip object (if it
+     * exists and \em is internal, of course).
+     **/
+    virtual ~QuaZipFile();
+    /// Returns the ZIP archive file name.
+    /** If this object was created by passing QuaZip pointer to the
+     * constructor, this function will return that QuaZip's file name
+     * (or null string if that object does not have file name yet).
+     *
+     * Otherwise, returns associated ZIP archive file name or null
+     * string if there are no name set yet.
+     *
+     * \sa setZipName() getFileName()
+     **/
+    QString getZipName()const;
+    /// Returns a pointer to the associated QuaZip object.
+    /** Returns \c NULL if there is no associated QuaZip or it is
+     * internal (so you will not mess with it).
+     **/
+    QuaZip* getZip()const;
+    /// Returns file name.
+    /** This function returns file name you passed to this object either
+     * by using
+     * QuaZipFile(const QString&,const QString&,QuaZip::CaseSensitivity,QObject*)
+     * or by calling setFileName(). Real name of the file may differ in
+     * case if you used case-insensitivity.
+     *
+     * Returns null string if there is no file name set yet. This is the
+     * case when this QuaZipFile operates on the existing QuaZip object
+     * (constructor QuaZipFile(QuaZip*,QObject*) or setZip() was used).
+     * 
+     * \sa getActualFileName
+     **/
+    QString getFileName() const;
+    /// Returns case sensitivity of the file name.
+    /** This function returns case sensitivity argument you passed to
+     * this object either by using
+     * QuaZipFile(const QString&,const QString&,QuaZip::CaseSensitivity,QObject*)
+     * or by calling setFileName().
+     *
+     * Returns unpredictable value if getFileName() returns null string
+     * (this is the case when you did not used setFileName() or
+     * constructor above).
+     *
+     * \sa getFileName
+     **/
+    QuaZip::CaseSensitivity getCaseSensitivity() const;
+    /// Returns the actual file name in the archive.
+    /** This is \em not a ZIP archive file name, but a name of file inside
+     * archive. It is not necessary the same name that you have passed
+     * to the
+     * QuaZipFile(const QString&,const QString&,QuaZip::CaseSensitivity,QObject*),
+     * setFileName() or QuaZip::setCurrentFile() - this is the real file
+     * name inside archive, so it may differ in case if the file name
+     * search was case-insensitive.
+     *
+     * Equivalent to calling getCurrentFileName() on the associated
+     * QuaZip object. Returns null string if there is no associated
+     * QuaZip object or if it does not have a current file yet. And this
+     * is the case if you called setFileName() but did not open the
+     * file yet. So this is perfectly fine:
+     * \code
+     * QuaZipFile file("somezip.zip");
+     * file.setFileName("somefile");
+     * QString name=file.getName(); // name=="somefile"
+     * QString actual=file.getActualFileName(); // actual is null string
+     * file.open(QIODevice::ReadOnly);
+     * QString actual=file.getActualFileName(); // actual can be "SoMeFiLe" on Windows
+     * \endcode
+     *
+     * \sa getZipName(), getFileName(), QuaZip::CaseSensitivity
+     **/
+    QString getActualFileName()const;
+    /// Sets the ZIP archive file name.
+    /** Automatically creates internal QuaZip object and destroys
+     * previously created internal QuaZip object, if any.
+     *
+     * Will do nothing if this file is already open. You must close() it
+     * first.
+     **/
+    void setZipName(const QString& zipName);
+    /// Returns \c true if the file was opened in raw mode.
+    /** If the file is not open, the returned value is undefined.
+     *
+     * \sa open(OpenMode,int*,int*,bool,const char*)
+     **/
+    bool isRaw() const;
+    /// Binds to the existing QuaZip instance.
+    /** This function destroys internal QuaZip object, if any, and makes
+     * this QuaZipFile to use current file in the \a zip object for any
+     * further operations. See QuaZipFile(QuaZip*,QObject*) for the
+     * possible pitfalls.
+     *
+     * Will do nothing if the file is currently open. You must close()
+     * it first.
+     **/
+    void setZip(QuaZip *zip);
+    /// Sets the file name.
+    /** Will do nothing if at least one of the following conditions is
+     * met:
+     * - ZIP name has not been set yet (getZipName() returns null
+     *   string).
+     * - This QuaZipFile is associated with external QuaZip. In this
+     *   case you should call that QuaZip's setCurrentFile() function
+     *   instead!
+     * - File is already open so setting the name is meaningless.
+     *
+     * \sa QuaZip::setCurrentFile
+     **/
+    void setFileName(const QString& fileName, QuaZip::CaseSensitivity cs =QuaZip::csDefault);
+    /// Opens a file for reading.
+    /** Returns \c true on success, \c false otherwise.
+     * Call getZipError() to get error code.
+     *
+     * \note Since ZIP/UNZIP API provides buffered reading only,
+     * QuaZipFile does not support unbuffered reading. So do not pass
+     * QIODevice::Unbuffered flag in \a mode, or open will fail.
+     **/
+    virtual bool open(OpenMode mode);
+    /// Opens a file for reading.
+    /** \overload
+     * Argument \a password specifies a password to decrypt the file. If
+     * it is NULL then this function behaves just like open(OpenMode).
+     **/
+    inline bool open(OpenMode mode, const char *password)
+    {return open(mode, nullptr, nullptr, false, password);}
+    /// Opens a file for reading.
+    /** \overload
+     * Argument \a password specifies a password to decrypt the file.
+     *
+     * An integers pointed by \a method and \a level will receive codes
+     * of the compression method and level used. See unzip.h.
+     *
+     * If raw is \c true then no decompression is performed.
+     *
+     * \a method should not be \c NULL. \a level can be \c NULL if you
+     * don't want to know the compression level.
+     **/
+    bool open(OpenMode mode, int *method, int *level, bool raw, const char *password =nullptr);
+    /// Opens a file for writing.
+    /** \a info argument specifies information about file. It should at
+     * least specify a correct file name. Also, it is a good idea to
+     * specify correct timestamp (by default, current time will be
+     * used). See QuaZipNewInfo.
+     *
+     * The \a password argument specifies the password for crypting. Pass NULL
+     * if you don't need any crypting. The \a crc argument was supposed
+     * to be used for crypting too, but then it turned out that it's
+     * false information, so you need to set it to 0 unless you want to
+     * use the raw mode (see below).
+     *
+     * Arguments \a method and \a level specify compression method and
+     * level. The only method supported is Z_DEFLATED, but you may also
+     * specify 0 for no compression. If all of the files in the archive
+     * use both method 0 and either level 0 is explicitly specified or
+     * data descriptor writing is disabled with
+     * QuaZip::setDataDescriptorWritingEnabled(), then the
+     * resulting archive is supposed to be compatible with the 1.0 ZIP
+     * format version, should you need that. Except for this, \a level
+     * has no other effects with method 0.
+     *
+     * If \a raw is \c true, no compression is performed. In this case,
+     * \a crc and uncompressedSize field of the \a info are required.
+     *
+     * Arguments \a windowBits, \a memLevel, \a strategy provide zlib
+     * algorithms tuning. See deflateInit2() in zlib.
+     **/
+    bool open(OpenMode mode, const QuaZipNewInfo& info,
+        const char *password =nullptr, quint32 crc =0,
+        int method =Z_DEFLATED, int level =Z_DEFAULT_COMPRESSION, bool raw =false,
+        int windowBits =-MAX_WBITS, int memLevel =DEF_MEM_LEVEL, int strategy =Z_DEFAULT_STRATEGY);
+    /// Returns \c true, but \ref quazipfile-sequential "beware"!
+    virtual bool isSequential()const;
+    /// Returns current position in the file.
+    /** Implementation of the QIODevice::pos(). When reading, this
+     * function is a wrapper to the ZIP/UNZIP unztell(), therefore it is
+     * unable to keep track of the ungetChar() calls (which is
+     * non-virtual and therefore is dangerous to reimplement). So if you
+     * are using ungetChar() feature of the QIODevice, this function
+     * reports incorrect value until you get back characters which you
+     * ungot.
+     *
+     * When writing, pos() returns number of bytes already written
+     * (uncompressed unless you use raw mode).
+     *
+     * \note Although
+     * \ref quazipfile-sequential "QuaZipFile is a sequential device"
+     * and therefore pos() should always return zero, it does not,
+     * because it would be misguiding. Keep this in mind.
+     *
+     * This function returns -1 if the file or archive is not open.
+     *
+     * Error code returned by getZipError() is not affected by this
+     * function call.
+     **/
+    virtual qint64 pos()const;
+    /// Returns \c true if the end of file was reached.
+    /** This function returns \c false in the case of error. This means
+     * that you called this function on either not open file, or a file
+     * in the not open archive or even on a QuaZipFile instance that
+     * does not even have QuaZip instance associated. Do not do that
+     * because there is no means to determine whether \c false is
+     * returned because of error or because end of file was reached.
+     * Well, on the other side you may interpret \c false return value
+     * as "there is no file open to check for end of file and there is
+     * no end of file therefore".
+     *
+     * When writing, this function always returns \c true (because you
+     * are always writing to the end of file).
+     *
+     * Error code returned by getZipError() is not affected by this
+     * function call.
+     **/
+    virtual bool atEnd()const;
+    /// Returns file size.
+    /** This function returns csize() if the file is open for reading in
+     * raw mode, usize() if it is open for reading in normal mode and
+     * pos() if it is open for writing.
+     *
+     * Returns -1 on error, call getZipError() to get error code.
+     *
+     * \note This function returns file size despite that
+     * \ref quazipfile-sequential "QuaZipFile is considered to be sequential device",
+     * for which size() should return bytesAvailable() instead. But its
+     * name would be very misguiding otherwise, so just keep in mind
+     * this inconsistence.
+     **/
+    virtual qint64 size()const;
+    /// Returns compressed file size.
+    /** Equivalent to calling getFileInfo() and then getting
+     * compressedSize field, but more convenient and faster.
+     *
+     * File must be open for reading before calling this function.
+     *
+     * Returns -1 on error, call getZipError() to get error code.
+     **/
+    qint64 csize()const;
+    /// Returns uncompressed file size.
+    /** Equivalent to calling getFileInfo() and then getting
+     * uncompressedSize field, but more convenient and faster. See
+     * getFileInfo() for a warning.
+     *
+     * File must be open for reading before calling this function.
+     *
+     * Returns -1 on error, call getZipError() to get error code.
+     **/
+    qint64 usize()const;
+    /// Gets information about current file.
+    /** This function does the same thing as calling
+     * QuaZip::getCurrentFileInfo() on the associated QuaZip object,
+     * but you can not call getCurrentFileInfo() if the associated
+     * QuaZip is internal (because you do not have access to it), while
+     * you still can call this function in that case.
+     *
+     * File must be open for reading before calling this function.
+     *
+     * \return \c false in the case of an error.
+     *
+     * This function doesn't support zip64, but will still work fine on zip64
+     * archives if file sizes are below 4 GB, otherwise the values will be set
+     * as if converted using QuaZipFileInfo64::toQuaZipFileInfo().
+     *
+     * \sa getFileInfo(QuaZipFileInfo64*)
+     **/
+    bool getFileInfo(QuaZipFileInfo *info);
+    /// Gets information about current file with zip64 support.
+    /**
+     * @overload
+     *
+     * \sa getFileInfo(QuaZipFileInfo*)
+     */
+    bool getFileInfo(QuaZipFileInfo64 *info);
+    /// Closes the file.
+    /** Call getZipError() to determine if the close was successful.
+     **/
+    virtual void close();
+    /// Returns the error code returned by the last ZIP/UNZIP API call.
+    int getZipError() const;
+    /// Returns the number of bytes available for reading.
+    virtual qint64 bytesAvailable() const;
+    /// Returns the local extra field
+    /**
+      There are two (optional) local extra fields associated with a file.
+      One is located in the central header and is available along
+      with the rest of the file information in @ref QuaZipFileInfo64::extra.
+      Another is located before the file itself,
+      and is returned by this function. The file must be open first.
+
+      @return the local extra field, or an empty array if there is none
+        (or file is not open)
+      */
+    QByteArray getLocalExtraField();
+    /// Returns the extended modification timestamp
+    /**
+    * The getExt*Time() functions only work if there is an extended timestamp
+    * extra field (ID 0x5455) present. Otherwise, they all return invalid null
+    * timestamps.
+    *
+    * Modification time, but not other times, can also be accessed through
+    * @ref QuaZipFileInfo64 without the need to open the file first.
+    *
+    * @sa dateTime
+    * @sa QuaZipFileInfo64::getExtModTime()
+    * @sa getExtAcTime()
+    * @sa getExtCrTime()
+    * @return The extended modification time, UTC
+    */
+    QDateTime getExtModTime();
+    /// Returns the extended access timestamp
+    /**
+    * The getExt*Time() functions only work if there is an extended timestamp
+    * extra field (ID 0x5455) present. Otherwise, they all return invalid null
+    * timestamps.
+    * @sa dateTime
+    * @sa QuaZipFileInfo64::getExtModTime()
+    * @sa getExtModTime()
+    * @sa getExtCrTime()
+    * @return The extended access time, UTC
+    */
+    QDateTime getExtAcTime();
+    /// Returns the extended creation timestamp
+    /**
+    * The getExt*Time() functions only work if there is an extended timestamp
+    * extra field (ID 0x5455) present. Otherwise, they all return invalid null
+    * timestamps.
+    * @sa dateTime
+    * @sa QuaZipFileInfo64::getExtModTime()
+    * @sa getExtModTime()
+    * @sa getExtAcTime()
+    * @return The extended creation time, UTC
+    */
+    QDateTime getExtCrTime();
+};
+
+#endif
diff -ruN ./quazipfileinfo.h ../../dep/quazip/quazip/quazipfileinfo.h
--- ./quazipfileinfo.h	2020-11-27 04:16:54.992498165 +0200
+++ ../../dep/quazip/quazip/quazipfileinfo.h	2020-11-27 04:08:04.065851277 +0200
@@ -1,66 +1,232 @@
-#ifndef QUA_ZIPFILEINFO_H
-#define QUA_ZIPFILEINFO_H
-
-/*
-Copyright (C) 2005-2011 Sergey A. Tachenov
-
-This program is free software; you can redistribute it and/or modify it
-under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation; either version 2 of the License, or (at
-your option) any later version.
-
-This program is distributed in the hope that it will be useful, but
-WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser
-General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this program; if not, write to the Free Software Foundation,
-Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
-
-See COPYING file for the full LGPL text.
-
-Original ZIP package is copyrighted by Gilles Vollant, see
-quazip/(un)zip.h files for details, basically it's zlib license.
- **/
-
-#include <QByteArray>
-#include <QDateTime>
-
-#include "quazip_global.h"
-
-/// Information about a file inside archive.
-/** Call QuaZip::getCurrentFileInfo() or QuaZipFile::getFileInfo() to
- * fill this structure. */
-struct QUAZIP_EXPORT QuaZipFileInfo {
-  /// File name.
-  QString name;
-  /// Version created by.
-  quint16 versionCreated;
-  /// Version needed to extract.
-  quint16 versionNeeded;
-  /// General purpose flags.
-  quint16 flags;
-  /// Compression method.
-  quint16 method;
-  /// Last modification date and time.
-  QDateTime dateTime;
-  /// CRC.
-  quint32 crc;
-  /// Compressed file size.
-  quint32 compressedSize;
-  /// Uncompressed file size.
-  quint32 uncompressedSize;
-  /// Disk number start.
-  quint16 diskNumberStart;
-  /// Internal file attributes.
-  quint16 internalAttr;
-  /// External file attributes.
-  quint32 externalAttr;
-  /// Comment.
-  QString comment;
-  /// Extra field.
-  QByteArray extra;
-};
-
-#endif
+#ifndef QUA_ZIPFILEINFO_H
+#define QUA_ZIPFILEINFO_H
+
+/*
+Copyright (C) 2005-2014 Sergey A. Tachenov
+
+This file is part of QuaZip.
+
+QuaZip is free software: you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation, either version 2.1 of the License, or
+(at your option) any later version.
+
+QuaZip is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with QuaZip.  If not, see <http://www.gnu.org/licenses/>.
+
+See COPYING file for the full LGPL text.
+
+Original ZIP package is copyrighted by Gilles Vollant and contributors,
+see quazip/(un)zip.h files for details. Basically it's the zlib license.
+*/
+
+#include <QtCore/QByteArray>
+#include <QtCore/QDateTime>
+#include <QtCore/QFile>
+#include <QtCore/QHash>
+
+#include "quazip_global.h"
+
+/// The typedef to store extra field parse results
+typedef QHash<quint16, QList<QByteArray> > QuaExtraFieldHash;
+
+/// Information about a file inside archive.
+/**
+ * \deprecated Use QuaZipFileInfo64 instead. Not only it supports large files,
+ * but also more convenience methods as well.
+ *
+ * Call QuaZip::getCurrentFileInfo() or QuaZipFile::getFileInfo() to
+ * fill this structure. */
+struct QUAZIP_EXPORT QuaZipFileInfo {
+  /// File name.
+  QString name;
+  /// Version created by.
+  quint16 versionCreated;
+  /// Version needed to extract.
+  quint16 versionNeeded;
+  /// General purpose flags.
+  quint16 flags;
+  /// Compression method.
+  quint16 method;
+  /// Last modification date and time.
+  QDateTime dateTime;
+  /// CRC.
+  quint32 crc;
+  /// Compressed file size.
+  quint32 compressedSize;
+  /// Uncompressed file size.
+  quint32 uncompressedSize;
+  /// Disk number start.
+  quint16 diskNumberStart;
+  /// Internal file attributes.
+  quint16 internalAttr;
+  /// External file attributes.
+  quint32 externalAttr;
+  /// Comment.
+  QString comment;
+  /// Extra field.
+  QByteArray extra;
+  /// Get the file permissions.
+  /**
+    Returns the high 16 bits of external attributes converted to
+    QFile::Permissions.
+    */
+  QFile::Permissions getPermissions() const;
+};
+
+/// Information about a file inside archive (with zip64 support).
+/** Call QuaZip::getCurrentFileInfo() or QuaZipFile::getFileInfo() to
+ * fill this structure. */
+struct QUAZIP_EXPORT QuaZipFileInfo64 {
+  /// File name.
+  QString name;
+  /// Version created by.
+  quint16 versionCreated;
+  /// Version needed to extract.
+  quint16 versionNeeded;
+  /// General purpose flags.
+  quint16 flags;
+  /// Compression method.
+  quint16 method;
+  /// Last modification date and time.
+  /**
+   * This is the time stored in the standard ZIP header. This format only allows
+   * to store time with 2-second precision, so the seconds will always be even
+   * and the milliseconds will always be zero. If you need more precise
+   * date and time, you can try to call the getNTFSmTime() function or
+   * its siblings, provided that the archive itself contains these NTFS times.
+   */
+  QDateTime dateTime;
+  /// CRC.
+  quint32 crc;
+  /// Compressed file size.
+  quint64 compressedSize;
+  /// Uncompressed file size.
+  quint64 uncompressedSize;
+  /// Disk number start.
+  quint16 diskNumberStart;
+  /// Internal file attributes.
+  quint16 internalAttr;
+  /// External file attributes.
+  quint32 externalAttr;
+  /// Comment.
+  QString comment;
+  /// Extra field.
+  QByteArray extra;
+  /// Get the file permissions.
+  /**
+    Returns the high 16 bits of external attributes converted to
+    QFile::Permissions.
+    */
+  QFile::Permissions getPermissions() const;
+  /// Checks whether the file is a symbolic link.
+  /**
+    Returns true iff the highest 16 bits of the external attributes
+    indicate that the file is a symbolic link according to Unix file mode.
+   */
+  bool isSymbolicLink() const;
+  /// Converts to QuaZipFileInfo
+  /**
+    If any of the fields are greater than 0xFFFFFFFFu, they are set to
+    0xFFFFFFFFu exactly, not just truncated. This function should be mainly used
+    for compatibility with the old code expecting QuaZipFileInfo, in the cases
+    when it's impossible or otherwise unadvisable (due to ABI compatibility
+    reasons, for example) to modify that old code to use QuaZipFileInfo64.
+
+    \return \c true if all fields converted correctly, \c false if an overflow
+    occured.
+    */
+  bool toQuaZipFileInfo(QuaZipFileInfo &info) const;
+  /// Returns the NTFS modification time
+  /**
+   * The getNTFS*Time() functions only work if there is an NTFS extra field
+   * present. Otherwise, they all return invalid null timestamps.
+   * @param fineTicks If not null, the fractional part of milliseconds returned
+   *                  there, measured in 100-nanosecond ticks. Will be set to
+   *                  zero if there is no NTFS extra field.
+   * @sa dateTime
+   * @sa getNTFSaTime()
+   * @sa getNTFScTime()
+   * @return The NTFS modification time, UTC
+   */
+  QDateTime getNTFSmTime(int *fineTicks = nullptr) const;
+  /// Returns the NTFS access time
+  /**
+   * The getNTFS*Time() functions only work if there is an NTFS extra field
+   * present. Otherwise, they all return invalid null timestamps.
+   * @param fineTicks If not null, the fractional part of milliseconds returned
+   *                  there, measured in 100-nanosecond ticks. Will be set to
+   *                  zero if there is no NTFS extra field.
+   * @sa dateTime
+   * @sa getNTFSmTime()
+   * @sa getNTFScTime()
+   * @return The NTFS access time, UTC
+   */
+  QDateTime getNTFSaTime(int *fineTicks = nullptr) const;
+  /// Returns the NTFS creation time
+  /**
+   * The getNTFS*Time() functions only work if there is an NTFS extra field
+   * present. Otherwise, they all return invalid null timestamps.
+   * @param fineTicks If not null, the fractional part of milliseconds returned
+   *                  there, measured in 100-nanosecond ticks. Will be set to
+   *                  zero if there is no NTFS extra field.
+   * @sa dateTime
+   * @sa getNTFSmTime()
+   * @sa getNTFSaTime()
+   * @return The NTFS creation time, UTC
+   */
+  QDateTime getNTFScTime(int *fineTicks = nullptr) const;
+  /// Returns the extended modification timestamp
+  /**
+   * The getExt*Time() functions only work if there is an extended timestamp
+   * extra field (ID 0x5455) present. Otherwise, they all return invalid null
+   * timestamps.
+   *
+   * QuaZipFileInfo64 only contains the modification time because it's extracted
+   * from @ref extra, which contains the global extra field, and access and
+   * creation time are in the local header which can be accessed through
+   * @ref QuaZipFile.
+   *
+   * @sa dateTime
+   * @sa QuaZipFile::getExtModTime()
+   * @sa QuaZipFile::getExtAcTime()
+   * @sa QuaZipFile::getExtCrTime()
+   * @return The extended modification time, UTC
+   */
+  QDateTime getExtModTime() const;
+  /// Checks whether the file is encrypted.
+  bool isEncrypted() const {return (flags & 1) != 0;}
+  /// Parses extra field
+  /**
+   * The returned hash table contains a list of data blocks for every header ID
+   * in the provided extra field. The number of data blocks in a hash table value
+   * equals to the number of occurrences of the appropriate header id. In most cases,
+   * a block with a specific header ID only occurs once, and therefore the returned
+   * hash table will contain a list consisting of a single element for that header ID.
+   *
+   * @param extraField extra field to parse
+   * @return header id to list of data block hash
+   */
+  static QuaExtraFieldHash parseExtraField(const QByteArray &extraField);
+  /// Extracts extended time from the extra field
+  /**
+   * Utility function used by various getExt*Time() functions, but can be used directly
+   * if the extra field is obtained elsewhere (from a third party library, for example).
+   *
+   * @param extra the extra field for a file
+   * @param flag 1 - modification time, 2 - access time, 4 - creation time
+   * @return the extracted time or null QDateTime if not present
+   * @sa getExtModTime()
+   * @sa QuaZipFile::getExtModTime()
+   * @sa QuaZipFile::getExtAcTime()
+   * @sa QuaZipFile::getExtCrTime()
+   */
+  static QDateTime getExtTime(const QByteArray &extra, int flag);
+};
+
+#endif
diff -ruN ./quazip_global.h ../../dep/quazip/quazip/quazip_global.h
--- ./quazip_global.h	2020-11-27 04:16:54.992498165 +0200
+++ ../../dep/quazip/quazip/quazip_global.h	2020-11-27 04:08:04.062517942 +0200
@@ -1,30 +1,31 @@
-/**
-Copyright (C) 2005-2011 Sergey A. Tachenov
+#ifndef QUAZIP_GLOBAL_H
+#define QUAZIP_GLOBAL_H
+
+/*
+Copyright (C) 2005-2014 Sergey A. Tachenov
+
+This file is part of QuaZip.
 
-This program is free software; you can redistribute it and/or modify it
-under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation; either version 2 of the License, or (at
-your option) any later version.
-
-This program is distributed in the hope that it will be useful, but
-WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser
-General Public License for more details.
+QuaZip is free software: you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation, either version 2.1 of the License, or
+(at your option) any later version.
+
+QuaZip is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public License
-along with this program; if not, write to the Free Software Foundation,
-Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+along with QuaZip.  If not, see <http://www.gnu.org/licenses/>.
 
 See COPYING file for the full LGPL text.
 
-Original ZIP package is copyrighted by Gilles Vollant, see
-quazip/(un)zip.h files for details, basically it's zlib license.
- */
+Original ZIP package is copyrighted by Gilles Vollant and contributors,
+see quazip/(un)zip.h files for details. Basically it's the zlib license.
+*/
 
-#ifndef QUAZIP_GLOBAL_H
-#define QUAZIP_GLOBAL_H
-
-#include <QtCore/qglobal.h>
+#include <QtCore/QtGlobal>
 
 /**
   This is automatically defined when building a static library, but when
@@ -47,9 +48,16 @@
 #endif // QUAZIP_STATIC
 
 #ifdef __GNUC__
-#define UNUSED __attribute__((__unused__))
+#define QUAZIP_UNUSED __attribute__((__unused__))
 #else
-#define UNUSED
+#define QUAZIP_UNUSED
 #endif
 
+#define QUAZIP_EXTRA_NTFS_MAGIC 0x000Au
+#define QUAZIP_EXTRA_NTFS_TIME_MAGIC 0x0001u
+#define QUAZIP_EXTRA_EXT_TIME_MAGIC 0x5455u
+#define QUAZIP_EXTRA_EXT_MOD_TIME_FLAG 1
+#define QUAZIP_EXTRA_EXT_AC_TIME_FLAG 2
+#define QUAZIP_EXTRA_EXT_CR_TIME_FLAG 4
+
 #endif // QUAZIP_GLOBAL_H
diff -ruN ./quazip.h ../../dep/quazip/quazip/quazip.h
--- ./quazip.h	2020-11-27 04:16:54.992498165 +0200
+++ ../../dep/quazip/quazip/quazip.h	2020-11-27 04:08:04.062517942 +0200
@@ -1,406 +1,611 @@
-#ifndef QUA_ZIP_H
-#define QUA_ZIP_H
-
-/*
-Copyright (C) 2005-2011 Sergey A. Tachenov
-
-This program is free software; you can redistribute it and/or modify it
-under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation; either version 2 of the License, or (at
-your option) any later version.
-
-This program is distributed in the hope that it will be useful, but
-WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser
-General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this program; if not, write to the Free Software Foundation,
-Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
-
-See COPYING file for the full LGPL text.
-
-Original ZIP package is copyrighted by Gilles Vollant, see
-quazip/(un)zip.h files for details, basically it's zlib license.
- **/
-
-#include <QString>
-#include <QStringList>
-#include <QTextCodec>
-
-#include "zip.h"
-#include "unzip.h"
-
-#include "quazip_global.h"
-#include "quazipfileinfo.h"
-
-// just in case it will be defined in the later versions of the ZIP/UNZIP
-#ifndef UNZ_OPENERROR
-// define additional error code
-#define UNZ_OPENERROR -1000
-#endif
-
-class QuaZipPrivate;
-
-/// ZIP archive.
-/** \class QuaZip quazip.h <quazip/quazip.h>
- * This class implements basic interface to the ZIP archive. It can be
- * used to read table contents of the ZIP archive and retreiving
- * information about the files inside it.
- *
- * You can also use this class to open files inside archive by passing
- * pointer to the instance of this class to the constructor of the
- * QuaZipFile class. But see QuaZipFile::QuaZipFile(QuaZip*, QObject*)
- * for the possible pitfalls.
- *
- * This class is indended to provide interface to the ZIP subpackage of
- * the ZIP/UNZIP package as well as to the UNZIP subpackage. But
- * currently it supports only UNZIP.
- *
- * The use of this class is simple - just create instance using
- * constructor, then set ZIP archive file name using setFile() function
- * (if you did not passed the name to the constructor), then open() and
- * then use different functions to work with it! Well, if you are
- * paranoid, you may also wish to call close before destructing the
- * instance, to check for errors on close.
- *
- * You may also use getUnzFile() and getZipFile() functions to get the
- * ZIP archive handle and use it with ZIP/UNZIP package API directly.
- *
- * This class supports localized file names inside ZIP archive, but you
- * have to set up proper codec with setCodec() function. By default,
- * locale codec will be used, which is probably ok for UNIX systems, but
- * will almost certainly fail with ZIP archives created in Windows. This
- * is because Windows ZIP programs have strange habit of using DOS
- * encoding for file names in ZIP archives. For example, ZIP archive
- * with cyrillic names created in Windows will have file names in \c
- * IBM866 encoding instead of \c WINDOWS-1251. I think that calling one
- * function is not much trouble, but for true platform independency it
- * would be nice to have some mechanism for file name encoding auto
- * detection using locale information. Does anyone know a good way to do
- * it?
- **/
-class QUAZIP_EXPORT QuaZip {
-  friend class QuaZipPrivate;
-  public:
-    /// Useful constants.
-    enum Constants {
-      MAX_FILE_NAME_LENGTH=256 /**< Maximum file name length. Taken from
-                                 \c UNZ_MAXFILENAMEINZIP constant in
-                                 unzip.c. */
-    };
-    /// Open mode of the ZIP file.
-    enum Mode {
-      mdNotOpen, ///< ZIP file is not open. This is the initial mode.
-      mdUnzip, ///< ZIP file is open for reading files inside it.
-      mdCreate, ///< ZIP file was created with open() call.
-      mdAppend, /**< ZIP file was opened in append mode. This refers to
-                  * \c APPEND_STATUS_CREATEAFTER mode in ZIP/UNZIP package
-                  * and means that zip is appended to some existing file
-                  * what is useful when that file contains
-                  * self-extractor code. This is obviously \em not what
-                  * you whant to use to add files to the existing ZIP
-                  * archive.
-                  **/
-      mdAdd ///< ZIP file was opened for adding files in the archive.
-    };
-    /// Case sensitivity for the file names.
-    /** This is what you specify when accessing files in the archive.
-     * Works perfectly fine with any characters thanks to Qt's great
-     * unicode support. This is different from ZIP/UNZIP API, where
-     * only US-ASCII characters was supported.
-     **/
-    enum CaseSensitivity {
-      csDefault=0, ///< Default for platform. Case sensitive for UNIX, not for Windows.
-      csSensitive=1, ///< Case sensitive.
-      csInsensitive=2 ///< Case insensitive.
-    };
-  private:
-    QuaZipPrivate *p;
-    // not (and will not be) implemented
-    QuaZip(const QuaZip& that);
-    // not (and will not be) implemented
-    QuaZip& operator=(const QuaZip& that);
-  public:
-    /// Constructs QuaZip object.
-    /** Call setName() before opening constructed object. */
-    QuaZip();
-    /// Constructs QuaZip object associated with ZIP file \a zipName.
-    QuaZip(const QString& zipName);
-    /// Constructs QuaZip object associated with ZIP file represented by \a ioDevice.
-    /** The IO device must be seekable, otherwise an error will occur when opening. */
-    QuaZip(QIODevice *ioDevice);
-    /// Destroys QuaZip object.
-    /** Calls close() if necessary. */
-    ~QuaZip();
-    /// Opens ZIP file.
-    /**
-     * Argument \a mode specifies open mode of the ZIP archive. See Mode
-     * for details. Note that there is zipOpen2() function in the
-     * ZIP/UNZIP API which accepts \a globalcomment argument, but it
-     * does not use it anywhere, so this open() function does not have this
-     * argument. See setComment() if you need to set global comment.
-     *
-     * If the ZIP file is accessed via explicitly set QIODevice, then
-     * this device is opened in the necessary mode. If the device was
-     * already opened by some other means, then the behaviour is defined by
-     * the device implementation, but generally it is not a very good
-     * idea. For example, QFile will at least issue a warning.
-     *
-     * \return \c true if successful, \c false otherwise.
-     *
-     * \note ZIP/UNZIP API open calls do not return error code - they
-     * just return \c NULL indicating an error. But to make things
-     * easier, quazip.h header defines additional error code \c
-     * UNZ_ERROROPEN and getZipError() will return it if the open call
-     * of the ZIP/UNZIP API returns \c NULL.
-     *
-     * Argument \a ioApi specifies IO function set for ZIP/UNZIP
-     * package to use. See unzip.h, zip.h and ioapi.h for details. Note
-     * that IO API for QuaZip is different from the original package.
-     * The file path argument was changed to be of type \c voidpf, and
-     * QuaZip passes a QIODevice pointer there. This QIODevice is either
-     * set explicitly via setIoDevice() or the QuaZip(QIODevice*)
-     * constructor, or it is created internally when opening the archive
-     * by its file name. The default API (qioapi.cpp) just delegates
-     * everything to the QIODevice API. Not only this allows to use a
-     * QIODevice instead of file name, but also has a nice side effect
-     * of raising the file size limit from 2G to 4G.
-     *
-     * In short: just forget about the \a ioApi argument and you'll be
-     * fine.
-     **/
-    bool open(Mode mode, zlib_filefunc_def *ioApi =NULL);
-    /// Closes ZIP file.
-    /** Call getZipError() to determine if the close was successful. The
-     * underlying QIODevice is also closed, regardless of whether it was
-     * set explicitly or not. */
-    void close();
-    /// Sets the codec used to encode/decode file names inside archive.
-    /** This is necessary to access files in the ZIP archive created
-     * under Windows with non-latin characters in file names. For
-     * example, file names with cyrillic letters will be in \c IBM866
-     * encoding.
-     **/
-    void setFileNameCodec(QTextCodec *fileNameCodec);
-    /// Sets the codec used to encode/decode file names inside archive.
-    /** \overload
-     * Equivalent to calling setFileNameCodec(QTextCodec::codecForName(codecName));
-     **/
-    void setFileNameCodec(const char *fileNameCodecName);
-    /// Returns the codec used to encode/decode comments inside archive.
-    QTextCodec* getFileNameCodec() const;
-    /// Sets the codec used to encode/decode comments inside archive.
-    /** This codec defaults to locale codec, which is probably ok.
-     **/
-    void setCommentCodec(QTextCodec *commentCodec);
-    /// Sets the codec used to encode/decode comments inside archive.
-    /** \overload
-     * Equivalent to calling setCommentCodec(QTextCodec::codecForName(codecName));
-     **/
-    void setCommentCodec(const char *commentCodecName);
-    /// Returns the codec used to encode/decode comments inside archive.
-    QTextCodec* getCommentCodec() const;
-    /// Returns the name of the ZIP file.
-    /** Returns null string if no ZIP file name has been set, for
-     * example when the QuaZip instance is set up to use a QIODevice
-     * instead.
-     * \sa setZipName(), setIoDevice(), getIoDevice()
-     **/
-    QString getZipName() const;
-    /// Sets the name of the ZIP file.
-    /** Does nothing if the ZIP file is open.
-     *
-     * Does not reset error code returned by getZipError().
-     * \sa setIoDevice(), getIoDevice(), getZipName()
-     **/
-    void setZipName(const QString& zipName);
-    /// Returns the device representing this ZIP file.
-    /** Returns null string if no device has been set explicitly, for
-     * example when opening a ZIP file by name.
-     * \sa setIoDevice(), getZipName(), setZipName()
-     **/
-    QIODevice *getIoDevice() const;
-    /// Sets the device representing the ZIP file.
-    /** Does nothing if the ZIP file is open.
-     *
-     * Does not reset error code returned by getZipError().
-     * \sa getIoDevice(), getZipName(), setZipName()
-     **/
-    void setIoDevice(QIODevice *ioDevice);
-    /// Returns the mode in which ZIP file was opened.
-    Mode getMode() const;
-    /// Returns \c true if ZIP file is open, \c false otherwise.
-    bool isOpen() const;
-    /// Returns the error code of the last operation.
-    /** Returns \c UNZ_OK if the last operation was successful.
-     *
-     * Error code resets to \c UNZ_OK every time you call any function
-     * that accesses something inside ZIP archive, even if it is \c
-     * const (like getEntriesCount()). open() and close() calls reset
-     * error code too. See documentation for the specific functions for
-     * details on error detection.
-     **/
-    int getZipError() const;
-    /// Returns number of the entries in the ZIP central directory.
-    /** Returns negative error code in the case of error. The same error
-     * code will be returned by subsequent getZipError() call.
-     **/
-    int getEntriesCount() const;
-    /// Returns global comment in the ZIP file.
-    QString getComment() const;
-    /// Sets global comment in the ZIP file.
-    /** Comment will be written to the archive on close operation.
-     *
-     * \sa open()
-     **/
-    void setComment(const QString& comment);
-    /// Sets the current file to the first file in the archive.
-    /** Returns \c true on success, \c false otherwise. Call
-     * getZipError() to get the error code.
-     **/
-    bool goToFirstFile();
-    /// Sets the current file to the next file in the archive.
-    /** Returns \c true on success, \c false otherwise. Call
-     * getZipError() to determine if there was an error.
-     *
-     * Should be used only in QuaZip::mdUnzip mode.
-     *
-     * \note If the end of file was reached, getZipError() will return
-     * \c UNZ_OK instead of \c UNZ_END_OF_LIST_OF_FILE. This is to make
-     * things like this easier:
-     * \code
-     * for(bool more=zip.goToFirstFile(); more; more=zip.goToNextFile()) {
-     *   // do something
-     * }
-     * if(zip.getZipError()==UNZ_OK) {
-     *   // ok, there was no error
-     * }
-     * \endcode
-     **/
-    bool goToNextFile();
-    /// Sets current file by its name.
-    /** Returns \c true if successful, \c false otherwise. Argument \a
-     * cs specifies case sensitivity of the file name. Call
-     * getZipError() in the case of a failure to get error code.
-     *
-     * This is not a wrapper to unzLocateFile() function. That is
-     * because I had to implement locale-specific case-insensitive
-     * comparison.
-     *
-     * Here are the differences from the original implementation:
-     *
-     * - If the file was not found, error code is \c UNZ_OK, not \c
-     *   UNZ_END_OF_LIST_OF_FILE (see also goToNextFile()).
-     * - If this function fails, it unsets the current file rather than
-     *   resetting it back to what it was before the call.
-     *
-     * If \a fileName is null string then this function unsets the
-     * current file and return \c true. Note that you should close the
-     * file first if it is open! See
-     * QuaZipFile::QuaZipFile(QuaZip*,QObject*) for the details.
-     *
-     * Should be used only in QuaZip::mdUnzip mode.
-     *
-     * \sa setFileNameCodec(), CaseSensitivity
-     **/
-    bool setCurrentFile(const QString& fileName, CaseSensitivity cs =csDefault);
-    /// Returns \c true if the current file has been set.
-    bool hasCurrentFile() const;
-    /// Retrieves information about the current file.
-    /** Fills the structure pointed by \a info. Returns \c true on
-     * success, \c false otherwise. In the latter case structure pointed
-     * by \a info remains untouched. If there was an error,
-     * getZipError() returns error code.
-     *
-     * Should be used only in QuaZip::mdUnzip mode.
-     *
-     * Does nothing and returns \c false in any of the following cases.
-     * - ZIP is not open;
-     * - ZIP does not have current file;
-     * - \a info is \c NULL;
-     *
-     * In all these cases getZipError() returns \c UNZ_OK since there
-     * is no ZIP/UNZIP API call.
-     **/
-    bool getCurrentFileInfo(QuaZipFileInfo* info)const;
-    /// Returns the current file name.
-    /** Equivalent to calling getCurrentFileInfo() and then getting \c
-     * name field of the QuaZipFileInfo structure, but faster and more
-     * convenient.
-     *
-     * Should be used only in QuaZip::mdUnzip mode.
-     **/
-    QString getCurrentFileName()const;
-    /// Returns \c unzFile handle.
-    /** You can use this handle to directly call UNZIP part of the
-     * ZIP/UNZIP package functions (see unzip.h).
-     *
-     * \warning When using the handle returned by this function, please
-     * keep in mind that QuaZip class is unable to detect any changes
-     * you make in the ZIP file state (e. g. changing current file, or
-     * closing the handle). So please do not do anything with this
-     * handle that is possible to do with the functions of this class.
-     * Or at least return the handle in the original state before
-     * calling some another function of this class (including implicit
-     * destructor calls and calls from the QuaZipFile objects that refer
-     * to this QuaZip instance!). So if you have changed the current
-     * file in the ZIP archive - then change it back or you may
-     * experience some strange behavior or even crashes.
-     **/
-    unzFile getUnzFile();
-    /// Returns \c zipFile handle.
-    /** You can use this handle to directly call ZIP part of the
-     * ZIP/UNZIP package functions (see zip.h). Warnings about the
-     * getUnzFile() function also apply to this function.
-     **/
-    zipFile getZipFile();
-    /// Changes the data descriptor writing mode.
-    /**
-      According to the ZIP format specification, a file inside archive
-      may have a data descriptor immediately following the file
-      data. This is reflected by a special flag in the local file header
-      and in the central directory. By default, QuaZIP sets this flag
-      and writes the data descriptor unless both method and level were
-      set to 0, in which case it operates in 1.0-compatible mode and
-      never writes data descriptors.
-
-      By setting this flag to false, it is possible to disable data
-      descriptor writing, thus increasing compatibility with archive
-      readers that don't understand this feature of the ZIP file format.
-
-      Setting this flag affects all the QuaZipFile instances that are
-      opened after this flag is set.
-
-      The data descriptor writing mode is enabled by default.
-
-      \param enabled If \c true, enable local descriptor writing,
-      disable it otherwise.
-
-      \sa QuaZipFile::setDataDescriptorWritingEnabled()
-      */
-    void setDataDescriptorWritingEnabled(bool enabled);
-    /// Returns the data descriptor default writing mode.
-    /**
-      \sa setDataDescriptorWritingEnabled()
-      */
-    bool isDataDescriptorWritingEnabled() const;
-    /// Returns a list of files inside the archive.
-    /**
-      \return A list of file names or an empty list if there
-      was an error or if the archive is empty (call getZipError() to
-      figure out which).
-      \sa getFileInfoList()
-      */
-    QStringList getFileNameList() const;
-    /// Returns information list about all files inside the archive.
-    /**
-      \return A list of QuaZipFileInfo objects or an empty list if there
-      was an error or if the archive is empty (call getZipError() to
-      figure out which).
-      \sa getFileNameList()
-      */
-    QList<QuaZipFileInfo> getFileInfoList() const;
-};
-
-#endif
+#ifndef QUA_ZIP_H
+#define QUA_ZIP_H
+
+/*
+Copyright (C) 2005-2014 Sergey A. Tachenov
+
+This file is part of QuaZip.
+
+QuaZip is free software: you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation, either version 2.1 of the License, or
+(at your option) any later version.
+
+QuaZip is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with QuaZip.  If not, see <http://www.gnu.org/licenses/>.
+
+See COPYING file for the full LGPL text.
+
+Original ZIP package is copyrighted by Gilles Vollant, see
+quazip/(un)zip.h files for details, basically it's zlib license.
+ **/
+
+#include <QtCore/QString>
+#include <QtCore/QStringList>
+#include "quazip_qt_compat.h"
+
+#include "zip.h"
+#include "unzip.h"
+
+#include "quazip_global.h"
+#include "quazipfileinfo.h"
+
+// just in case it will be defined in the later versions of the ZIP/UNZIP
+#ifndef UNZ_OPENERROR
+// define additional error code
+#define UNZ_OPENERROR -1000
+#endif
+
+class QuaZipPrivate;
+
+/// ZIP archive.
+/** \class QuaZip quazip.h <quazip/quazip.h>
+ * This class implements basic interface to the ZIP archive. It can be
+ * used to read table contents of the ZIP archive and retreiving
+ * information about the files inside it.
+ *
+ * You can also use this class to open files inside archive by passing
+ * pointer to the instance of this class to the constructor of the
+ * QuaZipFile class. But see QuaZipFile::QuaZipFile(QuaZip*, QObject*)
+ * for the possible pitfalls.
+ *
+ * This class is indended to provide interface to the ZIP subpackage of
+ * the ZIP/UNZIP package as well as to the UNZIP subpackage. But
+ * currently it supports only UNZIP.
+ *
+ * The use of this class is simple - just create instance using
+ * constructor, then set ZIP archive file name using setFile() function
+ * (if you did not passed the name to the constructor), then open() and
+ * then use different functions to work with it! Well, if you are
+ * paranoid, you may also wish to call close before destructing the
+ * instance, to check for errors on close.
+ *
+ * You may also use getUnzFile() and getZipFile() functions to get the
+ * ZIP archive handle and use it with ZIP/UNZIP package API directly.
+ *
+ * This class supports localized file names inside ZIP archive, but you
+ * have to set up proper codec with setCodec() function. By default,
+ * locale codec will be used, which is probably ok for UNIX systems, but
+ * will almost certainly fail with ZIP archives created in Windows. This
+ * is because Windows ZIP programs have strange habit of using DOS
+ * encoding for file names in ZIP archives. For example, ZIP archive
+ * with cyrillic names created in Windows will have file names in \c
+ * IBM866 encoding instead of \c WINDOWS-1251. I think that calling one
+ * function is not much trouble, but for true platform independency it
+ * would be nice to have some mechanism for file name encoding auto
+ * detection using locale information. Does anyone know a good way to do
+ * it?
+ **/
+class QUAZIP_EXPORT QuaZip {
+  friend class QuaZipPrivate;
+  public:
+    /// Useful constants.
+    enum Constants {
+      MAX_FILE_NAME_LENGTH=256 /**< Maximum file name length. Taken from
+                                 \c UNZ_MAXFILENAMEINZIP constant in
+                                 unzip.c. */
+    };
+    /// Open mode of the ZIP file.
+    enum Mode {
+      mdNotOpen, ///< ZIP file is not open. This is the initial mode.
+      mdUnzip, ///< ZIP file is open for reading files inside it.
+      mdCreate, ///< ZIP file was created with open() call.
+      mdAppend, /**< ZIP file was opened in append mode. This refers to
+                  * \c APPEND_STATUS_CREATEAFTER mode in ZIP/UNZIP package
+                  * and means that zip is appended to some existing file
+                  * what is useful when that file contains
+                  * self-extractor code. This is obviously \em not what
+                  * you whant to use to add files to the existing ZIP
+                  * archive.
+                  **/
+      mdAdd ///< ZIP file was opened for adding files in the archive.
+    };
+    /// Case sensitivity for the file names.
+    /** This is what you specify when accessing files in the archive.
+     * Works perfectly fine with any characters thanks to Qt's great
+     * unicode support. This is different from ZIP/UNZIP API, where
+     * only US-ASCII characters was supported.
+     **/
+    enum CaseSensitivity {
+      csDefault=0, ///< Default for platform. Case sensitive for UNIX, not for Windows.
+      csSensitive=1, ///< Case sensitive.
+      csInsensitive=2 ///< Case insensitive.
+    };
+    /// Returns the actual case sensitivity for the specified QuaZip one.
+    /**
+      \param cs The value to convert.
+      \returns If CaseSensitivity::csDefault, then returns the default
+      file name case sensitivity for the platform. Otherwise, just
+      returns the appropriate value from the Qt::CaseSensitivity enum.
+      */
+    static Qt::CaseSensitivity convertCaseSensitivity(
+            CaseSensitivity cs);
+  private:
+    QuaZipPrivate *p;
+    // not (and will not be) implemented
+    QuaZip(const QuaZip& that);
+    // not (and will not be) implemented
+    QuaZip& operator=(const QuaZip& that);
+  public:
+    /// Constructs QuaZip object.
+    /** Call setName() before opening constructed object. */
+    QuaZip();
+    /// Constructs QuaZip object associated with ZIP file \a zipName.
+    QuaZip(const QString& zipName);
+    /// Constructs QuaZip object associated with ZIP file represented by \a ioDevice.
+    /** The IO device must be seekable, otherwise an error will occur when opening. */
+    QuaZip(QIODevice *ioDevice);
+    /// Destroys QuaZip object.
+    /** Calls close() if necessary. */
+    ~QuaZip();
+    /// Opens ZIP file.
+    /**
+     * Argument \a mode specifies open mode of the ZIP archive. See Mode
+     * for details. Note that there is zipOpen2() function in the
+     * ZIP/UNZIP API which accepts \a globalcomment argument, but it
+     * does not use it anywhere, so this open() function does not have this
+     * argument. See setComment() if you need to set global comment.
+     *
+     * If the ZIP file is accessed via explicitly set QIODevice, then
+     * this device is opened in the necessary mode. If the device was
+     * already opened by some other means, then QuaZip checks if the
+     * open mode is compatible to the mode needed for the requested operation.
+     * If necessary, seeking is performed to position the device properly.
+     *
+     * \return \c true if successful, \c false otherwise.
+     *
+     * \note ZIP/UNZIP API open calls do not return error code - they
+     * just return \c null indicating an error. But to make things
+     * easier, quazip.h header defines additional error code \c
+     * UNZ_ERROROPEN and getZipError() will return it if the open call
+     * of the ZIP/UNZIP API returns \c null.
+     *
+     * Argument \a ioApi specifies IO function set for ZIP/UNZIP
+     * package to use. See unzip.h, zip.h and ioapi.h for details. Note
+     * that IO API for QuaZip is different from the original package.
+     * The file path argument was changed to be of type \c voidpf, and
+     * QuaZip passes a QIODevice pointer there. This QIODevice is either
+     * set explicitly via setIoDevice() or the QuaZip(QIODevice*)
+     * constructor, or it is created internally when opening the archive
+     * by its file name. The default API (qioapi.cpp) just delegates
+     * everything to the QIODevice API. Not only this allows to use a
+     * QIODevice instead of file name, but also has a nice side effect
+     * of raising the file size limit from 2G to 4G (in non-zip64 archives).
+     *
+     * \note If the zip64 support is needed, the ioApi argument \em must be null
+     * because due to the backwards compatibility issues it can be used to
+     * provide a 32-bit API only.
+     *
+     * \note If the \ref QuaZip::setAutoClose() "no-auto-close" feature is used,
+     * then the \a ioApi argument \em should be null because the old API
+     * doesn't support the 'fake close' operation, causing slight memory leaks
+     * and other possible troubles (like closing the output device in case
+     * when an error occurs during opening).
+     *
+     * In short: just forget about the \a ioApi argument and you'll be
+     * fine.
+     **/
+    bool open(Mode mode, zlib_filefunc_def *ioApi =nullptr);
+    /// Closes ZIP file.
+    /** Call getZipError() to determine if the close was successful.
+     *
+     * If the file was opened by name, then the underlying QIODevice is closed
+     * and deleted.
+     *
+     * If the underlying QIODevice was set explicitly using setIoDevice() or
+     * the appropriate constructor, then it is closed if the auto-close flag
+     * is set (which it is by default). Call setAutoClose() to clear the
+     * auto-close flag if this behavior is undesirable.
+     *
+     * Since Qt 5.1, the QSaveFile was introduced. It breaks the QIODevice API
+     * by making close() private and crashing the application if it is called
+     * from the base class where it is public. It is an excellent example
+     * of poor design that illustrates why you should never ever break
+     * an is-a relationship between the base class and a subclass. QuaZip
+     * works around this bug by checking if the QIODevice is an instance
+     * of QSaveFile, using qobject_cast<>, and if it is, calls
+     * QSaveFile::commit() instead of close(). It is a really ugly hack,
+     * but at least it makes your programs work instead of crashing. Note that
+     * if the auto-close flag is cleared, then this is a non-issue, and
+     * commit() isn't called.
+      */
+    void close();
+    /// Sets the codec used to encode/decode file names inside archive.
+    /** This is necessary to access files in the ZIP archive created
+     * under Windows with non-latin characters in file names. For
+     * example, file names with cyrillic letters will be in \c IBM866
+     * encoding.
+     **/
+    void setFileNameCodec(QTextCodec *fileNameCodec);
+    /// Sets the codec used to encode/decode file names inside archive.
+    /** \overload
+     * Equivalent to calling setFileNameCodec(QTextCodec::codecForName(codecName));
+     **/
+    void setFileNameCodec(const char *fileNameCodecName);
+    /// Sets the OS code (highest 8 bits of the “version made by” field) for new files.
+    /** There is currently no way to specify this for each file individually,
+        except by calling this function before opening each file. If this function is not called,
+        then the default OS code will be used. The default code is set by calling
+        setDefaultOsCode(). The default value at the moment of QuaZip creation will be used. */
+    void setOsCode(uint osCode);
+    /// Returns the OS code for new files.
+    uint getOsCode() const;
+    /// Returns the codec used to encode/decode comments inside archive.
+    QTextCodec* getFileNameCodec() const;
+    /// Sets the codec used to encode/decode comments inside archive.
+    /** This codec defaults to locale codec, which is probably ok.
+     **/
+    void setCommentCodec(QTextCodec *commentCodec);
+    /// Sets the codec used to encode/decode comments inside archive.
+    /** \overload
+     * Equivalent to calling setCommentCodec(QTextCodec::codecForName(codecName));
+     **/
+    void setCommentCodec(const char *commentCodecName);
+    /// Returns the codec used to encode/decode comments inside archive.
+    QTextCodec* getCommentCodec() const;
+    /// Returns the name of the ZIP file.
+    /** Returns null string if no ZIP file name has been set, for
+     * example when the QuaZip instance is set up to use a QIODevice
+     * instead.
+     * \sa setZipName(), setIoDevice(), getIoDevice()
+     **/
+    QString getZipName() const;
+    /// Sets the name of the ZIP file.
+    /** Does nothing if the ZIP file is open.
+     *
+     * Does not reset error code returned by getZipError().
+     * \sa setIoDevice(), getIoDevice(), getZipName()
+     **/
+    void setZipName(const QString& zipName);
+    /// Returns the device representing this ZIP file.
+    /** Returns null string if no device has been set explicitly, for
+     * example when opening a ZIP file by name.
+     * \sa setIoDevice(), getZipName(), setZipName()
+     **/
+    QIODevice *getIoDevice() const;
+    /// Sets the device representing the ZIP file.
+    /** Does nothing if the ZIP file is open.
+     *
+     * Does not reset error code returned by getZipError().
+     * \sa getIoDevice(), getZipName(), setZipName()
+     **/
+    void setIoDevice(QIODevice *ioDevice);
+    /// Returns the mode in which ZIP file was opened.
+    Mode getMode() const;
+    /// Returns \c true if ZIP file is open, \c false otherwise.
+    bool isOpen() const;
+    /// Returns the error code of the last operation.
+    /** Returns \c UNZ_OK if the last operation was successful.
+     *
+     * Error code resets to \c UNZ_OK every time you call any function
+     * that accesses something inside ZIP archive, even if it is \c
+     * const (like getEntriesCount()). open() and close() calls reset
+     * error code too. See documentation for the specific functions for
+     * details on error detection.
+     **/
+    int getZipError() const;
+    /// Returns number of the entries in the ZIP central directory.
+    /** Returns negative error code in the case of error. The same error
+     * code will be returned by subsequent getZipError() call.
+     **/
+    int getEntriesCount() const;
+    /// Returns global comment in the ZIP file.
+    QString getComment() const;
+    /// Sets the global comment in the ZIP file.
+    /** The comment will be written to the archive on close operation.
+     * QuaZip makes a distinction between a null QByteArray() comment 
+     * and an empty &quot;&quot; comment in the QuaZip::mdAdd mode. 
+     * A null comment is the default and it means &quot;don't change 
+     * the comment&quot;. An empty comment removes the original comment.
+     *
+     * \sa open()
+     **/
+    void setComment(const QString& comment);
+    /// Sets the current file to the first file in the archive.
+    /** Returns \c true on success, \c false otherwise. Call
+     * getZipError() to get the error code.
+     **/
+    bool goToFirstFile();
+    /// Sets the current file to the next file in the archive.
+    /** Returns \c true on success, \c false otherwise. Call
+     * getZipError() to determine if there was an error.
+     *
+     * Should be used only in QuaZip::mdUnzip mode.
+     *
+     * \note If the end of file was reached, getZipError() will return
+     * \c UNZ_OK instead of \c UNZ_END_OF_LIST_OF_FILE. This is to make
+     * things like this easier:
+     * \code
+     * for(bool more=zip.goToFirstFile(); more; more=zip.goToNextFile()) {
+     *   // do something
+     * }
+     * if(zip.getZipError()==UNZ_OK) {
+     *   // ok, there was no error
+     * }
+     * \endcode
+     **/
+    bool goToNextFile();
+    /// Sets current file by its name.
+    /** Returns \c true if successful, \c false otherwise. Argument \a
+     * cs specifies case sensitivity of the file name. Call
+     * getZipError() in the case of a failure to get error code.
+     *
+     * This is not a wrapper to unzLocateFile() function. That is
+     * because I had to implement locale-specific case-insensitive
+     * comparison.
+     *
+     * Here are the differences from the original implementation:
+     *
+     * - If the file was not found, error code is \c UNZ_OK, not \c
+     *   UNZ_END_OF_LIST_OF_FILE (see also goToNextFile()).
+     * - If this function fails, it unsets the current file rather than
+     *   resetting it back to what it was before the call.
+     *
+     * If \a fileName is null string then this function unsets the
+     * current file and return \c true. Note that you should close the
+     * file first if it is open! See
+     * QuaZipFile::QuaZipFile(QuaZip*,QObject*) for the details.
+     *
+     * Should be used only in QuaZip::mdUnzip mode.
+     *
+     * \sa setFileNameCodec(), CaseSensitivity
+     **/
+    bool setCurrentFile(const QString& fileName, CaseSensitivity cs =csDefault);
+    /// Returns \c true if the current file has been set.
+    bool hasCurrentFile() const;
+    /// Retrieves information about the current file.
+    /** Fills the structure pointed by \a info. Returns \c true on
+     * success, \c false otherwise. In the latter case structure pointed
+     * by \a info remains untouched. If there was an error,
+     * getZipError() returns error code.
+     *
+     * Should be used only in QuaZip::mdUnzip mode.
+     *
+     * Does nothing and returns \c false in any of the following cases.
+     * - ZIP is not open;
+     * - ZIP does not have current file.
+     *
+     * In both cases getZipError() returns \c UNZ_OK since there
+     * is no ZIP/UNZIP API call.
+     *
+     * This overload doesn't support zip64, but will work OK on zip64 archives
+     * except that if one of the sizes (compressed or uncompressed) is greater
+     * than 0xFFFFFFFFu, it will be set to exactly 0xFFFFFFFFu.
+     *
+     * \sa getCurrentFileInfo(QuaZipFileInfo64* info)const
+     * \sa QuaZipFileInfo64::toQuaZipFileInfo(QuaZipFileInfo&)const
+     **/
+    bool getCurrentFileInfo(QuaZipFileInfo* info)const;
+    /// Retrieves information about the current file.
+    /** \overload
+     *
+     * This function supports zip64. If the archive doesn't use zip64, it is
+     * completely equivalent to getCurrentFileInfo(QuaZipFileInfo* info)
+     * except for the argument type.
+     *
+     * \sa
+     **/
+    bool getCurrentFileInfo(QuaZipFileInfo64* info)const;
+    /// Returns the current file name.
+    /** Equivalent to calling getCurrentFileInfo() and then getting \c
+     * name field of the QuaZipFileInfo structure, but faster and more
+     * convenient.
+     *
+     * Should be used only in QuaZip::mdUnzip mode.
+     **/
+    QString getCurrentFileName()const;
+    /// Returns \c unzFile handle.
+    /** You can use this handle to directly call UNZIP part of the
+     * ZIP/UNZIP package functions (see unzip.h).
+     *
+     * \warning When using the handle returned by this function, please
+     * keep in mind that QuaZip class is unable to detect any changes
+     * you make in the ZIP file state (e. g. changing current file, or
+     * closing the handle). So please do not do anything with this
+     * handle that is possible to do with the functions of this class.
+     * Or at least return the handle in the original state before
+     * calling some another function of this class (including implicit
+     * destructor calls and calls from the QuaZipFile objects that refer
+     * to this QuaZip instance!). So if you have changed the current
+     * file in the ZIP archive - then change it back or you may
+     * experience some strange behavior or even crashes.
+     **/
+    unzFile getUnzFile();
+    /// Returns \c zipFile handle.
+    /** You can use this handle to directly call ZIP part of the
+     * ZIP/UNZIP package functions (see zip.h). Warnings about the
+     * getUnzFile() function also apply to this function.
+     **/
+    zipFile getZipFile();
+    /// Changes the data descriptor writing mode.
+    /**
+      According to the ZIP format specification, a file inside archive
+      may have a data descriptor immediately following the file
+      data. This is reflected by a special flag in the local file header
+      and in the central directory. By default, QuaZip sets this flag
+      and writes the data descriptor unless both method and level were
+      set to 0, in which case it operates in 1.0-compatible mode and
+      never writes data descriptors.
+
+      By setting this flag to false, it is possible to disable data
+      descriptor writing, thus increasing compatibility with archive
+      readers that don't understand this feature of the ZIP file format.
+
+      Setting this flag affects all the QuaZipFile instances that are
+      opened after this flag is set.
+
+      The data descriptor writing mode is enabled by default.
+
+      Note that if the ZIP archive is written into a QIODevice for which
+      QIODevice::isSequential() returns \c true, then the data descriptor
+      is mandatory and will be written even if this flag is set to false.
+
+      \param enabled If \c true, enable local descriptor writing,
+      disable it otherwise.
+
+      \sa QuaZipFile::isDataDescriptorWritingEnabled()
+      */
+    void setDataDescriptorWritingEnabled(bool enabled);
+    /// Returns the data descriptor default writing mode.
+    /**
+      \sa setDataDescriptorWritingEnabled()
+      */
+    bool isDataDescriptorWritingEnabled() const;
+    /// Returns a list of files inside the archive.
+    /**
+      \return A list of file names or an empty list if there
+      was an error or if the archive is empty (call getZipError() to
+      figure out which).
+      \sa getFileInfoList()
+      */
+    QStringList getFileNameList() const;
+    /// Returns information list about all files inside the archive.
+    /**
+      \return A list of QuaZipFileInfo objects or an empty list if there
+      was an error or if the archive is empty (call getZipError() to
+      figure out which).
+
+      This function doesn't support zip64, but will still work with zip64
+      archives, converting results using QuaZipFileInfo64::toQuaZipFileInfo().
+      If all file sizes are below 4 GB, it will work just fine.
+
+      \sa getFileNameList()
+      \sa getFileInfoList64()
+      */
+    QList<QuaZipFileInfo> getFileInfoList() const;
+    /// Returns information list about all files inside the archive.
+    /**
+      \overload
+
+      This function supports zip64.
+
+      \sa getFileNameList()
+      \sa getFileInfoList()
+      */
+    QList<QuaZipFileInfo64> getFileInfoList64() const;
+    /// Enables the zip64 mode.
+    /**
+     * @param zip64 If \c true, the zip64 mode is enabled, disabled otherwise.
+     *
+     * Once this is enabled, all new files (until the mode is disabled again)
+     * will be created in the zip64 mode, thus enabling the ability to write
+     * files larger than 4 GB. By default, the zip64 mode is off due to
+     * compatibility reasons.
+     *
+     * Note that this does not affect the ability to read zip64 archives in any
+     * way.
+     *
+     * \sa isZip64Enabled()
+     */
+    void setZip64Enabled(bool zip64);
+    /// Returns whether the zip64 mode is enabled.
+    /**
+     * @return \c true if and only if the zip64 mode is enabled.
+     *
+     * \sa setZip64Enabled()
+     */
+    bool isZip64Enabled() const;
+    /// Enables the use of UTF-8 encoding for file names and comments text.
+    /**
+     * @param utf8 If \c true, the UTF-8 mode is enabled, disabled otherwise.
+     *
+     * Once this is enabled, the names of all new files and comments text (until
+     * the mode is disabled again) will be encoded in UTF-8 encoding, and the
+     * version to extract will be set to 6.3 (63) in ZIP header. By default,
+     * the UTF-8 mode is off due to compatibility reasons.
+     *
+     * Note that when extracting ZIP archives, the UTF-8 mode is determined from
+     * ZIP file header, not from this flag.
+     *
+     * \sa isUtf8Enabled()
+     */
+    void setUtf8Enabled(bool utf8);
+    /// Returns whether the UTF-8 encoding mode is enabled.
+    /**
+     * @return \c true if and only if the UTF-8 mode is enabled.
+     *
+     * \sa setUtf8Enabled()
+     */
+    bool isUtf8Enabled() const;
+    /// Returns the auto-close flag.
+    /**
+      @sa setAutoClose()
+      */
+    bool isAutoClose() const;
+    /// Sets or unsets the auto-close flag.
+    /**
+      By default, QuaZip opens the underlying QIODevice when open() is called,
+      and closes it when close() is called. In some cases, when the device
+      is set explicitly using setIoDevice(), it may be desirable to
+      leave the device open. If the auto-close flag is unset using this method,
+      then the device isn't closed automatically if it was set explicitly.
+
+      If it is needed to clear this flag, it is recommended to do so before
+      opening the archive because otherwise QuaZip may close the device
+      during the open() call if an error is encountered after the device
+      is opened.
+
+      If the device was not set explicitly, but rather the setZipName() or
+      the appropriate constructor was used to set the ZIP file name instead,
+      then the auto-close flag has no effect, and the internal device
+      is closed nevertheless because there is no other way to close it.
+
+      @sa isAutoClose()
+      @sa setIoDevice()
+      */
+    void setAutoClose(bool autoClose) const;
+    /// Sets the default file name codec to use.
+    /**
+     * The default codec is used by the constructors, so calling this function
+     * won't affect the QuaZip instances already created at that moment.
+     *
+     * The codec specified here can be overriden by calling setFileNameCodec().
+     * If neither function is called, QTextCodec::codecForLocale() will be used
+     * to decode or encode file names. Use this function with caution if
+     * the application uses other libraries that depend on QuaZip. Those
+     * libraries can either call this function by themselves, thus overriding
+     * your setting or can rely on the default encoding, thus failing
+     * mysteriously if you change it. For these reasons, it isn't recommended
+     * to use this function if you are developing a library, not an application.
+     * Instead, ask your library users to call it in case they need specific
+     * encoding.
+     *
+     * In most cases, using setFileNameCodec() instead is the right choice.
+     * However, if you depend on third-party code that uses QuaZip, then the
+     * reasons stated above can actually become a reason to use this function
+     * in case the third-party code in question fails because it doesn't
+     * understand the encoding you need and doesn't provide a way to specify it.
+     * This applies to the JlCompress class as well, as it was contributed and
+     * doesn't support explicit encoding parameters.
+     *
+     * In short: use setFileNameCodec() when you can, resort to
+     * setDefaultFileNameCodec() when you don't have access to the QuaZip
+     * instance.
+     *
+     * @param codec The codec to use by default. If null, resets to default.
+     */
+    static void setDefaultFileNameCodec(QTextCodec *codec);
+    /**
+     * @overload
+     * Equivalent to calling
+     * setDefaultFileNameCodec(QTextCodec::codecForName(codecName)).
+     */
+    static void setDefaultFileNameCodec(const char *codecName);
+    /// Sets default OS code.
+    /**
+     * @sa setOsCode()
+     */
+    static void setDefaultOsCode(uint osCode);
+    /// Returns default OS code.
+    /**
+     * @sa getOsCode()
+     */
+    static uint getDefaultOsCode();
+};
+
+#endif
diff -ruN ./quazipnewinfo.cpp ../../dep/quazip/quazip/quazipnewinfo.cpp
--- ./quazipnewinfo.cpp	2020-11-27 04:16:54.992498165 +0200
+++ ../../dep/quazip/quazip/quazipnewinfo.cpp	2020-11-27 04:08:04.065851277 +0200
@@ -1,51 +1,278 @@
-/*
-Copyright (C) 2005-2011 Sergey A. Tachenov
-
-This program is free software; you can redistribute it and/or modify it
-under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation; either version 2 of the License, or (at
-your option) any later version.
-
-This program is distributed in the hope that it will be useful, but
-WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser
-General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this program; if not, write to the Free Software Foundation,
-Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
-
-See COPYING file for the full LGPL text.
-
-Original ZIP package is copyrighted by Gilles Vollant, see
-quazip/(un)zip.h files for details, basically it's zlib license.
-*/
-
-#include <QFileInfo>
-
-#include "quazipnewinfo.h"
-
-
-QuaZipNewInfo::QuaZipNewInfo(const QString& name):
-  name(name), dateTime(QDateTime::currentDateTime()), internalAttr(0), externalAttr(0)
-{
-}
-
-QuaZipNewInfo::QuaZipNewInfo(const QString& name, const QString& file):
-  name(name), internalAttr(0), externalAttr(0)
-{
-  QFileInfo info(file);
-  QDateTime lm = info.lastModified();
-  if (!info.exists())
-    dateTime = QDateTime::currentDateTime();
-  else
-    dateTime = lm;
-}
-
-void QuaZipNewInfo::setFileDateTime(const QString& file)
-{
-  QFileInfo info(file);
-  QDateTime lm = info.lastModified();
-  if (info.exists())
-    dateTime = lm;
-}
+/*
+Copyright (C) 2005-2014 Sergey A. Tachenov
+
+This file is part of QuaZip.
+
+QuaZip is free software: you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation, either version 2.1 of the License, or
+(at your option) any later version.
+
+QuaZip is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with QuaZip.  If not, see <http://www.gnu.org/licenses/>.
+
+See COPYING file for the full LGPL text.
+
+Original ZIP package is copyrighted by Gilles Vollant and contributors,
+see quazip/(un)zip.h files for details. Basically it's the zlib license.
+*/
+
+#include <QtCore/QFileInfo>
+
+#include "quazipnewinfo.h"
+#include "quazip_qt_compat.h"
+
+#include <string.h>
+
+static void QuaZipNewInfo_setPermissions(QuaZipNewInfo *info,
+        QFile::Permissions perm, bool isDir, bool isSymLink = false)
+{
+    quint32 uPerm = isDir ? 0040000 : 0100000;
+
+    if ( isSymLink ) {
+#ifdef Q_OS_WIN
+        uPerm = 0200000;
+#else
+        uPerm = 0120000;
+#endif
+    }
+
+    if ((perm & QFile::ReadOwner) != 0)
+        uPerm |= 0400;
+    if ((perm & QFile::WriteOwner) != 0)
+        uPerm |= 0200;
+    if ((perm & QFile::ExeOwner) != 0)
+        uPerm |= 0100;
+    if ((perm & QFile::ReadGroup) != 0)
+        uPerm |= 0040;
+    if ((perm & QFile::WriteGroup) != 0)
+        uPerm |= 0020;
+    if ((perm & QFile::ExeGroup) != 0)
+        uPerm |= 0010;
+    if ((perm & QFile::ReadOther) != 0)
+        uPerm |= 0004;
+    if ((perm & QFile::WriteOther) != 0)
+        uPerm |= 0002;
+    if ((perm & QFile::ExeOther) != 0)
+        uPerm |= 0001;
+    info->externalAttr = (info->externalAttr & ~0xFFFF0000u) | (uPerm << 16);
+}
+
+template<typename FileInfo>
+void QuaZipNewInfo_init(QuaZipNewInfo &self, const FileInfo &existing)
+{
+    self.name = existing.name;
+    self.dateTime = existing.dateTime;
+    self.internalAttr = existing.internalAttr;
+    self.externalAttr = existing.externalAttr;
+    self.comment = existing.comment;
+    self.extraLocal = existing.extra;
+    self.extraGlobal = existing.extra;
+    self.uncompressedSize = existing.uncompressedSize;
+}
+
+QuaZipNewInfo::QuaZipNewInfo(const QuaZipFileInfo &existing)
+{
+    QuaZipNewInfo_init(*this, existing);
+}
+
+QuaZipNewInfo::QuaZipNewInfo(const QuaZipFileInfo64 &existing)
+{
+    QuaZipNewInfo_init(*this, existing);
+}
+
+QuaZipNewInfo::QuaZipNewInfo(const QString& name):
+  name(name), dateTime(QDateTime::currentDateTime()), internalAttr(0), externalAttr(0),
+  uncompressedSize(0)
+{
+}
+
+QuaZipNewInfo::QuaZipNewInfo(const QString& name, const QString& file):
+  name(name), internalAttr(0), externalAttr(0), uncompressedSize(0)
+{
+  QFileInfo info(file);
+  QDateTime lm = info.lastModified();
+  if (!info.exists()) {
+    dateTime = QDateTime::currentDateTime();
+  } else {
+    dateTime = lm;
+    QuaZipNewInfo_setPermissions(this, info.permissions(), info.isDir(), quazip_is_symlink(info));
+  }
+}
+
+void QuaZipNewInfo::setFileDateTime(const QString& file)
+{
+  QFileInfo info(file);
+  QDateTime lm = info.lastModified();
+  if (info.exists())
+    dateTime = lm;
+}
+
+void QuaZipNewInfo::setFilePermissions(const QString &file)
+{
+    QFileInfo info = QFileInfo(file);
+    QFile::Permissions perm = info.permissions();
+    QuaZipNewInfo_setPermissions(this, perm, info.isDir(), quazip_is_symlink(info));
+}
+
+void QuaZipNewInfo::setPermissions(QFile::Permissions permissions)
+{
+    QuaZipNewInfo_setPermissions(this, permissions, name.endsWith(QLatin1String("/")));
+}
+
+void QuaZipNewInfo::setFileNTFSTimes(const QString &fileName)
+{
+    QFileInfo fi(fileName);
+    if (!fi.exists()) {
+        qWarning("QuaZipNewInfo::setFileNTFSTimes(): '%s' doesn't exist",
+                 fileName.toUtf8().constData());
+        return;
+    }
+    setFileNTFSmTime(fi.lastModified());
+    setFileNTFSaTime(fi.lastRead());
+    setFileNTFScTime(quazip_ctime(fi));
+}
+
+static void setNTFSTime(QByteArray &extra, const QDateTime &time, int position,
+                        int fineTicks) {
+    int ntfsPos = -1, timesPos = -1;
+    unsigned ntfsLength = 0, ntfsTimesLength = 0;
+    for (int i = 0; i <= extra.size() - 4; ) {
+        unsigned type = static_cast<unsigned>(static_cast<unsigned char>(
+                                                  extra.at(i)))
+                | (static_cast<unsigned>(static_cast<unsigned char>(
+                                                  extra.at(i + 1))) << 8);
+        i += 2;
+        unsigned length = static_cast<unsigned>(static_cast<unsigned char>(
+                                                  extra.at(i)))
+                | (static_cast<unsigned>(static_cast<unsigned char>(
+                                                  extra.at(i + 1))) << 8);
+        i += 2;
+        if (type == QUAZIP_EXTRA_NTFS_MAGIC) {
+            ntfsPos = i - 4; // the beginning of the NTFS record
+            ntfsLength = length;
+            if (length <= 4) {
+                break; // no times in the NTFS record
+            }
+            i += 4; // reserved
+            while (i <= extra.size() - 4) {
+                unsigned tag = static_cast<unsigned>(
+                            static_cast<unsigned char>(extra.at(i)))
+                        | (static_cast<unsigned>(
+                               static_cast<unsigned char>(extra.at(i + 1)))
+                           << 8);
+                i += 2;
+                unsigned tagsize = static_cast<unsigned>(
+                            static_cast<unsigned char>(extra.at(i)))
+                        | (static_cast<unsigned>(
+                               static_cast<unsigned char>(extra.at(i + 1)))
+                           << 8);
+                i += 2;
+                if (tag == QUAZIP_EXTRA_NTFS_TIME_MAGIC) {
+                    timesPos = i - 4; // the beginning of the NTFS times tag
+                    ntfsTimesLength = tagsize;
+                    break;
+                } else {
+                    i += tagsize;
+                }
+            }
+            break; // I ain't going to search for yet another NTFS record!
+        } else {
+            i += length;
+        }
+    }
+    if (ntfsPos == -1) {
+        // No NTFS record, need to create one.
+        ntfsPos = extra.size();
+        ntfsLength = 32;
+        extra.resize(extra.size() + 4 + ntfsLength);
+        // the NTFS record header
+        extra[ntfsPos] = static_cast<char>(QUAZIP_EXTRA_NTFS_MAGIC);
+        extra[ntfsPos + 1] = static_cast<char>(QUAZIP_EXTRA_NTFS_MAGIC >> 8);
+        extra[ntfsPos + 2] = 32; // the 2-byte size in LittleEndian
+        extra[ntfsPos + 3] = 0;
+        // zero the record
+        memset(extra.data() + ntfsPos + 4, 0, 32);
+        timesPos = ntfsPos + 8;
+        // now set the tag data
+        extra[timesPos] = static_cast<char>(QUAZIP_EXTRA_NTFS_TIME_MAGIC);
+        extra[timesPos + 1] = static_cast<char>(QUAZIP_EXTRA_NTFS_TIME_MAGIC
+                                               >> 8);
+        // the size:
+        extra[timesPos + 2] = 24;
+        extra[timesPos + 3] = 0;
+        ntfsTimesLength = 24;
+    }
+    if (timesPos == -1) {
+        // No time tag in the NTFS record, need to add one.
+        timesPos = ntfsPos + 4 + ntfsLength;
+        extra.resize(extra.size() + 28);
+        // Now we need to move the rest of the field
+        // (possibly zero bytes, but memmove() is OK with that).
+        // 0 ......... ntfsPos .. ntfsPos + 4   ... timesPos
+        // <some data> <header>   <NTFS record>     <need-to-move data>    <end>
+        memmove(extra.data() + timesPos + 28, extra.data() + timesPos,
+                extra.size() - 28 - timesPos);
+        ntfsLength += 28;
+        // now set the tag data
+        extra[timesPos] = static_cast<char>(QUAZIP_EXTRA_NTFS_TIME_MAGIC);
+        extra[timesPos + 1] = static_cast<char>(QUAZIP_EXTRA_NTFS_TIME_MAGIC
+                                               >> 8);
+        // the size:
+        extra[timesPos + 2] = 24;
+        extra[timesPos + 3] = 0;
+        // zero the record
+        memset(extra.data() + timesPos + 4, 0, 24);
+        ntfsTimesLength = 24;
+    }
+    if (ntfsTimesLength < 24) {
+        // Broken times field. OK, this is really unlikely, but just in case...
+        size_t timesEnd = timesPos + 4 + ntfsTimesLength;
+        extra.resize(extra.size() + (24 - ntfsTimesLength));
+        // Move it!
+        // 0 ......... timesPos .... timesPos + 4 .. timesEnd
+        // <some data> <time header> <broken times> <need-to-move data> <end>
+        memmove(extra.data() + timesEnd + (24 - ntfsTimesLength),
+                extra.data() + timesEnd,
+                extra.size() - (24 - ntfsTimesLength) - timesEnd);
+        // Now we have to increase the NTFS record and time tag lengths.
+        ntfsLength += (24 - ntfsTimesLength);
+        ntfsTimesLength = 24;
+        extra[ntfsPos + 2] = static_cast<char>(ntfsLength);
+        extra[ntfsPos + 3] = static_cast<char>(ntfsLength >> 8);
+        extra[timesPos + 2] = static_cast<char>(ntfsTimesLength);
+        extra[timesPos + 3] = static_cast<char>(ntfsTimesLength >> 8);
+    }
+    quint64 ticks = quazip_ntfs_ticks(time, fineTicks);
+    extra[timesPos + 4 + position] = static_cast<char>(ticks);
+    extra[timesPos + 5 + position] = static_cast<char>(ticks >> 8);
+    extra[timesPos + 6 + position] = static_cast<char>(ticks >> 16);
+    extra[timesPos + 7 + position] = static_cast<char>(ticks >> 24);
+    extra[timesPos + 8 + position] = static_cast<char>(ticks >> 32);
+    extra[timesPos + 9 + position] = static_cast<char>(ticks >> 40);
+    extra[timesPos + 10 + position] = static_cast<char>(ticks >> 48);
+    extra[timesPos + 11 + position] = static_cast<char>(ticks >> 56);
+}
+
+void QuaZipNewInfo::setFileNTFSmTime(const QDateTime &mTime, int fineTicks)
+{
+    setNTFSTime(extraLocal, mTime, 0, fineTicks);
+    setNTFSTime(extraGlobal, mTime, 0, fineTicks);
+}
+
+void QuaZipNewInfo::setFileNTFSaTime(const QDateTime &aTime, int fineTicks)
+{
+    setNTFSTime(extraLocal, aTime, 8, fineTicks);
+    setNTFSTime(extraGlobal, aTime, 8, fineTicks);
+}
+
+void QuaZipNewInfo::setFileNTFScTime(const QDateTime &cTime, int fineTicks)
+{
+    setNTFSTime(extraLocal, cTime, 16, fineTicks);
+    setNTFSTime(extraGlobal, cTime, 16, fineTicks);
+}
diff -ruN ./quazipnewinfo.h ../../dep/quazip/quazip/quazipnewinfo.h
--- ./quazipnewinfo.h	2020-11-27 04:16:54.992498165 +0200
+++ ../../dep/quazip/quazip/quazipnewinfo.h	2020-11-27 04:08:04.065851277 +0200
@@ -1,102 +1,208 @@
-#ifndef QUA_ZIPNEWINFO_H
-#define QUA_ZIPNEWINFO_H
-
-/*
-Copyright (C) 2005-2011 Sergey A. Tachenov
-
-This program is free software; you can redistribute it and/or modify it
-under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation; either version 2 of the License, or (at
-your option) any later version.
-
-This program is distributed in the hope that it will be useful, but
-WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser
-General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this program; if not, write to the Free Software Foundation,
-Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
-
-See COPYING file for the full LGPL text.
-
-Original ZIP package is copyrighted by Gilles Vollant, see
-quazip/(un)zip.h files for details, basically it's zlib license.
- **/
-
-#include <QDateTime>
-#include <QString>
-
-#include "quazip_global.h"
-
-/// Information about a file to be created.
-/** This structure holds information about a file to be created inside
- * ZIP archive. At least name should be set to something correct before
- * passing this structure to
- * QuaZipFile::open(OpenMode,const QuaZipNewInfo&,int,int,bool).
- **/
-struct QUAZIP_EXPORT QuaZipNewInfo {
-  /// File name.
-  /** This field holds file name inside archive, including path relative
-   * to archive root.
-   **/
-  QString name;
-  /// File timestamp.
-  /** This is the last file modification date and time. Will be stored
-   * in the archive central directory. It is a good practice to set it
-   * to the source file timestamp instead of archive creating time. Use
-   * setFileDateTime() or QuaZipNewInfo(const QString&, const QString&).
-   **/
-  QDateTime dateTime;
-  /// File internal attributes.
-  quint16 internalAttr;
-  /// File external attributes.
-  quint32 externalAttr;
-  /// File comment.
-  /** Will be encoded using QuaZip::getCommentCodec().
-   **/
-  QString comment;
-  /// File local extra field.
-  QByteArray extraLocal;
-  /// File global extra field.
-  QByteArray extraGlobal;
-  /// Uncompressed file size.
-  /** This is only needed if you are using raw file zipping mode, i. e.
-   * adding precompressed file in the zip archive.
-   **/
-  ulong uncompressedSize;
-  /// Constructs QuaZipNewInfo instance.
-  /** Initializes name with \a name, dateTime with current date and
-   * time. Attributes are initialized with zeros, comment and extra
-   * field with null values.
-   **/
-  QuaZipNewInfo(const QString& name);
-  /// Constructs QuaZipNewInfo instance.
-  /** Initializes name with \a name and dateTime with timestamp of the
-   * file named \a file. If the \a file does not exists or its timestamp
-   * is inaccessible (e. g. you do not have read permission for the
-   * directory file in), uses current date and time. Attributes are
-   * initialized with zeros, comment and extra field with null values.
-   * 
-   * \sa setFileDateTime()
-   **/
-  QuaZipNewInfo(const QString& name, const QString& file);
-  /// Sets the file timestamp from the existing file.
-  /** Use this function to set the file timestamp from the existing
-   * file. Use it like this:
-   * \code
-   * QuaZipFile zipFile(&zip);
-   * QFile file("file-to-add");
-   * file.open(QIODevice::ReadOnly);
-   * QuaZipNewInfo info("file-name-in-archive");
-   * info.setFileDateTime("file-to-add"); // take the timestamp from file
-   * zipFile.open(QIODevice::WriteOnly, info);
-   * \endcode
-   *
-   * This function does not change dateTime if some error occured (e. g.
-   * file is inaccessible).
-   **/
-  void setFileDateTime(const QString& file);
-};
-
-#endif
+#ifndef QUA_ZIPNEWINFO_H
+#define QUA_ZIPNEWINFO_H
+
+/*
+Copyright (C) 2005-2014 Sergey A. Tachenov
+
+This file is part of QuaZip.
+
+QuaZip is free software: you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation, either version 2.1 of the License, or
+(at your option) any later version.
+
+QuaZip is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with QuaZip.  If not, see <http://www.gnu.org/licenses/>.
+
+See COPYING file for the full LGPL text.
+
+Original ZIP package is copyrighted by Gilles Vollant, see
+quazip/(un)zip.h files for details, basically it's zlib license.
+ **/
+
+#include <QtCore/QDateTime>
+#include <QtCore/QFile>
+#include <QtCore/QString>
+
+#include "quazip_global.h"
+
+#include "quazipfileinfo.h"
+
+/// Information about a file to be created.
+/** This structure holds information about a file to be created inside
+ * ZIP archive. At least name should be set to something correct before
+ * passing this structure to
+ * QuaZipFile::open(OpenMode,const QuaZipNewInfo&,int,int,bool).
+ *
+ * Zip64 support of this structure is slightly limited: in the raw mode (when
+ * a pre-compressed file is written into a ZIP file as-is), it is necessary
+ * to specify the uncompressed file size and the appropriate field is 32 bit.
+ * Since the raw mode is used extremely rare, there is no real need to have
+ * a separate QuaZipNewInfo64 structure like QuaZipFileInfo64. It may be added
+ * in the future though, if there is a demand for the raw mode with zip64
+ * archives.
+ **/
+struct QUAZIP_EXPORT QuaZipNewInfo {
+  /// File name.
+  /** This field holds file name inside archive, including path relative
+   * to archive root.
+   **/
+  QString name;
+  /// File timestamp.
+  /** This is the last file modification date and time. Will be stored
+   * in the archive central directory. It is a good practice to set it
+   * to the source file timestamp instead of archive creating time. Use
+   * setFileDateTime() or QuaZipNewInfo(const QString&, const QString&).
+   **/
+  QDateTime dateTime;
+  /// File internal attributes.
+  quint16 internalAttr;
+  /// File external attributes.
+  /**
+    The highest 16 bits contain Unix file permissions and type (dir or
+    file). The constructor QuaZipNewInfo(const QString&, const QString&)
+    takes permissions from the provided file.
+    */
+  quint32 externalAttr;
+  /// File comment.
+  /** Will be encoded in UTF-8 encoding.
+   **/
+  QString comment;
+  /// File local extra field.
+  QByteArray extraLocal;
+  /// File global extra field.
+  QByteArray extraGlobal;
+  /// Uncompressed file size.
+  /** This is only needed if you are using raw file zipping mode, i. e.
+   * adding precompressed file in the zip archive.
+   **/
+  ulong uncompressedSize;
+  /// Constructs QuaZipNewInfo instance.
+  /** Initializes name with \a name, dateTime with current date and
+   * time. Attributes are initialized with zeros, comment and extra
+   * field with null values.
+   **/
+  QuaZipNewInfo(const QString& name);
+  /// Constructs QuaZipNewInfo instance.
+  /** Initializes name with \a name. Timestamp and permissions are taken
+   * from the specified file. If the \a file does not exists or its timestamp
+   * is inaccessible (e. g. you do not have read permission for the
+   * directory file in), uses current time and zero permissions. Other attributes are
+   * initialized with zeros, comment and extra field with null values.
+   * 
+   * \sa setFileDateTime()
+   **/
+  QuaZipNewInfo(const QString& name, const QString& file);
+  /// Initializes the new instance from existing file info.
+  /** Mainly used when copying files between archives.
+   *
+   * Both extra fields are initialized to existing.extra.
+   * @brief QuaZipNewInfo
+   * @param existing
+   */
+  QuaZipNewInfo(const QuaZipFileInfo &existing);
+  /// Initializes the new instance from existing file info.
+  /** Mainly used when copying files between archives.
+   *
+   * Both extra fields are initialized to existing.extra.
+   * @brief QuaZipNewInfo
+   * @param existing
+   */
+  QuaZipNewInfo(const QuaZipFileInfo64 &existing);
+  /// Sets the file timestamp from the existing file.
+  /** Use this function to set the file timestamp from the existing
+   * file. Use it like this:
+   * \code
+   * QuaZipFile zipFile(&zip);
+   * QFile file("file-to-add");
+   * file.open(QIODevice::ReadOnly);
+   * QuaZipNewInfo info("file-name-in-archive");
+   * info.setFileDateTime("file-to-add"); // take the timestamp from file
+   * zipFile.open(QIODevice::WriteOnly, info);
+   * \endcode
+   *
+   * This function does not change dateTime if some error occured (e. g.
+   * file is inaccessible).
+   **/
+  void setFileDateTime(const QString& file);
+  /// Sets the file permissions from the existing file.
+  /**
+    Takes permissions from the file and sets the high 16 bits of
+    external attributes. Uses QFileInfo to get permissions on all
+    platforms.
+    */
+  void setFilePermissions(const QString &file);
+  /// Sets the file permissions.
+  /**
+    Modifies the highest 16 bits of external attributes. The type part
+    is set to dir if the name ends with a slash, and to regular file
+    otherwise.
+    */
+  void setPermissions(QFile::Permissions permissions);
+  /// Sets the NTFS times from an existing file.
+  /**
+   * If the file doesn't exist, a warning is printed to the stderr and nothing
+   * is done. Otherwise, all three times, as reported by
+   * QFileInfo::lastModified(), QFileInfo::lastRead() and
+   * QFileInfo::birthTime() (>=Qt5.10) or QFileInfo::created(), are written to
+   * the NTFS extra field record.
+   *
+   * The NTFS record is written to
+   * both the local and the global extra fields, updating the existing record
+   * if there is one, or creating a new one and appending it to the end
+   * of each extra field.
+   *
+   * The microseconds will be zero, as they aren't reported by QFileInfo.
+   * @param fileName
+   */
+  void setFileNTFSTimes(const QString &fileName);
+  /// Sets the NTFS modification time.
+  /**
+   * The time is written into the NTFS record in
+   * both the local and the global extra fields, updating the existing record
+   * if there is one, or creating a new one and appending it to the end
+   * of each extra field. When updating an existing record, all other fields
+   * are left intact.
+   * @param mTime The new modification time.
+   * @param fineTicks The fractional part of milliseconds, in 100-nanosecond
+   *        ticks (i. e. 9999 ticks = 999.9 microsecond). Values greater than
+   *        9999 will add milliseconds or even seconds, but this can be
+   *        confusing and therefore is discouraged.
+   */
+  void setFileNTFSmTime(const QDateTime &mTime, int fineTicks = 0);
+  /// Sets the NTFS access time.
+  /**
+   * The time is written into the NTFS record in
+   * both the local and the global extra fields, updating the existing record
+   * if there is one, or creating a new one and appending it to the end
+   * of each extra field. When updating an existing record, all other fields
+   * are left intact.
+   * @param aTime The new access time.
+   * @param fineTicks The fractional part of milliseconds, in 100-nanosecond
+   *        ticks (i. e. 9999 ticks = 999.9 microsecond). Values greater than
+   *        9999 will add milliseconds or even seconds, but this can be
+   *        confusing and therefore is discouraged.
+   */
+  void setFileNTFSaTime(const QDateTime &aTime, int fineTicks = 0);
+  /// Sets the NTFS creation time.
+  /**
+   * The time is written into the NTFS record in
+   * both the local and the global extra fields, updating the existing record
+   * if there is one, or creating a new one and appending it to the end
+   * of each extra field. When updating an existing record, all other fields
+   * are left intact.
+   * @param cTime The new creation time.
+   * @param fineTicks The fractional part of milliseconds, in 100-nanosecond
+   *        ticks (i. e. 9999 ticks = 999.9 microsecond). Values greater than
+   *        9999 will add milliseconds or even seconds, but this can be
+   *        confusing and therefore is discouraged.
+   */
+  void setFileNTFScTime(const QDateTime &cTime, int fineTicks = 0);
+};
+
+#endif
diff -ruN ./quazip.pri ../../dep/quazip/quazip/quazip.pri
--- ./quazip.pri	2020-11-27 04:16:54.992498165 +0200
+++ ../../dep/quazip/quazip/quazip.pri	1970-01-01 02:00:00.000000000 +0200
@@ -1,23 +0,0 @@
-INCLUDEPATH += $$PWD
-DEPENDPATH += $$PWD
-HEADERS += $$PWD/crypt.h \
-           $$PWD/ioapi.h \
-           $$PWD/JlCompress.h \
-           $$PWD/quaadler32.h \
-           $$PWD/quachecksum32.h \
-           $$PWD/quacrc32.h \
-           $$PWD/quazip.h \
-           $$PWD/quazipfile.h \
-           $$PWD/quazipfileinfo.h \
-           $$PWD/quazipnewinfo.h \
-           $$PWD/unzip.h \
-           $$PWD/zip.h
-SOURCES += $$PWD/qioapi.cpp \
-           $$PWD/JlCompress.cpp \
-           $$PWD/quaadler32.cpp \
-           $$PWD/quacrc32.cpp \
-           $$PWD/quazip.cpp \
-           $$PWD/quazipfile.cpp \
-           $$PWD/quazipnewinfo.cpp \
-           $$PWD/unzip.c \
-           $$PWD/zip.c
diff -ruN ./quazip.pro ../../dep/quazip/quazip/quazip.pro
--- ./quazip.pro	2020-11-27 04:16:54.992498165 +0200
+++ ../../dep/quazip/quazip/quazip.pro	1970-01-01 02:00:00.000000000 +0200
@@ -1,72 +0,0 @@
-TEMPLATE = lib
-CONFIG += qt warn_on
-QT -= gui
-DEPENDPATH += .
-INCLUDEPATH += .
-
-DEFINES += QUAZIP_BUILD
-CONFIG(staticlib): DEFINES += QUAZIP_STATIC
-
-# Input
-HEADERS += \
-    crypt.h\
-    ioapi.h\
-    JlCompress.h\
-    quaadler32.h\
-    quachecksum32.h\
-    quacrc32.h\
-    quazip.h\
-    quazipfile.h\
-    quazipfileinfo.h\
-    quazipnewinfo.h\
-    quazip_global.h\
-    unzip.h\
-    zip.h\
-
-SOURCES += *.c *.cpp
-
-unix:!symbian {
-    headers.path=$$PREFIX/include/quazip
-    headers.files=$$HEADERS
-    target.path=$$PREFIX/lib
-    INSTALLS += headers target
-
-	OBJECTS_DIR=.obj
-	MOC_DIR=.moc
-	
-}
-
-win32 {
-    headers.path=$$PREFIX/include/quazip
-    headers.files=$$HEADERS
-    target.path=$$PREFIX/lib
-    INSTALLS += headers target
-
-}
-
-
-symbian {
-
-    # Note, on Symbian you may run into troubles with LGPL.
-    # The point is, if your application uses some version of QuaZip,
-    # and a newer binary compatible version of QuaZip is released, then
-    # the users of your application must be able to relink it with the
-    # new QuaZip version. For example, to take advantage of some QuaZip
-    # bug fixes.
-
-    # This is probably best achieved by building QuaZip as a static
-    # library and providing linkable object files of your application,
-    # so users can relink it.
-
-    CONFIG += staticlib
-    CONFIG += debug_and_release
-
-    LIBS += -lezip
-
-    #Export headers to SDK Epoc32/include directory
-    exportheaders.sources = $$HEADERS
-    exportheaders.path = quazip
-    for(header, exportheaders.sources) {
-        BLD_INF_RULES.prj_exports += "$$header $$exportheaders.path/$$basename(header)"
-    }
-}
diff -ruN ./unzip.c ../../dep/quazip/quazip/unzip.c
--- ./unzip.c	2020-11-27 04:16:54.992498165 +0200
+++ ../../dep/quazip/quazip/unzip.c	2020-11-27 04:08:04.065851277 +0200
@@ -1,1603 +1,2163 @@
-/* unzip.c -- IO for uncompress .zip files using zlib
-   Version 1.01e, February 12th, 2005
-
-   Copyright (C) 1998-2005 Gilles Vollant
-
-   Read unzip.h for more info
-
-   Modified by Sergey A. Tachenov to integrate with Qt.
-*/
-
-/* Decryption code comes from crypt.c by Info-ZIP but has been greatly reduced in terms of
-compatibility with older software. The following is from the original crypt.c. Code
-woven in by Terry Thorsen 1/2003.
-*/
-/*
-  Copyright (c) 1990-2000 Info-ZIP.  All rights reserved.
-
-  See the accompanying file LICENSE, version 2000-Apr-09 or later
-  (the contents of which are also included in zip.h) for terms of use.
-  If, for some reason, all these files are missing, the Info-ZIP license
-  also may be found at:  ftp://ftp.info-zip.org/pub/infozip/license.html
-*/
-/*
-  crypt.c (full version) by Info-ZIP.      Last revised:  [see crypt.h]
-
-  The encryption/decryption parts of this source code (as opposed to the
-  non-echoing password parts) were originally written in Europe.  The
-  whole source package can be freely distributed, including from the USA.
-  (Prior to January 2000, re-export from the US was a violation of US law.)
- */
-
-/*
-  This encryption code is a direct transcription of the algorithm from
-  Roger Schlafly, described by Phil Katz in the file appnote.txt.  This
-  file (appnote.txt) is distributed with the PKZIP program (even in the
-  version without encryption capabilities).
- */
-
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include "zlib.h"
-#include "unzip.h"
-
-#ifdef STDC
-#  include <stddef.h>
-#  include <string.h>
-#  include <stdlib.h>
-#endif
-#ifdef NO_ERRNO_H
-    extern int errno;
-#else
-#   include <errno.h>
-#endif
-
-
-#ifndef local
-#  define local static
-#endif
-/* compile with -Dlocal if your debugger can't find static symbols */
-
-
-#ifndef CASESENSITIVITYDEFAULT_NO
-#  if !defined(unix) && !defined(CASESENSITIVITYDEFAULT_YES)
-#    define CASESENSITIVITYDEFAULT_NO
-#  endif
-#endif
-
-
-#ifndef UNZ_BUFSIZE
-#define UNZ_BUFSIZE (16384)
-#endif
-
-#ifndef UNZ_MAXFILENAMEINZIP
-#define UNZ_MAXFILENAMEINZIP (256)
-#endif
-
-#ifndef ALLOC
-# define ALLOC(size) (malloc(size))
-#endif
-#ifndef TRYFREE
-# define TRYFREE(p) {if (p) free(p);}
-#endif
-
-#define SIZECENTRALDIRITEM (0x2e)
-#define SIZEZIPLOCALHEADER (0x1e)
-
-
-
-
-const char unz_copyright[] =
-   " unzip 1.01 Copyright 1998-2004 Gilles Vollant - http://www.winimage.com/zLibDll";
-
-/* unz_file_info_interntal contain internal info about a file in zipfile*/
-typedef struct unz_file_info_internal_s
-{
-    uLong offset_curfile;/* relative offset of local header 4 bytes */
-} unz_file_info_internal;
-
-
-/* file_in_zip_read_info_s contain internal information about a file in zipfile,
-    when reading and decompress it */
-typedef struct
-{
-    char  *read_buffer;         /* internal buffer for compressed data */
-    z_stream stream;            /* zLib stream structure for inflate */
-
-    uLong pos_in_zipfile;       /* position in byte on the zipfile, for fseek*/
-    uLong stream_initialised;   /* flag set if stream structure is initialised*/
-
-    uLong offset_local_extrafield;/* offset of the local extra field */
-    uInt  size_local_extrafield;/* size of the local extra field */
-    uLong pos_local_extrafield;   /* position in the local extra field in read*/
-
-    uLong crc32;                /* crc32 of all data uncompressed */
-    uLong crc32_wait;           /* crc32 we must obtain after decompress all */
-    uLong rest_read_compressed; /* number of byte to be decompressed */
-    uLong rest_read_uncompressed;/*number of byte to be obtained after decomp*/
-    zlib_filefunc_def z_filefunc;
-    voidpf filestream;        /* io structore of the zipfile */
-    uLong compression_method;   /* compression method (0==store) */
-    uLong byte_before_the_zipfile;/* byte before the zipfile, (>0 for sfx)*/
-    int   raw;
-} file_in_zip_read_info_s;
-
-
-/* unz_s contain internal information about the zipfile
-*/
-typedef struct
-{
-    zlib_filefunc_def z_filefunc;
-    voidpf filestream;        /* io structore of the zipfile */
-    unz_global_info gi;       /* public global information */
-    uLong byte_before_the_zipfile;/* byte before the zipfile, (>0 for sfx)*/
-    uLong num_file;             /* number of the current file in the zipfile*/
-    uLong pos_in_central_dir;   /* pos of the current file in the central dir*/
-    uLong current_file_ok;      /* flag about the usability of the current file*/
-    uLong central_pos;          /* position of the beginning of the central dir*/
-
-    uLong size_central_dir;     /* size of the central directory  */
-    uLong offset_central_dir;   /* offset of start of central directory with
-                                   respect to the starting disk number */
-
-    unz_file_info cur_file_info; /* public info about the current file in zip*/
-    unz_file_info_internal cur_file_info_internal; /* private info about it*/
-    file_in_zip_read_info_s* pfile_in_zip_read; /* structure about the current
-                                        file if we are decompressing it */
-    int encrypted;
-#    ifndef NOUNCRYPT
-    unsigned long keys[3];     /* keys defining the pseudo-random sequence */
-    const unsigned long* pcrc_32_tab;
-#    endif
-} unz_s;
-
-
-#ifndef NOUNCRYPT
-#include "crypt.h"
-#endif
-
-/* ===========================================================================
-     Read a byte from a gz_stream; update next_in and avail_in. Return EOF
-   for end of file.
-   IN assertion: the stream s has been sucessfully opened for reading.
-*/
-
-
-local int unzlocal_getByte OF((
-    const zlib_filefunc_def* pzlib_filefunc_def,
-    voidpf filestream,
-    int *pi));
-
-local int unzlocal_getByte(pzlib_filefunc_def,filestream,pi)
-    const zlib_filefunc_def* pzlib_filefunc_def;
-    voidpf filestream;
-    int *pi;
-{
-    unsigned char c;
-    int err = (int)ZREAD(*pzlib_filefunc_def,filestream,&c,1);
-    if (err==1)
-    {
-        *pi = (int)c;
-        return UNZ_OK;
-    }
-    else
-    {
-        if (ZERROR(*pzlib_filefunc_def,filestream))
-            return UNZ_ERRNO;
-        else
-            return UNZ_EOF;
-    }
-}
-
-
-/* ===========================================================================
-   Reads a long in LSB order from the given gz_stream. Sets
-*/
-local int unzlocal_getShort OF((
-    const zlib_filefunc_def* pzlib_filefunc_def,
-    voidpf filestream,
-    uLong *pX));
-
-local int unzlocal_getShort (pzlib_filefunc_def,filestream,pX)
-    const zlib_filefunc_def* pzlib_filefunc_def;
-    voidpf filestream;
-    uLong *pX;
-{
-    uLong x ;
-    int i;
-    int err;
-
-    err = unzlocal_getByte(pzlib_filefunc_def,filestream,&i);
-    x = (uLong)i;
-
-    if (err==UNZ_OK)
-        err = unzlocal_getByte(pzlib_filefunc_def,filestream,&i);
-    x += ((uLong)i)<<8;
-
-    if (err==UNZ_OK)
-        *pX = x;
-    else
-        *pX = 0;
-    return err;
-}
-
-local int unzlocal_getLong OF((
-    const zlib_filefunc_def* pzlib_filefunc_def,
-    voidpf filestream,
-    uLong *pX));
-
-local int unzlocal_getLong (pzlib_filefunc_def,filestream,pX)
-    const zlib_filefunc_def* pzlib_filefunc_def;
-    voidpf filestream;
-    uLong *pX;
-{
-    uLong x ;
-    int i;
-    int err;
-
-    err = unzlocal_getByte(pzlib_filefunc_def,filestream,&i);
-    x = (uLong)i;
-
-    if (err==UNZ_OK)
-        err = unzlocal_getByte(pzlib_filefunc_def,filestream,&i);
-    x += ((uLong)i)<<8;
-
-    if (err==UNZ_OK)
-        err = unzlocal_getByte(pzlib_filefunc_def,filestream,&i);
-    x += ((uLong)i)<<16;
-
-    if (err==UNZ_OK)
-        err = unzlocal_getByte(pzlib_filefunc_def,filestream,&i);
-    x += ((uLong)i)<<24;
-
-    if (err==UNZ_OK)
-        *pX = x;
-    else
-        *pX = 0;
-    return err;
-}
-
-
-/* My own strcmpi / strcasecmp */
-local int strcmpcasenosensitive_internal (fileName1,fileName2)
-    const char* fileName1;
-    const char* fileName2;
-{
-    for (;;)
-    {
-        char c1=*(fileName1++);
-        char c2=*(fileName2++);
-        if ((c1>='a') && (c1<='z'))
-            c1 -= 0x20;
-        if ((c2>='a') && (c2<='z'))
-            c2 -= 0x20;
-        if (c1=='\0')
-            return ((c2=='\0') ? 0 : -1);
-        if (c2=='\0')
-            return 1;
-        if (c1<c2)
-            return -1;
-        if (c1>c2)
-            return 1;
-    }
-}
-
-
-#ifdef  CASESENSITIVITYDEFAULT_NO
-#define CASESENSITIVITYDEFAULTVALUE 2
-#else
-#define CASESENSITIVITYDEFAULTVALUE 1
-#endif
-
-#ifndef STRCMPCASENOSENTIVEFUNCTION
-#define STRCMPCASENOSENTIVEFUNCTION strcmpcasenosensitive_internal
-#endif
-
-/*
-   Compare two filename (fileName1,fileName2).
-   If iCaseSenisivity = 1, comparision is case sensitivity (like strcmp)
-   If iCaseSenisivity = 2, comparision is not case sensitivity (like strcmpi
-                                                                or strcasecmp)
-   If iCaseSenisivity = 0, case sensitivity is defaut of your operating system
-        (like 1 on Unix, 2 on Windows)
-
-*/
-extern int ZEXPORT unzStringFileNameCompare (fileName1,fileName2,iCaseSensitivity)
-    const char* fileName1;
-    const char* fileName2;
-    int iCaseSensitivity;
-{
-    if (iCaseSensitivity==0)
-        iCaseSensitivity=CASESENSITIVITYDEFAULTVALUE;
-
-    if (iCaseSensitivity==1)
-        return strcmp(fileName1,fileName2);
-
-    return STRCMPCASENOSENTIVEFUNCTION(fileName1,fileName2);
-}
-
-#ifndef BUFREADCOMMENT
-#define BUFREADCOMMENT (0x400)
-#endif
-
-/*
-  Locate the Central directory of a zipfile (at the end, just before
-    the global comment)
-*/
-local uLong unzlocal_SearchCentralDir OF((
-    const zlib_filefunc_def* pzlib_filefunc_def,
-    voidpf filestream));
-
-local uLong unzlocal_SearchCentralDir(pzlib_filefunc_def,filestream)
-    const zlib_filefunc_def* pzlib_filefunc_def;
-    voidpf filestream;
-{
-    unsigned char* buf;
-    uLong uSizeFile;
-    uLong uBackRead;
-    uLong uMaxBack=0xffff; /* maximum size of global comment */
-    uLong uPosFound=0;
-
-    if (ZSEEK(*pzlib_filefunc_def,filestream,0,ZLIB_FILEFUNC_SEEK_END) != 0)
-        return 0;
-
-
-    uSizeFile = ZTELL(*pzlib_filefunc_def,filestream);
-
-    if (uMaxBack>uSizeFile)
-        uMaxBack = uSizeFile;
-
-    buf = (unsigned char*)ALLOC(BUFREADCOMMENT+4);
-    if (buf==NULL)
-        return 0;
-
-    uBackRead = 4;
-    while (uBackRead<uMaxBack)
-    {
-        uLong uReadSize,uReadPos ;
-        int i;
-        if (uBackRead+BUFREADCOMMENT>uMaxBack)
-            uBackRead = uMaxBack;
-        else
-            uBackRead+=BUFREADCOMMENT;
-        uReadPos = uSizeFile-uBackRead ;
-
-        uReadSize = ((BUFREADCOMMENT+4) < (uSizeFile-uReadPos)) ?
-                     (BUFREADCOMMENT+4) : (uSizeFile-uReadPos);
-        if (ZSEEK(*pzlib_filefunc_def,filestream,uReadPos,ZLIB_FILEFUNC_SEEK_SET)!=0)
-            break;
-
-        if (ZREAD(*pzlib_filefunc_def,filestream,buf,uReadSize)!=uReadSize)
-            break;
-
-        for (i=(int)uReadSize-3; (i--)>0;)
-            if (((*(buf+i))==0x50) && ((*(buf+i+1))==0x4b) &&
-                ((*(buf+i+2))==0x05) && ((*(buf+i+3))==0x06))
-            {
-                uPosFound = uReadPos+i;
-                break;
-            }
-
-        if (uPosFound!=0)
-            break;
-    }
-    TRYFREE(buf);
-    return uPosFound;
-}
-
-/*
-  Open a Zip file. path contain the full pathname (by example,
-     on a Windows NT computer "c:\\test\\zlib114.zip" or on an Unix computer
-     "zlib/zlib114.zip".
-     If the zipfile cannot be opened (file doesn't exist or in not valid), the
-       return value is NULL.
-     Else, the return value is a unzFile Handle, usable with other function
-       of this unzip package.
-*/
-extern unzFile ZEXPORT unzOpen2 (file, pzlib_filefunc_def)
-    voidpf file;
-    zlib_filefunc_def* pzlib_filefunc_def;
-{
-    unz_s us;
-    unz_s *s;
-    uLong central_pos,uL;
-
-    uLong number_disk;          /* number of the current dist, used for
-                                   spaning ZIP, unsupported, always 0*/
-    uLong number_disk_with_CD;  /* number the the disk with central dir, used
-                                   for spaning ZIP, unsupported, always 0*/
-    uLong number_entry_CD;      /* total number of entries in
-                                   the central dir
-                                   (same than number_entry on nospan) */
-
-    int err=UNZ_OK;
-
-    if (unz_copyright[0]!=' ')
-        return NULL;
-
-    if (pzlib_filefunc_def==NULL)
-        fill_qiodevice_filefunc(&us.z_filefunc);
-    else
-        us.z_filefunc = *pzlib_filefunc_def;
-
-    us.filestream= (*(us.z_filefunc.zopen_file))(us.z_filefunc.opaque,
-                                                 file,
-                                                 ZLIB_FILEFUNC_MODE_READ |
-                                                 ZLIB_FILEFUNC_MODE_EXISTING);
-    if (us.filestream==NULL)
-        return NULL;
-
-    central_pos = unzlocal_SearchCentralDir(&us.z_filefunc,us.filestream);
-    if (central_pos==0)
-        err=UNZ_ERRNO;
-
-    if (ZSEEK(us.z_filefunc, us.filestream,
-                                      central_pos,ZLIB_FILEFUNC_SEEK_SET)!=0)
-        err=UNZ_ERRNO;
-
-    /* the signature, already checked */
-    if (unzlocal_getLong(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)
-        err=UNZ_ERRNO;
-
-    /* number of this disk */
-    if (unzlocal_getShort(&us.z_filefunc, us.filestream,&number_disk)!=UNZ_OK)
-        err=UNZ_ERRNO;
-
-    /* number of the disk with the start of the central directory */
-    if (unzlocal_getShort(&us.z_filefunc, us.filestream,&number_disk_with_CD)!=UNZ_OK)
-        err=UNZ_ERRNO;
-
-    /* total number of entries in the central dir on this disk */
-    if (unzlocal_getShort(&us.z_filefunc, us.filestream,&us.gi.number_entry)!=UNZ_OK)
-        err=UNZ_ERRNO;
-
-    /* total number of entries in the central dir */
-    if (unzlocal_getShort(&us.z_filefunc, us.filestream,&number_entry_CD)!=UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if ((number_entry_CD!=us.gi.number_entry) ||
-        (number_disk_with_CD!=0) ||
-        (number_disk!=0))
-        err=UNZ_BADZIPFILE;
-
-    /* size of the central directory */
-    if (unzlocal_getLong(&us.z_filefunc, us.filestream,&us.size_central_dir)!=UNZ_OK)
-        err=UNZ_ERRNO;
-
-    /* offset of start of central directory with respect to the
-          starting disk number */
-    if (unzlocal_getLong(&us.z_filefunc, us.filestream,&us.offset_central_dir)!=UNZ_OK)
-        err=UNZ_ERRNO;
-
-    /* zipfile comment length */
-    if (unzlocal_getShort(&us.z_filefunc, us.filestream,&us.gi.size_comment)!=UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if ((central_pos<us.offset_central_dir+us.size_central_dir) &&
-        (err==UNZ_OK))
-        err=UNZ_BADZIPFILE;
-
-    if (err!=UNZ_OK)
-    {
-        ZCLOSE(us.z_filefunc, us.filestream);
-        return NULL;
-    }
-
-    us.byte_before_the_zipfile = central_pos -
-                            (us.offset_central_dir+us.size_central_dir);
-    us.central_pos = central_pos;
-    us.pfile_in_zip_read = NULL;
-    us.encrypted = 0;
-
-
-    s=(unz_s*)ALLOC(sizeof(unz_s));
-    *s=us;
-    unzGoToFirstFile((unzFile)s);
-    return (unzFile)s;
-}
-
-
-extern unzFile ZEXPORT unzOpen (file)
-    voidpf file;
-{
-    return unzOpen2(file, NULL);
-}
-
-/*
-  Close a ZipFile opened with unzipOpen.
-  If there is files inside the .Zip opened with unzipOpenCurrentFile (see later),
-    these files MUST be closed with unzipCloseCurrentFile before call unzipClose.
-  return UNZ_OK if there is no problem. */
-extern int ZEXPORT unzClose (file)
-    unzFile file;
-{
-    unz_s* s;
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz_s*)file;
-
-    if (s->pfile_in_zip_read!=NULL)
-        unzCloseCurrentFile(file);
-
-    ZCLOSE(s->z_filefunc, s->filestream);
-    TRYFREE(s);
-    return UNZ_OK;
-}
-
-
-/*
-  Write info about the ZipFile in the *pglobal_info structure.
-  No preparation of the structure is needed
-  return UNZ_OK if there is no problem. */
-extern int ZEXPORT unzGetGlobalInfo (file,pglobal_info)
-    unzFile file;
-    unz_global_info *pglobal_info;
-{
-    unz_s* s;
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz_s*)file;
-    *pglobal_info=s->gi;
-    return UNZ_OK;
-}
-
-
-/*
-   Translate date/time from Dos format to tm_unz (readable more easilty)
-*/
-local void unzlocal_DosDateToTmuDate (ulDosDate, ptm)
-    uLong ulDosDate;
-    tm_unz* ptm;
-{
-    uLong uDate;
-    uDate = (uLong)(ulDosDate>>16);
-    ptm->tm_mday = (uInt)(uDate&0x1f) ;
-    ptm->tm_mon =  (uInt)((((uDate)&0x1E0)/0x20)-1) ;
-    ptm->tm_year = (uInt)(((uDate&0x0FE00)/0x0200)+1980) ;
-
-    ptm->tm_hour = (uInt) ((ulDosDate &0xF800)/0x800);
-    ptm->tm_min =  (uInt) ((ulDosDate&0x7E0)/0x20) ;
-    ptm->tm_sec =  (uInt) (2*(ulDosDate&0x1f)) ;
-}
-
-/*
-  Get Info about the current file in the zipfile, with internal only info
-*/
-local int unzlocal_GetCurrentFileInfoInternal OF((unzFile file,
-                                                  unz_file_info *pfile_info,
-                                                  unz_file_info_internal
-                                                  *pfile_info_internal,
-                                                  char *szFileName,
-                                                  uLong fileNameBufferSize,
-                                                  void *extraField,
-                                                  uLong extraFieldBufferSize,
-                                                  char *szComment,
-                                                  uLong commentBufferSize));
-
-local int unzlocal_GetCurrentFileInfoInternal (file,
-                                              pfile_info,
-                                              pfile_info_internal,
-                                              szFileName, fileNameBufferSize,
-                                              extraField, extraFieldBufferSize,
-                                              szComment,  commentBufferSize)
-    unzFile file;
-    unz_file_info *pfile_info;
-    unz_file_info_internal *pfile_info_internal;
-    char *szFileName;
-    uLong fileNameBufferSize;
-    void *extraField;
-    uLong extraFieldBufferSize;
-    char *szComment;
-    uLong commentBufferSize;
-{
-    unz_s* s;
-    unz_file_info file_info;
-    unz_file_info_internal file_info_internal;
-    int err=UNZ_OK;
-    uLong uMagic;
-    uLong uSeek=0;
-
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz_s*)file;
-    if (ZSEEK(s->z_filefunc, s->filestream,
-              s->pos_in_central_dir+s->byte_before_the_zipfile,
-              ZLIB_FILEFUNC_SEEK_SET)!=0)
-        err=UNZ_ERRNO;
-
-
-    /* we check the magic */
-    if (err==UNZ_OK) {
-        if (unzlocal_getLong(&s->z_filefunc, s->filestream,&uMagic) != UNZ_OK)
-            err=UNZ_ERRNO;
-        else if (uMagic!=0x02014b50)
-            err=UNZ_BADZIPFILE;
-    }
-
-    if (unzlocal_getShort(&s->z_filefunc, s->filestream,&file_info.version) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unzlocal_getShort(&s->z_filefunc, s->filestream,&file_info.version_needed) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unzlocal_getShort(&s->z_filefunc, s->filestream,&file_info.flag) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unzlocal_getShort(&s->z_filefunc, s->filestream,&file_info.compression_method) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unzlocal_getLong(&s->z_filefunc, s->filestream,&file_info.dosDate) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    unzlocal_DosDateToTmuDate(file_info.dosDate,&file_info.tmu_date);
-
-    if (unzlocal_getLong(&s->z_filefunc, s->filestream,&file_info.crc) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unzlocal_getLong(&s->z_filefunc, s->filestream,&file_info.compressed_size) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unzlocal_getLong(&s->z_filefunc, s->filestream,&file_info.uncompressed_size) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unzlocal_getShort(&s->z_filefunc, s->filestream,&file_info.size_filename) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unzlocal_getShort(&s->z_filefunc, s->filestream,&file_info.size_file_extra) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unzlocal_getShort(&s->z_filefunc, s->filestream,&file_info.size_file_comment) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unzlocal_getShort(&s->z_filefunc, s->filestream,&file_info.disk_num_start) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unzlocal_getShort(&s->z_filefunc, s->filestream,&file_info.internal_fa) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unzlocal_getLong(&s->z_filefunc, s->filestream,&file_info.external_fa) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unzlocal_getLong(&s->z_filefunc, s->filestream,&file_info_internal.offset_curfile) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    uSeek+=file_info.size_filename;
-    if ((err==UNZ_OK) && (szFileName!=NULL))
-    {
-        uLong uSizeRead ;
-        if (file_info.size_filename<fileNameBufferSize)
-        {
-            *(szFileName+file_info.size_filename)='\0';
-            uSizeRead = file_info.size_filename;
-        }
-        else
-            uSizeRead = fileNameBufferSize;
-
-        if ((file_info.size_filename>0) && (fileNameBufferSize>0))
-            if (ZREAD(s->z_filefunc, s->filestream,szFileName,uSizeRead)!=uSizeRead)
-                err=UNZ_ERRNO;
-        uSeek -= uSizeRead;
-    }
-
-
-    if ((err==UNZ_OK) && (extraField!=NULL))
-    {
-        uLong uSizeRead ;
-        if (file_info.size_file_extra<extraFieldBufferSize)
-            uSizeRead = file_info.size_file_extra;
-        else
-            uSizeRead = extraFieldBufferSize;
-
-        if (uSeek!=0) {
-            if (ZSEEK(s->z_filefunc, s->filestream,uSeek,ZLIB_FILEFUNC_SEEK_CUR)==0)
-                uSeek=0;
-            else
-                err=UNZ_ERRNO;
-        }
-        if ((file_info.size_file_extra>0) && (extraFieldBufferSize>0))
-            if (ZREAD(s->z_filefunc, s->filestream,extraField,uSizeRead)!=uSizeRead)
-                err=UNZ_ERRNO;
-        uSeek += file_info.size_file_extra - uSizeRead;
-    }
-    else
-        uSeek+=file_info.size_file_extra;
-
-
-    if ((err==UNZ_OK) && (szComment!=NULL))
-    {
-        uLong uSizeRead ;
-        if (file_info.size_file_comment<commentBufferSize)
-        {
-            *(szComment+file_info.size_file_comment)='\0';
-            uSizeRead = file_info.size_file_comment;
-        }
-        else
-            uSizeRead = commentBufferSize;
-
-        if (uSeek!=0) {
-            if (ZSEEK(s->z_filefunc, s->filestream,uSeek,ZLIB_FILEFUNC_SEEK_CUR)==0)
-                uSeek=0;
-            else
-                err=UNZ_ERRNO;
-        }
-        if ((file_info.size_file_comment>0) && (commentBufferSize>0))
-            if (ZREAD(s->z_filefunc, s->filestream,szComment,uSizeRead)!=uSizeRead)
-                err=UNZ_ERRNO;
-        uSeek+=file_info.size_file_comment - uSizeRead;
-    }
-    else
-        uSeek+=file_info.size_file_comment;
-
-    if ((err==UNZ_OK) && (pfile_info!=NULL))
-        *pfile_info=file_info;
-
-    if ((err==UNZ_OK) && (pfile_info_internal!=NULL))
-        *pfile_info_internal=file_info_internal;
-
-    return err;
-}
-
-
-
-/*
-  Write info about the ZipFile in the *pglobal_info structure.
-  No preparation of the structure is needed
-  return UNZ_OK if there is no problem.
-*/
-extern int ZEXPORT unzGetCurrentFileInfo (file,
-                                          pfile_info,
-                                          szFileName, fileNameBufferSize,
-                                          extraField, extraFieldBufferSize,
-                                          szComment,  commentBufferSize)
-    unzFile file;
-    unz_file_info *pfile_info;
-    char *szFileName;
-    uLong fileNameBufferSize;
-    void *extraField;
-    uLong extraFieldBufferSize;
-    char *szComment;
-    uLong commentBufferSize;
-{
-    return unzlocal_GetCurrentFileInfoInternal(file,pfile_info,NULL,
-                                                szFileName,fileNameBufferSize,
-                                                extraField,extraFieldBufferSize,
-                                                szComment,commentBufferSize);
-}
-
-/*
-  Set the current file of the zipfile to the first file.
-  return UNZ_OK if there is no problem
-*/
-extern int ZEXPORT unzGoToFirstFile (file)
-    unzFile file;
-{
-    int err=UNZ_OK;
-    unz_s* s;
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz_s*)file;
-    s->pos_in_central_dir=s->offset_central_dir;
-    s->num_file=0;
-    err=unzlocal_GetCurrentFileInfoInternal(file,&s->cur_file_info,
-                                             &s->cur_file_info_internal,
-                                             NULL,0,NULL,0,NULL,0);
-    s->current_file_ok = (err == UNZ_OK);
-    return err;
-}
-
-/*
-  Set the current file of the zipfile to the next file.
-  return UNZ_OK if there is no problem
-  return UNZ_END_OF_LIST_OF_FILE if the actual file was the latest.
-*/
-extern int ZEXPORT unzGoToNextFile (file)
-    unzFile file;
-{
-    unz_s* s;
-    int err;
-
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz_s*)file;
-    if (!s->current_file_ok)
-        return UNZ_END_OF_LIST_OF_FILE;
-    if (s->gi.number_entry != 0xffff)    /* 2^16 files overflow hack */
-      if (s->num_file+1==s->gi.number_entry)
-        return UNZ_END_OF_LIST_OF_FILE;
-
-    s->pos_in_central_dir += SIZECENTRALDIRITEM + s->cur_file_info.size_filename +
-            s->cur_file_info.size_file_extra + s->cur_file_info.size_file_comment ;
-    s->num_file++;
-    err = unzlocal_GetCurrentFileInfoInternal(file,&s->cur_file_info,
-                                               &s->cur_file_info_internal,
-                                               NULL,0,NULL,0,NULL,0);
-    s->current_file_ok = (err == UNZ_OK);
-    return err;
-}
-
-
-/*
-  Try locate the file szFileName in the zipfile.
-  For the iCaseSensitivity signification, see unzipStringFileNameCompare
-
-  return value :
-  UNZ_OK if the file is found. It becomes the current file.
-  UNZ_END_OF_LIST_OF_FILE if the file is not found
-*/
-extern int ZEXPORT unzLocateFile (file, szFileName, iCaseSensitivity)
-    unzFile file;
-    const char *szFileName;
-    int iCaseSensitivity;
-{
-    unz_s* s;
-    int err;
-
-    /* We remember the 'current' position in the file so that we can jump
-     * back there if we fail.
-     */
-    unz_file_info cur_file_infoSaved;
-    unz_file_info_internal cur_file_info_internalSaved;
-    uLong num_fileSaved;
-    uLong pos_in_central_dirSaved;
-
-
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-
-    if (strlen(szFileName)>=UNZ_MAXFILENAMEINZIP)
-        return UNZ_PARAMERROR;
-
-    s=(unz_s*)file;
-    if (!s->current_file_ok)
-        return UNZ_END_OF_LIST_OF_FILE;
-
-    /* Save the current state */
-    num_fileSaved = s->num_file;
-    pos_in_central_dirSaved = s->pos_in_central_dir;
-    cur_file_infoSaved = s->cur_file_info;
-    cur_file_info_internalSaved = s->cur_file_info_internal;
-
-    err = unzGoToFirstFile(file);
-
-    while (err == UNZ_OK)
-    {
-        char szCurrentFileName[UNZ_MAXFILENAMEINZIP+1];
-        err = unzGetCurrentFileInfo(file,NULL,
-                                    szCurrentFileName,sizeof(szCurrentFileName)-1,
-                                    NULL,0,NULL,0);
-        if (err == UNZ_OK)
-        {
-            if (unzStringFileNameCompare(szCurrentFileName,
-                                            szFileName,iCaseSensitivity)==0)
-                return UNZ_OK;
-            err = unzGoToNextFile(file);
-        }
-    }
-
-    /* We failed, so restore the state of the 'current file' to where we
-     * were.
-     */
-    s->num_file = num_fileSaved ;
-    s->pos_in_central_dir = pos_in_central_dirSaved ;
-    s->cur_file_info = cur_file_infoSaved;
-    s->cur_file_info_internal = cur_file_info_internalSaved;
-    return err;
-}
-
-
-/*
-///////////////////////////////////////////
-// Contributed by Ryan Haksi (mailto://cryogen@infoserve.net)
-// I need random access
-//
-// Further optimization could be realized by adding an ability
-// to cache the directory in memory. The goal being a single
-// comprehensive file read to put the file I need in a memory.
-*/
-
-/*
-typedef struct unz_file_pos_s
-{
-    uLong pos_in_zip_directory;   // offset in file
-    uLong num_of_file;            // # of file
-} unz_file_pos;
-*/
-
-extern int ZEXPORT unzGetFilePos(file, file_pos)
-    unzFile file;
-    unz_file_pos* file_pos;
-{
-    unz_s* s;
-
-    if (file==NULL || file_pos==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz_s*)file;
-    if (!s->current_file_ok)
-        return UNZ_END_OF_LIST_OF_FILE;
-
-    file_pos->pos_in_zip_directory  = s->pos_in_central_dir;
-    file_pos->num_of_file           = s->num_file;
-
-    return UNZ_OK;
-}
-
-extern int ZEXPORT unzGoToFilePos(file, file_pos)
-    unzFile file;
-    unz_file_pos* file_pos;
-{
-    unz_s* s;
-    int err;
-
-    if (file==NULL || file_pos==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz_s*)file;
-
-    /* jump to the right spot */
-    s->pos_in_central_dir = file_pos->pos_in_zip_directory;
-    s->num_file           = file_pos->num_of_file;
-
-    /* set the current file */
-    err = unzlocal_GetCurrentFileInfoInternal(file,&s->cur_file_info,
-                                               &s->cur_file_info_internal,
-                                               NULL,0,NULL,0,NULL,0);
-    /* return results */
-    s->current_file_ok = (err == UNZ_OK);
-    return err;
-}
-
-/*
-// Unzip Helper Functions - should be here?
-///////////////////////////////////////////
-*/
-
-/*
-  Read the local header of the current zipfile
-  Check the coherency of the local header and info in the end of central
-        directory about this file
-  store in *piSizeVar the size of extra info in local header
-        (filename and size of extra field data)
-*/
-local int unzlocal_CheckCurrentFileCoherencyHeader (s,piSizeVar,
-                                                    poffset_local_extrafield,
-                                                    psize_local_extrafield)
-    unz_s* s;
-    uInt* piSizeVar;
-    uLong *poffset_local_extrafield;
-    uInt  *psize_local_extrafield;
-{
-    uLong uMagic,uData,uFlags;
-    uLong size_filename;
-    uLong size_extra_field;
-    int err=UNZ_OK;
-
-    *piSizeVar = 0;
-    *poffset_local_extrafield = 0;
-    *psize_local_extrafield = 0;
-
-    if (ZSEEK(s->z_filefunc, s->filestream,s->cur_file_info_internal.offset_curfile +
-                                s->byte_before_the_zipfile,ZLIB_FILEFUNC_SEEK_SET)!=0)
-        return UNZ_ERRNO;
-
-
-    if (err==UNZ_OK) {
-        if (unzlocal_getLong(&s->z_filefunc, s->filestream,&uMagic) != UNZ_OK)
-            err=UNZ_ERRNO;
-        else if (uMagic!=0x04034b50)
-            err=UNZ_BADZIPFILE;
-    }
-
-    if (unzlocal_getShort(&s->z_filefunc, s->filestream,&uData) != UNZ_OK)
-        err=UNZ_ERRNO;
-/*
-    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.wVersion))
-        err=UNZ_BADZIPFILE;
-*/
-    if (unzlocal_getShort(&s->z_filefunc, s->filestream,&uFlags) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unzlocal_getShort(&s->z_filefunc, s->filestream,&uData) != UNZ_OK)
-        err=UNZ_ERRNO;
-    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.compression_method))
-        err=UNZ_BADZIPFILE;
-
-    if ((err==UNZ_OK) && (s->cur_file_info.compression_method!=0) &&
-                         (s->cur_file_info.compression_method!=Z_DEFLATED))
-        err=UNZ_BADZIPFILE;
-
-    if (unzlocal_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* date/time */
-        err=UNZ_ERRNO;
-
-    if (unzlocal_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* crc */
-        err=UNZ_ERRNO;
-    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.crc) &&
-                              ((uFlags & 8)==0))
-        err=UNZ_BADZIPFILE;
-
-    if (unzlocal_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* size compr */
-        err=UNZ_ERRNO;
-    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.compressed_size) &&
-                              ((uFlags & 8)==0))
-        err=UNZ_BADZIPFILE;
-
-    if (unzlocal_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* size uncompr */
-        err=UNZ_ERRNO;
-    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.uncompressed_size) &&
-                              ((uFlags & 8)==0))
-        err=UNZ_BADZIPFILE;
-
-
-    if (unzlocal_getShort(&s->z_filefunc, s->filestream,&size_filename) != UNZ_OK)
-        err=UNZ_ERRNO;
-    else if ((err==UNZ_OK) && (size_filename!=s->cur_file_info.size_filename))
-        err=UNZ_BADZIPFILE;
-
-    *piSizeVar += (uInt)size_filename;
-
-    if (unzlocal_getShort(&s->z_filefunc, s->filestream,&size_extra_field) != UNZ_OK)
-        err=UNZ_ERRNO;
-    *poffset_local_extrafield= s->cur_file_info_internal.offset_curfile +
-                                    SIZEZIPLOCALHEADER + size_filename;
-    *psize_local_extrafield = (uInt)size_extra_field;
-
-    *piSizeVar += (uInt)size_extra_field;
-
-    return err;
-}
-
-/*
-  Open for reading data the current file in the zipfile.
-  If there is no error and the file is opened, the return value is UNZ_OK.
-*/
-extern int ZEXPORT unzOpenCurrentFile3 (file, method, level, raw, password)
-    unzFile file;
-    int* method;
-    int* level;
-    int raw;
-    const char* password;
-{
-    int err=UNZ_OK;
-    uInt iSizeVar;
-    unz_s* s;
-    file_in_zip_read_info_s* pfile_in_zip_read_info;
-    uLong offset_local_extrafield;  /* offset of the local extra field */
-    uInt  size_local_extrafield;    /* size of the local extra field */
-#    ifndef NOUNCRYPT
-    char source[12];
-#    else
-    if (password != NULL)
-        return UNZ_PARAMERROR;
-#    endif
-
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz_s*)file;
-    if (!s->current_file_ok)
-        return UNZ_PARAMERROR;
-
-    if (s->pfile_in_zip_read != NULL)
-        unzCloseCurrentFile(file);
-
-    if (unzlocal_CheckCurrentFileCoherencyHeader(s,&iSizeVar,
-                &offset_local_extrafield,&size_local_extrafield)!=UNZ_OK)
-        return UNZ_BADZIPFILE;
-
-    pfile_in_zip_read_info = (file_in_zip_read_info_s*)
-                                        ALLOC(sizeof(file_in_zip_read_info_s));
-    if (pfile_in_zip_read_info==NULL)
-        return UNZ_INTERNALERROR;
-
-    pfile_in_zip_read_info->read_buffer=(char*)ALLOC(UNZ_BUFSIZE);
-    pfile_in_zip_read_info->offset_local_extrafield = offset_local_extrafield;
-    pfile_in_zip_read_info->size_local_extrafield = size_local_extrafield;
-    pfile_in_zip_read_info->pos_local_extrafield=0;
-    pfile_in_zip_read_info->raw=raw;
-
-    if (pfile_in_zip_read_info->read_buffer==NULL)
-    {
-        TRYFREE(pfile_in_zip_read_info);
-        return UNZ_INTERNALERROR;
-    }
-
-    pfile_in_zip_read_info->stream_initialised=0;
-
-    if (method!=NULL)
-        *method = (int)s->cur_file_info.compression_method;
-
-    if (level!=NULL)
-    {
-        *level = 6;
-        switch (s->cur_file_info.flag & 0x06)
-        {
-          case 6 : *level = 1; break;
-          case 4 : *level = 2; break;
-          case 2 : *level = 9; break;
-        }
-    }
-
-    if ((s->cur_file_info.compression_method!=0) &&
-        (s->cur_file_info.compression_method!=Z_DEFLATED))
-        err=UNZ_BADZIPFILE;
-
-    pfile_in_zip_read_info->crc32_wait=s->cur_file_info.crc;
-    pfile_in_zip_read_info->crc32=0;
-    pfile_in_zip_read_info->compression_method =
-            s->cur_file_info.compression_method;
-    pfile_in_zip_read_info->filestream=s->filestream;
-    pfile_in_zip_read_info->z_filefunc=s->z_filefunc;
-    pfile_in_zip_read_info->byte_before_the_zipfile=s->byte_before_the_zipfile;
-
-    pfile_in_zip_read_info->stream.total_out = 0;
-
-    if ((s->cur_file_info.compression_method==Z_DEFLATED) &&
-        (!raw))
-    {
-      pfile_in_zip_read_info->stream.zalloc = (alloc_func)0;
-      pfile_in_zip_read_info->stream.zfree = (free_func)0;
-      pfile_in_zip_read_info->stream.opaque = (voidpf)0;
-      pfile_in_zip_read_info->stream.next_in = (voidpf)0;
-      pfile_in_zip_read_info->stream.avail_in = 0;
-
-      err=inflateInit2(&pfile_in_zip_read_info->stream, -MAX_WBITS);
-      if (err == Z_OK)
-        pfile_in_zip_read_info->stream_initialised=1;
-      else
-      {
-        TRYFREE(pfile_in_zip_read_info);
-        return err;
-      }
-        /* windowBits is passed < 0 to tell that there is no zlib header.
-         * Note that in this case inflate *requires* an extra "dummy" byte
-         * after the compressed stream in order to complete decompression and
-         * return Z_STREAM_END.
-         * In unzip, i don't wait absolutely Z_STREAM_END because I known the
-         * size of both compressed and uncompressed data
-         */
-    }
-    pfile_in_zip_read_info->rest_read_compressed =
-            s->cur_file_info.compressed_size ;
-    pfile_in_zip_read_info->rest_read_uncompressed =
-            s->cur_file_info.uncompressed_size ;
-
-
-    pfile_in_zip_read_info->pos_in_zipfile =
-            s->cur_file_info_internal.offset_curfile + SIZEZIPLOCALHEADER +
-              iSizeVar;
-
-    pfile_in_zip_read_info->stream.avail_in = (uInt)0;
-
-    s->pfile_in_zip_read = pfile_in_zip_read_info;
-
-#    ifndef NOUNCRYPT
-    if (password != NULL)
-    {
-        int i;
-        s->pcrc_32_tab = get_crc_table();
-        init_keys(password,s->keys,s->pcrc_32_tab);
-        if (ZSEEK(s->z_filefunc, s->filestream,
-                  s->pfile_in_zip_read->pos_in_zipfile +
-                     s->pfile_in_zip_read->byte_before_the_zipfile,
-                  SEEK_SET)!=0)
-            return UNZ_INTERNALERROR;
-        if(ZREAD(s->z_filefunc, s->filestream,source, 12)<12)
-            return UNZ_INTERNALERROR;
-
-        for (i = 0; i<12; i++)
-            zdecode(s->keys,s->pcrc_32_tab,source[i]);
-
-        s->pfile_in_zip_read->pos_in_zipfile+=12;
-        s->encrypted=1;
-    }
-#    endif
-
-
-    return UNZ_OK;
-}
-
-extern int ZEXPORT unzOpenCurrentFile (file)
-    unzFile file;
-{
-    return unzOpenCurrentFile3(file, NULL, NULL, 0, NULL);
-}
-
-extern int ZEXPORT unzOpenCurrentFilePassword (file, password)
-    unzFile file;
-    const char* password;
-{
-    return unzOpenCurrentFile3(file, NULL, NULL, 0, password);
-}
-
-extern int ZEXPORT unzOpenCurrentFile2 (file,method,level,raw)
-    unzFile file;
-    int* method;
-    int* level;
-    int raw;
-{
-    return unzOpenCurrentFile3(file, method, level, raw, NULL);
-}
-
-/*
-  Read bytes from the current file.
-  buf contain buffer where data must be copied
-  len the size of buf.
-
-  return the number of byte copied if somes bytes are copied
-  return 0 if the end of file was reached
-  return <0 with error code if there is an error
-    (UNZ_ERRNO for IO error, or zLib error for uncompress error)
-*/
-extern int ZEXPORT unzReadCurrentFile  (file, buf, len)
-    unzFile file;
-    voidp buf;
-    unsigned len;
-{
-    int err=UNZ_OK;
-    uInt iRead = 0;
-    unz_s* s;
-    file_in_zip_read_info_s* pfile_in_zip_read_info;
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz_s*)file;
-    pfile_in_zip_read_info=s->pfile_in_zip_read;
-
-    if (pfile_in_zip_read_info==NULL)
-        return UNZ_PARAMERROR;
-
-
-    if ((pfile_in_zip_read_info->read_buffer == NULL))
-        return UNZ_END_OF_LIST_OF_FILE;
-    if (len==0)
-        return 0;
-
-    pfile_in_zip_read_info->stream.next_out = (Bytef*)buf;
-
-    pfile_in_zip_read_info->stream.avail_out = (uInt)len;
-
-    if ((len>pfile_in_zip_read_info->rest_read_uncompressed) &&
-        (!(pfile_in_zip_read_info->raw)))
-        pfile_in_zip_read_info->stream.avail_out =
-            (uInt)pfile_in_zip_read_info->rest_read_uncompressed;
-
-    if ((len>pfile_in_zip_read_info->rest_read_compressed+
-           pfile_in_zip_read_info->stream.avail_in) &&
-         (pfile_in_zip_read_info->raw))
-        pfile_in_zip_read_info->stream.avail_out =
-            (uInt)pfile_in_zip_read_info->rest_read_compressed+
-            pfile_in_zip_read_info->stream.avail_in;
-
-    while (pfile_in_zip_read_info->stream.avail_out>0)
-    {
-        if ((pfile_in_zip_read_info->stream.avail_in==0) &&
-            (pfile_in_zip_read_info->rest_read_compressed>0))
-        {
-            uInt uReadThis = UNZ_BUFSIZE;
-            if (pfile_in_zip_read_info->rest_read_compressed<uReadThis)
-                uReadThis = (uInt)pfile_in_zip_read_info->rest_read_compressed;
-            if (uReadThis == 0)
-                return UNZ_EOF;
-            if (ZSEEK(pfile_in_zip_read_info->z_filefunc,
-                      pfile_in_zip_read_info->filestream,
-                      pfile_in_zip_read_info->pos_in_zipfile +
-                         pfile_in_zip_read_info->byte_before_the_zipfile,
-                         ZLIB_FILEFUNC_SEEK_SET)!=0)
-                return UNZ_ERRNO;
-            if (ZREAD(pfile_in_zip_read_info->z_filefunc,
-                      pfile_in_zip_read_info->filestream,
-                      pfile_in_zip_read_info->read_buffer,
-                      uReadThis)!=uReadThis)
-                return UNZ_ERRNO;
-
-
-#            ifndef NOUNCRYPT
-            if(s->encrypted)
-            {
-                uInt i;
-                for(i=0;i<uReadThis;i++)
-                  pfile_in_zip_read_info->read_buffer[i] =
-                      zdecode(s->keys,s->pcrc_32_tab,
-                              pfile_in_zip_read_info->read_buffer[i]);
-            }
-#            endif
-
-
-            pfile_in_zip_read_info->pos_in_zipfile += uReadThis;
-
-            pfile_in_zip_read_info->rest_read_compressed-=uReadThis;
-
-            pfile_in_zip_read_info->stream.next_in =
-                (Bytef*)pfile_in_zip_read_info->read_buffer;
-            pfile_in_zip_read_info->stream.avail_in = (uInt)uReadThis;
-        }
-
-        if ((pfile_in_zip_read_info->compression_method==0) || (pfile_in_zip_read_info->raw))
-        {
-            uInt uDoCopy,i ;
-
-            if ((pfile_in_zip_read_info->stream.avail_in == 0) &&
-                (pfile_in_zip_read_info->rest_read_compressed == 0))
-                return (iRead==0) ? UNZ_EOF : iRead;
-
-            if (pfile_in_zip_read_info->stream.avail_out <
-                            pfile_in_zip_read_info->stream.avail_in)
-                uDoCopy = pfile_in_zip_read_info->stream.avail_out ;
-            else
-                uDoCopy = pfile_in_zip_read_info->stream.avail_in ;
-
-            for (i=0;i<uDoCopy;i++)
-                *(pfile_in_zip_read_info->stream.next_out+i) =
-                        *(pfile_in_zip_read_info->stream.next_in+i);
-
-            pfile_in_zip_read_info->crc32 = crc32(pfile_in_zip_read_info->crc32,
-                                pfile_in_zip_read_info->stream.next_out,
-                                uDoCopy);
-            pfile_in_zip_read_info->rest_read_uncompressed-=uDoCopy;
-            pfile_in_zip_read_info->stream.avail_in -= uDoCopy;
-            pfile_in_zip_read_info->stream.avail_out -= uDoCopy;
-            pfile_in_zip_read_info->stream.next_out += uDoCopy;
-            pfile_in_zip_read_info->stream.next_in += uDoCopy;
-            pfile_in_zip_read_info->stream.total_out += uDoCopy;
-            iRead += uDoCopy;
-        }
-        else
-        {
-            uLong uTotalOutBefore,uTotalOutAfter;
-            const Bytef *bufBefore;
-            uLong uOutThis;
-            int flush=Z_SYNC_FLUSH;
-
-            uTotalOutBefore = pfile_in_zip_read_info->stream.total_out;
-            bufBefore = pfile_in_zip_read_info->stream.next_out;
-
-            /*
-            if ((pfile_in_zip_read_info->rest_read_uncompressed ==
-                     pfile_in_zip_read_info->stream.avail_out) &&
-                (pfile_in_zip_read_info->rest_read_compressed == 0))
-                flush = Z_FINISH;
-            */
-            err=inflate(&pfile_in_zip_read_info->stream,flush);
-
-            if ((err>=0) && (pfile_in_zip_read_info->stream.msg!=NULL))
-              err = Z_DATA_ERROR;
-
-            uTotalOutAfter = pfile_in_zip_read_info->stream.total_out;
-            uOutThis = uTotalOutAfter-uTotalOutBefore;
-
-            pfile_in_zip_read_info->crc32 =
-                crc32(pfile_in_zip_read_info->crc32,bufBefore,
-                        (uInt)(uOutThis));
-
-            pfile_in_zip_read_info->rest_read_uncompressed -=
-                uOutThis;
-
-            iRead += (uInt)(uTotalOutAfter - uTotalOutBefore);
-
-            if (err==Z_STREAM_END)
-                return (iRead==0) ? UNZ_EOF : iRead;
-            if (err!=Z_OK)
-                break;
-        }
-    }
-
-    if (err==Z_OK)
-        return iRead;
-    return err;
-}
-
-
-/*
-  Give the current position in uncompressed data
-*/
-extern z_off_t ZEXPORT unztell (file)
-    unzFile file;
-{
-    unz_s* s;
-    file_in_zip_read_info_s* pfile_in_zip_read_info;
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz_s*)file;
-    pfile_in_zip_read_info=s->pfile_in_zip_read;
-
-    if (pfile_in_zip_read_info==NULL)
-        return UNZ_PARAMERROR;
-
-    return (z_off_t)pfile_in_zip_read_info->stream.total_out;
-}
-
-
-/*
-  return 1 if the end of file was reached, 0 elsewhere
-*/
-extern int ZEXPORT unzeof (file)
-    unzFile file;
-{
-    unz_s* s;
-    file_in_zip_read_info_s* pfile_in_zip_read_info;
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz_s*)file;
-    pfile_in_zip_read_info=s->pfile_in_zip_read;
-
-    if (pfile_in_zip_read_info==NULL)
-        return UNZ_PARAMERROR;
-
-    if (pfile_in_zip_read_info->rest_read_uncompressed == 0)
-        return 1;
-    else
-        return 0;
-}
-
-
-
-/*
-  Read extra field from the current file (opened by unzOpenCurrentFile)
-  This is the local-header version of the extra field (sometimes, there is
-    more info in the local-header version than in the central-header)
-
-  if buf==NULL, it return the size of the local extra field that can be read
-
-  if buf!=NULL, len is the size of the buffer, the extra header is copied in
-    buf.
-  the return value is the number of bytes copied in buf, or (if <0)
-    the error code
-*/
-extern int ZEXPORT unzGetLocalExtrafield (file,buf,len)
-    unzFile file;
-    voidp buf;
-    unsigned len;
-{
-    unz_s* s;
-    file_in_zip_read_info_s* pfile_in_zip_read_info;
-    uInt read_now;
-    uLong size_to_read;
-
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz_s*)file;
-    pfile_in_zip_read_info=s->pfile_in_zip_read;
-
-    if (pfile_in_zip_read_info==NULL)
-        return UNZ_PARAMERROR;
-
-    size_to_read = (pfile_in_zip_read_info->size_local_extrafield -
-                pfile_in_zip_read_info->pos_local_extrafield);
-
-    if (buf==NULL)
-        return (int)size_to_read;
-
-    if (len>size_to_read)
-        read_now = (uInt)size_to_read;
-    else
-        read_now = (uInt)len ;
-
-    if (read_now==0)
-        return 0;
-
-    if (ZSEEK(pfile_in_zip_read_info->z_filefunc,
-              pfile_in_zip_read_info->filestream,
-              pfile_in_zip_read_info->offset_local_extrafield +
-              pfile_in_zip_read_info->pos_local_extrafield,
-              ZLIB_FILEFUNC_SEEK_SET)!=0)
-        return UNZ_ERRNO;
-
-    if (ZREAD(pfile_in_zip_read_info->z_filefunc,
-              pfile_in_zip_read_info->filestream,
-              buf,read_now)!=read_now)
-        return UNZ_ERRNO;
-
-    return (int)read_now;
-}
-
-/*
-  Close the file in zip opened with unzipOpenCurrentFile
-  Return UNZ_CRCERROR if all the file was read but the CRC is not good
-*/
-extern int ZEXPORT unzCloseCurrentFile (file)
-    unzFile file;
-{
-    int err=UNZ_OK;
-
-    unz_s* s;
-    file_in_zip_read_info_s* pfile_in_zip_read_info;
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz_s*)file;
-    pfile_in_zip_read_info=s->pfile_in_zip_read;
-
-    if (pfile_in_zip_read_info==NULL)
-        return UNZ_PARAMERROR;
-
-
-    if ((pfile_in_zip_read_info->rest_read_uncompressed == 0) &&
-        (!pfile_in_zip_read_info->raw))
-    {
-        if (pfile_in_zip_read_info->crc32 != pfile_in_zip_read_info->crc32_wait)
-            err=UNZ_CRCERROR;
-    }
-
-
-    TRYFREE(pfile_in_zip_read_info->read_buffer);
-    pfile_in_zip_read_info->read_buffer = NULL;
-    if (pfile_in_zip_read_info->stream_initialised)
-        inflateEnd(&pfile_in_zip_read_info->stream);
-
-    pfile_in_zip_read_info->stream_initialised = 0;
-    TRYFREE(pfile_in_zip_read_info);
-
-    s->pfile_in_zip_read=NULL;
-
-    return err;
-}
-
-
-/*
-  Get the global comment string of the ZipFile, in the szComment buffer.
-  uSizeBuf is the size of the szComment buffer.
-  return the number of byte copied or an error code <0
-*/
-extern int ZEXPORT unzGetGlobalComment (file, szComment, uSizeBuf)
-    unzFile file;
-    char *szComment;
-    uLong uSizeBuf;
-{
-    unz_s* s;
-    uLong uReadThis ;
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz_s*)file;
-
-    uReadThis = uSizeBuf;
-    if (uReadThis>s->gi.size_comment)
-        uReadThis = s->gi.size_comment;
-
-    if (ZSEEK(s->z_filefunc,s->filestream,s->central_pos+22,ZLIB_FILEFUNC_SEEK_SET)!=0)
-        return UNZ_ERRNO;
-
-    if (uReadThis>0)
-    {
-      *szComment='\0';
-      if (ZREAD(s->z_filefunc,s->filestream,szComment,uReadThis)!=uReadThis)
-        return UNZ_ERRNO;
-    }
-
-    if ((szComment != NULL) && (uSizeBuf > s->gi.size_comment))
-        *(szComment+s->gi.size_comment)='\0';
-    return (int)uReadThis;
-}
-
-/* Additions by RX '2004 */
-extern uLong ZEXPORT unzGetOffset (file)
-    unzFile file;
-{
-    unz_s* s;
-
-    if (file==NULL)
-          return UNZ_PARAMERROR;
-    s=(unz_s*)file;
-    if (!s->current_file_ok)
-      return 0;
-    if (s->gi.number_entry != 0 && s->gi.number_entry != 0xffff)
-      if (s->num_file==s->gi.number_entry)
-         return 0;
-    return s->pos_in_central_dir;
-}
-
-extern int ZEXPORT unzSetOffset (file, pos)
-        unzFile file;
-        uLong pos;
-{
-    unz_s* s;
-    int err;
-
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz_s*)file;
-
-    s->pos_in_central_dir = pos;
-    s->num_file = s->gi.number_entry;      /* hack */
-    err = unzlocal_GetCurrentFileInfoInternal(file,&s->cur_file_info,
-                                              &s->cur_file_info_internal,
-                                              NULL,0,NULL,0,NULL,0);
-    s->current_file_ok = (err == UNZ_OK);
-    return err;
-}
+/* unzip.c -- IO for uncompress .zip files using zlib
+   Version 1.1, February 14h, 2010
+   part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )
+
+         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )
+
+         Modifications of Unzip for Zip64
+         Copyright (C) 2007-2008 Even Rouault
+
+         Modifications for Zip64 support on both zip and unzip
+         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )
+
+         Modifications for QIODevice support and other QuaZip fixes
+         Copyright (C) 2005-2014 Sergey A. Tachenov
+
+         For more info read MiniZip_info.txt
+
+         Modifications for static code analysis report
+         Copyright (C) 2016 Intel Deutschland GmbH
+
+  ------------------------------------------------------------------------------------
+  Decryption code comes from crypt.c by Info-ZIP but has been greatly reduced in terms of
+  compatibility with older software. The following is from the original crypt.c.
+  Code woven in by Terry Thorsen 1/2003.
+
+  Copyright (c) 1990-2000 Info-ZIP.  All rights reserved.
+
+  See the accompanying file LICENSE, version 2000-Apr-09 or later
+  (the contents of which are also included in zip.h) for terms of use.
+  If, for some reason, all these files are missing, the Info-ZIP license
+  also may be found at:  ftp://ftp.info-zip.org/pub/infozip/license.html
+
+        crypt.c (full version) by Info-ZIP.      Last revised:  [see minizip_crypt.h]
+
+  The encryption/decryption parts of this source code (as opposed to the
+  non-echoing password parts) were originally written in Europe.  The
+  whole source package can be freely distributed, including from the USA.
+  (Prior to January 2000, re-export from the US was a violation of US law.)
+
+        This encryption code is a direct transcription of the algorithm from
+  Roger Schlafly, described by Phil Katz in the file appnote.txt.  This
+  file (appnote.txt) is distributed with the PKZIP program (even in the
+  version without encryption capabilities).
+
+        ------------------------------------------------------------------------------------
+
+        Changes in unzip.c
+
+        2007-2008 - Even Rouault - Addition of cpl_unzGetCurrentFileZStreamPos
+  2007-2008 - Even Rouault - Decoration of symbol names unz* -> cpl_unz*
+  2007-2008 - Even Rouault - Remove old C style function prototypes
+  2007-2008 - Even Rouault - Add unzip support for ZIP64
+
+        Copyright (C) 2007-2008 Even Rouault
+
+
+        Oct-2009 - Mathias Svensson - Removed cpl_* from symbol names (Even Rouault added them but since this is now moved to a new project (minizip64) I renamed them again).
+  Oct-2009 - Mathias Svensson - Fixed problem if uncompressed size was > 4G and compressed size was <4G
+                                should only read the compressed/uncompressed size from the Zip64 format if
+                                the size from normal header was 0xFFFFFFFF
+  Oct-2009 - Mathias Svensson - Applied some bug fixes from paches recived from Gilles Vollant
+        Oct-2009 - Mathias Svensson - Applied support to unzip files with compression mathod BZIP2 (bzip2 lib is required)
+                                Patch created by Daniel Borca
+
+  Jan-2010 - back to unzip and minizip 1.0 name scheme, with compatibility layer
+
+  Copyright (C) 1998 - 2010 Gilles Vollant, Even Rouault, Mathias Svensson
+
+*/
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <zlib.h>
+#if (ZLIB_VERNUM < 0x1270)
+typedef uLongf z_crc_t;
+#endif
+#include "unzip.h"
+
+#ifdef STDC
+#  include <stddef.h>
+#  include <string.h>
+#  include <stdlib.h>
+#endif
+#ifdef NO_ERRNO_H
+    extern int errno;
+#else
+#   include <errno.h>
+#endif
+
+
+#ifndef local
+#  define local static
+#endif
+/* compile with -Dlocal if your debugger can't find static symbols */
+
+
+#ifndef CASESENSITIVITYDEFAULT_NO
+#  if !defined(unix) && !defined(CASESENSITIVITYDEFAULT_YES)
+#    define CASESENSITIVITYDEFAULT_NO
+#  endif
+#endif
+
+
+#ifndef UNZ_BUFSIZE
+#define UNZ_BUFSIZE (16384)
+#endif
+
+#ifndef UNZ_MAXFILENAMEINZIP
+#define UNZ_MAXFILENAMEINZIP (256)
+#endif
+
+#ifndef ALLOC
+# define ALLOC(size) (malloc(size))
+#endif
+#ifndef TRYFREE
+# define TRYFREE(p) {if (p) free(p);}
+#endif
+
+#define SIZECENTRALDIRITEM (0x2e)
+#define SIZEZIPLOCALHEADER (0x1e)
+
+
+const char unz_copyright[] =
+   " unzip 1.01 Copyright 1998-2004 Gilles Vollant - http://www.winimage.com/zLibDll";
+
+/* unz_file_info_interntal contain internal info about a file in zipfile*/
+typedef struct unz_file_info64_internal_s
+{
+    ZPOS64_T offset_curfile;/* relative offset of local header 8 bytes */
+} unz_file_info64_internal;
+
+
+/* file_in_zip_read_info_s contain internal information about a file in zipfile,
+    when reading and decompress it */
+typedef struct
+{
+    char  *read_buffer;         /* internal buffer for compressed data */
+    z_stream stream;            /* zLib stream structure for inflate */
+
+#ifdef HAVE_BZIP2
+    bz_stream bstream;          /* bzLib stream structure for bziped */
+#endif
+
+    ZPOS64_T pos_in_zipfile;       /* position in byte on the zipfile, for fseek*/
+    uLong stream_initialised;   /* flag set if stream structure is initialised*/
+
+    ZPOS64_T offset_local_extrafield;/* offset of the local extra field */
+    uInt  size_local_extrafield;/* size of the local extra field */
+    ZPOS64_T pos_local_extrafield;   /* position in the local extra field in read*/
+    ZPOS64_T total_out_64;
+
+    uLong crc32;                /* crc32 of all data uncompressed */
+    uLong crc32_wait;           /* crc32 we must obtain after decompress all */
+    ZPOS64_T rest_read_compressed; /* number of byte to be decompressed */
+    ZPOS64_T rest_read_uncompressed;/*number of byte to be obtained after decomp*/
+    zlib_filefunc64_32_def z_filefunc;
+    voidpf filestream;        /* io structore of the zipfile */
+    uLong compression_method;   /* compression method (0==store) */
+    ZPOS64_T byte_before_the_zipfile;/* byte before the zipfile, (>0 for sfx)*/
+    int   raw;
+} file_in_zip64_read_info_s;
+
+
+/* unz64_s contain internal information about the zipfile
+*/
+typedef struct
+{
+    zlib_filefunc64_32_def z_filefunc;
+    int is64bitOpenFunction;
+    voidpf filestream;        /* io structore of the zipfile */
+    unz_global_info64 gi;       /* public global information */
+    ZPOS64_T byte_before_the_zipfile;/* byte before the zipfile, (>0 for sfx)*/
+    ZPOS64_T num_file;             /* number of the current file in the zipfile*/
+    ZPOS64_T pos_in_central_dir;   /* pos of the current file in the central dir*/
+    ZPOS64_T current_file_ok;      /* flag about the usability of the current file*/
+    ZPOS64_T central_pos;          /* position of the beginning of the central dir*/
+
+    ZPOS64_T size_central_dir;     /* size of the central directory  */
+    ZPOS64_T offset_central_dir;   /* offset of start of central directory with
+                                   respect to the starting disk number */
+
+    unz_file_info64 cur_file_info; /* public info about the current file in zip*/
+    unz_file_info64_internal cur_file_info_internal; /* private info about it*/
+    file_in_zip64_read_info_s* pfile_in_zip_read; /* structure about the current
+                                        file if we are decompressing it */
+    int encrypted;
+
+    int isZip64;
+    unsigned flags;
+
+#    ifndef NOUNCRYPT
+    unsigned long keys[3];     /* keys defining the pseudo-random sequence */
+    const z_crc_t FAR * pcrc_32_tab;
+#    endif
+} unz64_s;
+
+
+#ifndef NOUNCRYPT
+#include "minizip_crypt.h"
+#endif
+
+/* ===========================================================================
+     Read a byte from a gz_stream; update next_in and avail_in. Return EOF
+   for end of file.
+   IN assertion: the stream s has been sucessfully opened for reading.
+*/
+
+
+local int unz64local_getByte OF((
+    const zlib_filefunc64_32_def* pzlib_filefunc_def,
+    voidpf filestream,
+    int *pi));
+
+local int unz64local_getByte(const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, int *pi)
+{
+    unsigned char c;
+    int err = (int)ZREAD64(*pzlib_filefunc_def,filestream,&c,1);
+    if (err==1)
+    {
+        *pi = (int)c;
+        return UNZ_OK;
+    }
+    else
+    {
+        if (ZERROR64(*pzlib_filefunc_def,filestream))
+            return UNZ_ERRNO;
+        else
+            return UNZ_EOF;
+    }
+}
+
+
+/* ===========================================================================
+   Reads a long in LSB order from the given gz_stream. Sets
+*/
+local int unz64local_getShort OF((
+    const zlib_filefunc64_32_def* pzlib_filefunc_def,
+    voidpf filestream,
+    uLong *pX));
+
+local int unz64local_getShort (const zlib_filefunc64_32_def* pzlib_filefunc_def,
+                             voidpf filestream,
+                             uLong *pX)
+{
+    uLong x ;
+    int i = 0;
+    int err;
+
+    err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
+    x = (uLong)i;
+
+    if (err==UNZ_OK)
+        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
+    x |= ((uLong)i)<<8;
+
+    if (err==UNZ_OK)
+        *pX = x;
+    else
+        *pX = 0;
+    return err;
+}
+
+local int unz64local_getLong OF((
+    const zlib_filefunc64_32_def* pzlib_filefunc_def,
+    voidpf filestream,
+    uLong *pX));
+
+local int unz64local_getLong (const zlib_filefunc64_32_def* pzlib_filefunc_def,
+                            voidpf filestream,
+                            uLong *pX)
+{
+    uLong x ;
+    int i = 0;
+    int err;
+
+    err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
+    x = (uLong)i;
+
+    if (err==UNZ_OK)
+        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
+    x |= ((uLong)i)<<8;
+
+    if (err==UNZ_OK)
+        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
+    x |= ((uLong)i)<<16;
+
+    if (err==UNZ_OK)
+        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
+    x += ((uLong)i)<<24;
+
+    if (err==UNZ_OK)
+        *pX = x;
+    else
+        *pX = 0;
+    return err;
+}
+
+local int unz64local_getLong64 OF((
+    const zlib_filefunc64_32_def* pzlib_filefunc_def,
+    voidpf filestream,
+    ZPOS64_T *pX));
+
+
+local int unz64local_getLong64 (const zlib_filefunc64_32_def* pzlib_filefunc_def,
+                            voidpf filestream,
+                            ZPOS64_T *pX)
+{
+    ZPOS64_T x ;
+    int i = 0;
+    int err;
+
+    err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
+    x = (ZPOS64_T)i;
+
+    if (err==UNZ_OK)
+        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
+    x |= ((ZPOS64_T)i)<<8;
+
+    if (err==UNZ_OK)
+        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
+    x |= ((ZPOS64_T)i)<<16;
+
+    if (err==UNZ_OK)
+        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
+    x |= ((ZPOS64_T)i)<<24;
+
+    if (err==UNZ_OK)
+        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
+    x |= ((ZPOS64_T)i)<<32;
+
+    if (err==UNZ_OK)
+        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
+    x |= ((ZPOS64_T)i)<<40;
+
+    if (err==UNZ_OK)
+        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
+    x |= ((ZPOS64_T)i)<<48;
+
+    if (err==UNZ_OK)
+        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
+    x |= ((ZPOS64_T)i)<<56;
+
+    if (err==UNZ_OK)
+        *pX = x;
+    else
+        *pX = 0;
+    return err;
+}
+
+/* My own strcmpi / strcasecmp */
+local int strcmpcasenosensitive_internal (const char* fileName1, const char* fileName2)
+{
+    for (;;)
+    {
+        char c1=*(fileName1++);
+        char c2=*(fileName2++);
+        if ((c1>='a') && (c1<='z'))
+            c1 -= 0x20;
+        if ((c2>='a') && (c2<='z'))
+            c2 -= 0x20;
+        if (c1=='\0')
+            return ((c2=='\0') ? 0 : -1);
+        if (c2=='\0')
+            return 1;
+        if (c1<c2)
+            return -1;
+        if (c1>c2)
+            return 1;
+    }
+}
+
+
+#ifdef  CASESENSITIVITYDEFAULT_NO
+#define CASESENSITIVITYDEFAULTVALUE 2
+#else
+#define CASESENSITIVITYDEFAULTVALUE 1
+#endif
+
+#ifndef STRCMPCASENOSENTIVEFUNCTION
+#define STRCMPCASENOSENTIVEFUNCTION strcmpcasenosensitive_internal
+#endif
+
+/*
+   Compare two filename (fileName1,fileName2).
+   If iCaseSenisivity = 1, comparision is case sensitivity (like strcmp)
+   If iCaseSenisivity = 2, comparision is not case sensitivity (like strcmpi
+                                                                or strcasecmp)
+   If iCaseSenisivity = 0, case sensitivity is defaut of your operating system
+        (like 1 on Unix, 2 on Windows)
+
+*/
+extern int ZEXPORT unzStringFileNameCompare (const char*  fileName1,
+                                                 const char*  fileName2,
+                                                 int iCaseSensitivity)
+
+{
+    if (iCaseSensitivity==0)
+        iCaseSensitivity=CASESENSITIVITYDEFAULTVALUE;
+
+    if (iCaseSensitivity==1)
+        return strcmp(fileName1,fileName2);
+
+    return STRCMPCASENOSENTIVEFUNCTION(fileName1,fileName2);
+}
+
+#ifndef BUFREADCOMMENT
+#define BUFREADCOMMENT (0x400)
+#endif
+
+/*
+  Locate the Central directory of a zipfile (at the end, just before
+    the global comment)
+*/
+local ZPOS64_T unz64local_SearchCentralDir OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream));
+local ZPOS64_T unz64local_SearchCentralDir(const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream)
+{
+    unsigned char* buf;
+    ZPOS64_T uSizeFile;
+    ZPOS64_T uBackRead;
+    ZPOS64_T uMaxBack=0xffff; /* maximum size of global comment */
+    ZPOS64_T uPosFound=0;
+
+    if (ZSEEK64(*pzlib_filefunc_def,filestream,0,ZLIB_FILEFUNC_SEEK_END) != 0)
+        return 0;
+
+
+    uSizeFile = ZTELL64(*pzlib_filefunc_def,filestream);
+
+    if (uMaxBack>uSizeFile)
+        uMaxBack = uSizeFile;
+
+    buf = (unsigned char*)ALLOC(BUFREADCOMMENT+4);
+    if (buf==NULL)
+        return 0;
+
+    uBackRead = 4;
+    while (uBackRead<uMaxBack)
+    {
+        uLong uReadSize;
+        ZPOS64_T uReadPos ;
+        int i;
+        if (uBackRead+BUFREADCOMMENT>uMaxBack)
+            uBackRead = uMaxBack;
+        else
+            uBackRead+=BUFREADCOMMENT;
+        uReadPos = uSizeFile-uBackRead ;
+
+        uReadSize = ((BUFREADCOMMENT+4) < (uSizeFile-uReadPos)) ?
+                     (BUFREADCOMMENT+4) : (uLong)(uSizeFile-uReadPos);
+        if (ZSEEK64(*pzlib_filefunc_def,filestream,uReadPos,ZLIB_FILEFUNC_SEEK_SET)!=0)
+            break;
+
+        if (ZREAD64(*pzlib_filefunc_def,filestream,buf,uReadSize)!=uReadSize)
+            break;
+
+        for (i=(int)uReadSize-3; (i--)>0;)
+            if (((*(buf+i))==0x50) && ((*(buf+i+1))==0x4b) &&
+                ((*(buf+i+2))==0x05) && ((*(buf+i+3))==0x06))
+            {
+                uPosFound = uReadPos+i;
+                break;
+            }
+
+        if (uPosFound!=0)
+            break;
+    }
+    TRYFREE(buf);
+    return uPosFound;
+}
+
+
+/*
+  Locate the Central directory 64 of a zipfile (at the end, just before
+    the global comment)
+*/
+local ZPOS64_T unz64local_SearchCentralDir64 OF((
+    const zlib_filefunc64_32_def* pzlib_filefunc_def,
+    voidpf filestream));
+
+local ZPOS64_T unz64local_SearchCentralDir64(const zlib_filefunc64_32_def* pzlib_filefunc_def,
+                                      voidpf filestream)
+{
+    unsigned char* buf;
+    ZPOS64_T uSizeFile;
+    ZPOS64_T uBackRead;
+    ZPOS64_T uMaxBack=0xffff; /* maximum size of global comment */
+    ZPOS64_T uPosFound=0;
+    uLong uL;
+                ZPOS64_T relativeOffset;
+
+    if (ZSEEK64(*pzlib_filefunc_def,filestream,0,ZLIB_FILEFUNC_SEEK_END) != 0)
+        return 0;
+
+
+    uSizeFile = ZTELL64(*pzlib_filefunc_def,filestream);
+
+    if (uMaxBack>uSizeFile)
+        uMaxBack = uSizeFile;
+
+    buf = (unsigned char*)ALLOC(BUFREADCOMMENT+4);
+    if (buf==NULL)
+        return 0;
+
+    uBackRead = 4;
+    while (uBackRead<uMaxBack)
+    {
+        uLong uReadSize;
+        ZPOS64_T uReadPos;
+        int i;
+        if (uBackRead+BUFREADCOMMENT>uMaxBack)
+            uBackRead = uMaxBack;
+        else
+            uBackRead+=BUFREADCOMMENT;
+        uReadPos = uSizeFile-uBackRead ;
+
+        uReadSize = ((BUFREADCOMMENT+4) < (uSizeFile-uReadPos)) ?
+                     (BUFREADCOMMENT+4) : (uLong)(uSizeFile-uReadPos);
+        if (ZSEEK64(*pzlib_filefunc_def,filestream,uReadPos,ZLIB_FILEFUNC_SEEK_SET)!=0)
+            break;
+
+        if (ZREAD64(*pzlib_filefunc_def,filestream,buf,uReadSize)!=uReadSize)
+            break;
+
+        for (i=(int)uReadSize-3; (i--)>0;)
+            if (((*(buf+i))==0x50) && ((*(buf+i+1))==0x4b) &&
+                ((*(buf+i+2))==0x06) && ((*(buf+i+3))==0x07))
+            {
+                uPosFound = uReadPos+i;
+                break;
+            }
+
+        if (uPosFound!=0)
+            break;
+    }
+    TRYFREE(buf);
+    if (uPosFound == 0)
+        return 0;
+
+    /* Zip64 end of central directory locator */
+    if (ZSEEK64(*pzlib_filefunc_def,filestream, uPosFound,ZLIB_FILEFUNC_SEEK_SET)!=0)
+        return 0;
+
+    /* the signature, already checked */
+    if (unz64local_getLong(pzlib_filefunc_def,filestream,&uL)!=UNZ_OK)
+        return 0;
+
+    /* number of the disk with the start of the zip64 end of  central directory */
+    if (unz64local_getLong(pzlib_filefunc_def,filestream,&uL)!=UNZ_OK)
+        return 0;
+    if (uL != 0)
+        return 0;
+
+    /* relative offset of the zip64 end of central directory record */
+    if (unz64local_getLong64(pzlib_filefunc_def,filestream,&relativeOffset)!=UNZ_OK)
+        return 0;
+
+    /* total number of disks */
+    if (unz64local_getLong(pzlib_filefunc_def,filestream,&uL)!=UNZ_OK)
+        return 0;
+    if (uL != 1)
+        return 0;
+
+    /* Goto end of central directory record */
+    if (ZSEEK64(*pzlib_filefunc_def,filestream, relativeOffset,ZLIB_FILEFUNC_SEEK_SET)!=0)
+        return 0;
+
+     /* the signature */
+    if (unz64local_getLong(pzlib_filefunc_def,filestream,&uL)!=UNZ_OK)
+        return 0;
+
+    if (uL != 0x06064b50)
+        return 0;
+
+    return relativeOffset;
+}
+
+/*
+  Open a Zip file. path contain the full pathname (by example,
+     on a Windows NT computer "c:\\test\\zlib114.zip" or on an Unix computer
+     "zlib/zlib114.zip".
+     If the zipfile cannot be opened (file doesn't exist or in not valid), the
+       return value is NULL.
+     Else, the return value is a unzFile Handle, usable with other function
+       of this unzip package.
+*/
+extern unzFile unzOpenInternal (voidpf file,
+                               zlib_filefunc64_32_def* pzlib_filefunc64_32_def,
+                               int is64bitOpenFunction, unsigned flags)
+{
+    unz64_s us;
+    unz64_s *s;
+    ZPOS64_T central_pos;
+    uLong   uL;
+
+    uLong number_disk;          /* number of the current dist, used for
+                                   spaning ZIP, unsupported, always 0*/
+    uLong number_disk_with_CD;  /* number the the disk with central dir, used
+                                   for spaning ZIP, unsupported, always 0*/
+    ZPOS64_T number_entry_CD;      /* total number of entries in
+                                   the central dir
+                                   (same than number_entry on nospan) */
+
+    int err=UNZ_OK;
+
+    if (unz_copyright[0]!=' ')
+        return NULL;
+
+    us.flags = flags;
+    us.z_filefunc.zseek32_file = NULL;
+    us.z_filefunc.ztell32_file = NULL;
+    if (pzlib_filefunc64_32_def==NULL)
+        fill_qiodevice64_filefunc(&us.z_filefunc.zfile_func64);
+    else
+        us.z_filefunc = *pzlib_filefunc64_32_def;
+    us.is64bitOpenFunction = is64bitOpenFunction;
+
+
+
+    us.filestream = ZOPEN64(us.z_filefunc,
+                                                 file,
+                                                 ZLIB_FILEFUNC_MODE_READ |
+                                                 ZLIB_FILEFUNC_MODE_EXISTING);
+    if (us.filestream==NULL)
+        return NULL;
+
+    central_pos = unz64local_SearchCentralDir64(&us.z_filefunc,us.filestream);
+    if (central_pos)
+    {
+        uLong uS;
+        ZPOS64_T uL64;
+
+        us.isZip64 = 1;
+
+        if (ZSEEK64(us.z_filefunc, us.filestream,
+                                      central_pos,ZLIB_FILEFUNC_SEEK_SET)!=0)
+        err=UNZ_ERRNO;
+
+        /* the signature, already checked */
+        if (unz64local_getLong(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)
+            err=UNZ_ERRNO;
+
+        /* size of zip64 end of central directory record */
+        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&uL64)!=UNZ_OK)
+            err=UNZ_ERRNO;
+
+        /* version made by */
+        if (unz64local_getShort(&us.z_filefunc, us.filestream,&uS)!=UNZ_OK)
+            err=UNZ_ERRNO;
+
+        /* version needed to extract */
+        if (unz64local_getShort(&us.z_filefunc, us.filestream,&uS)!=UNZ_OK)
+            err=UNZ_ERRNO;
+
+        /* number of this disk */
+        if (unz64local_getLong(&us.z_filefunc, us.filestream,&number_disk)!=UNZ_OK)
+            err=UNZ_ERRNO;
+
+        /* number of the disk with the start of the central directory */
+        if (unz64local_getLong(&us.z_filefunc, us.filestream,&number_disk_with_CD)!=UNZ_OK)
+            err=UNZ_ERRNO;
+
+        /* total number of entries in the central directory on this disk */
+        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&us.gi.number_entry)!=UNZ_OK)
+            err=UNZ_ERRNO;
+
+        /* total number of entries in the central directory */
+        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&number_entry_CD)!=UNZ_OK)
+            err=UNZ_ERRNO;
+
+        if ((number_entry_CD!=us.gi.number_entry) ||
+            (number_disk_with_CD!=0) ||
+            (number_disk!=0))
+            err=UNZ_BADZIPFILE;
+
+        /* size of the central directory */
+        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&us.size_central_dir)!=UNZ_OK)
+            err=UNZ_ERRNO;
+
+        /* offset of start of central directory with respect to the
+          starting disk number */
+        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&us.offset_central_dir)!=UNZ_OK)
+            err=UNZ_ERRNO;
+
+        us.gi.size_comment = 0;
+    }
+    else
+    {
+        central_pos = unz64local_SearchCentralDir(&us.z_filefunc,us.filestream);
+        if (central_pos==0)
+            err=UNZ_ERRNO;
+
+        us.isZip64 = 0;
+
+        if (ZSEEK64(us.z_filefunc, us.filestream,
+                                        central_pos,ZLIB_FILEFUNC_SEEK_SET)!=0)
+            err=UNZ_ERRNO;
+
+        /* the signature, already checked */
+        if (unz64local_getLong(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)
+            err=UNZ_ERRNO;
+
+        /* number of this disk */
+        if (unz64local_getShort(&us.z_filefunc, us.filestream,&number_disk)!=UNZ_OK)
+            err=UNZ_ERRNO;
+
+        /* number of the disk with the start of the central directory */
+        if (unz64local_getShort(&us.z_filefunc, us.filestream,&number_disk_with_CD)!=UNZ_OK)
+            err=UNZ_ERRNO;
+
+        /* total number of entries in the central dir on this disk */
+        if (unz64local_getShort(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)
+            err=UNZ_ERRNO;
+        us.gi.number_entry = uL;
+
+        /* total number of entries in the central dir */
+        if (unz64local_getShort(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)
+            err=UNZ_ERRNO;
+        number_entry_CD = uL;
+
+        if ((number_entry_CD!=us.gi.number_entry) ||
+            (number_disk_with_CD!=0) ||
+            (number_disk!=0))
+            err=UNZ_BADZIPFILE;
+
+        /* size of the central directory */
+        if (unz64local_getLong(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)
+            err=UNZ_ERRNO;
+        us.size_central_dir = uL;
+
+        /* offset of start of central directory with respect to the
+            starting disk number */
+        if (unz64local_getLong(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)
+            err=UNZ_ERRNO;
+        us.offset_central_dir = uL;
+
+        /* zipfile comment length */
+        if (unz64local_getShort(&us.z_filefunc, us.filestream,&us.gi.size_comment)!=UNZ_OK)
+            err=UNZ_ERRNO;
+    }
+
+    if ((central_pos<us.offset_central_dir+us.size_central_dir) &&
+        (err==UNZ_OK))
+        err=UNZ_BADZIPFILE;
+
+    if (err!=UNZ_OK)
+    {
+        if ((us.flags & UNZ_AUTO_CLOSE) != 0)
+            ZCLOSE64(us.z_filefunc, us.filestream);
+        else
+            ZFAKECLOSE64(us.z_filefunc, us.filestream);
+        return NULL;
+    }
+
+    us.byte_before_the_zipfile = central_pos -
+                            (us.offset_central_dir+us.size_central_dir);
+    us.central_pos = central_pos;
+    us.pfile_in_zip_read = NULL;
+    us.encrypted = 0;
+
+
+    s=(unz64_s*)ALLOC(sizeof(unz64_s));
+    if( s != NULL)
+    {
+        *s=us;
+        unzGoToFirstFile((unzFile)s);
+    }
+    return (unzFile)s;
+}
+
+
+extern unzFile ZEXPORT unzOpen2 (voidpf file,
+                                        zlib_filefunc_def* pzlib_filefunc32_def)
+{
+    if (pzlib_filefunc32_def != NULL)
+    {
+        zlib_filefunc64_32_def zlib_filefunc64_32_def_fill;
+        fill_zlib_filefunc64_32_def_from_filefunc32(&zlib_filefunc64_32_def_fill,pzlib_filefunc32_def);
+        return unzOpenInternal(file, &zlib_filefunc64_32_def_fill, 0, UNZ_DEFAULT_FLAGS);
+    }
+    else
+        return unzOpenInternal(file, NULL, 0, UNZ_DEFAULT_FLAGS);
+}
+
+extern unzFile ZEXPORT unzOpen2_64 (voidpf file,
+                                     zlib_filefunc64_def* pzlib_filefunc_def)
+{
+    if (pzlib_filefunc_def != NULL)
+    {
+        zlib_filefunc64_32_def zlib_filefunc64_32_def_fill;
+        zlib_filefunc64_32_def_fill.zfile_func64 = *pzlib_filefunc_def;
+        zlib_filefunc64_32_def_fill.ztell32_file = NULL;
+        zlib_filefunc64_32_def_fill.zseek32_file = NULL;
+        return unzOpenInternal(file, &zlib_filefunc64_32_def_fill, 1, UNZ_DEFAULT_FLAGS);
+    }
+    else
+        return unzOpenInternal(file, NULL, 1, UNZ_DEFAULT_FLAGS);
+}
+
+extern unzFile ZEXPORT unzOpen (voidpf file)
+{
+    return unzOpenInternal(file, NULL, 0, UNZ_DEFAULT_FLAGS);
+}
+
+extern unzFile ZEXPORT unzOpen64 (voidpf file)
+{
+    return unzOpenInternal(file, NULL, 1, UNZ_DEFAULT_FLAGS);
+}
+
+/*
+  Close a ZipFile opened with unzipOpen.
+  If there is files inside the .Zip opened with unzipOpenCurrentFile (see later),
+    these files MUST be closed with unzipCloseCurrentFile before call unzipClose.
+  return UNZ_OK if there is no problem. */
+extern int ZEXPORT unzClose (unzFile file)
+{
+    unz64_s* s;
+    if (file==NULL)
+        return UNZ_PARAMERROR;
+    s=(unz64_s*)file;
+
+    if (s->pfile_in_zip_read!=NULL)
+        unzCloseCurrentFile(file);
+
+    if ((s->flags & UNZ_AUTO_CLOSE) != 0)
+        ZCLOSE64(s->z_filefunc, s->filestream);
+    else
+        ZFAKECLOSE64(s->z_filefunc, s->filestream);
+    TRYFREE(s);
+    return UNZ_OK;
+}
+
+
+/*
+  Write info about the ZipFile in the *pglobal_info structure.
+  No preparation of the structure is needed
+  return UNZ_OK if there is no problem. */
+extern int ZEXPORT unzGetGlobalInfo64 (unzFile file, unz_global_info64* pglobal_info)
+{
+    unz64_s* s;
+    if (file==NULL)
+        return UNZ_PARAMERROR;
+    s=(unz64_s*)file;
+    *pglobal_info=s->gi;
+    return UNZ_OK;
+}
+
+extern int ZEXPORT unzGetGlobalInfo (unzFile file, unz_global_info* pglobal_info32)
+{
+    unz64_s* s;
+    if (file==NULL)
+        return UNZ_PARAMERROR;
+    s=(unz64_s*)file;
+    /* to do : check if number_entry is not truncated */
+    pglobal_info32->number_entry = (uLong)s->gi.number_entry;
+    pglobal_info32->size_comment = s->gi.size_comment;
+    return UNZ_OK;
+}
+
+extern int ZEXPORT unzGetFileFlags (unzFile file, unsigned* pflags)
+{
+    unz64_s* s;
+    if (file==NULL)
+        return UNZ_PARAMERROR;
+    s=(unz64_s*)file;
+    *pflags = s->flags;
+    return UNZ_OK;
+}
+
+/*
+   Translate date/time from Dos format to tm_unz (readable more easilty)
+*/
+local void unz64local_DosDateToTmuDate (ZPOS64_T ulDosDate, tm_unz* ptm)
+{
+    ZPOS64_T uDate;
+    uDate = (ZPOS64_T)(ulDosDate>>16);
+    ptm->tm_mday = (uInt)(uDate&0x1f) ;
+    ptm->tm_mon =  (uInt)((((uDate)&0x1E0)/0x20)-1) ;
+    ptm->tm_year = (uInt)(((uDate&0x0FE00)/0x0200)+1980) ;
+
+    ptm->tm_hour = (uInt) ((ulDosDate &0xF800)/0x800);
+    ptm->tm_min =  (uInt) ((ulDosDate&0x7E0)/0x20) ;
+    ptm->tm_sec =  (uInt) (2*(ulDosDate&0x1f)) ;
+}
+
+/*
+  Get Info about the current file in the zipfile, with internal only info
+*/
+local int unz64local_GetCurrentFileInfoInternal OF((unzFile file,
+                                                  unz_file_info64 *pfile_info,
+                                                  unz_file_info64_internal
+                                                  *pfile_info_internal,
+                                                  char *szFileName,
+                                                  uLong fileNameBufferSize,
+                                                  void *extraField,
+                                                  uLong extraFieldBufferSize,
+                                                  char *szComment,
+                                                  uLong commentBufferSize));
+
+local int unz64local_GetCurrentFileInfoInternal (unzFile file,
+                                                  unz_file_info64 *pfile_info,
+                                                  unz_file_info64_internal
+                                                  *pfile_info_internal,
+                                                  char *szFileName,
+                                                  uLong fileNameBufferSize,
+                                                  void *extraField,
+                                                  uLong extraFieldBufferSize,
+                                                  char *szComment,
+                                                  uLong commentBufferSize)
+{
+    unz64_s* s;
+    unz_file_info64 file_info;
+    unz_file_info64_internal file_info_internal;
+    int err=UNZ_OK;
+    uLong uMagic;
+    ZPOS64_T llSeek=0;
+    uLong uL;
+
+    if (file==NULL)
+        return UNZ_PARAMERROR;
+    s=(unz64_s*)file;
+    if (ZSEEK64(s->z_filefunc, s->filestream,
+              s->pos_in_central_dir+s->byte_before_the_zipfile,
+              ZLIB_FILEFUNC_SEEK_SET)!=0)
+        err=UNZ_ERRNO;
+
+
+    /* we check the magic */
+    if (err==UNZ_OK)
+    {
+        if (unz64local_getLong(&s->z_filefunc, s->filestream,&uMagic) != UNZ_OK)
+            err=UNZ_ERRNO;
+        else if (uMagic!=0x02014b50)
+            err=UNZ_BADZIPFILE;
+    }
+
+    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.version) != UNZ_OK)
+        err=UNZ_ERRNO;
+
+    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.version_needed) != UNZ_OK)
+        err=UNZ_ERRNO;
+
+    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.flag) != UNZ_OK)
+        err=UNZ_ERRNO;
+
+    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.compression_method) != UNZ_OK)
+        err=UNZ_ERRNO;
+
+    if (unz64local_getLong(&s->z_filefunc, s->filestream,&file_info.dosDate) != UNZ_OK)
+        err=UNZ_ERRNO;
+
+    unz64local_DosDateToTmuDate(file_info.dosDate,&file_info.tmu_date);
+
+    if (unz64local_getLong(&s->z_filefunc, s->filestream,&file_info.crc) != UNZ_OK)
+        err=UNZ_ERRNO;
+
+    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uL) != UNZ_OK)
+        err=UNZ_ERRNO;
+    file_info.compressed_size = uL;
+
+    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uL) != UNZ_OK)
+        err=UNZ_ERRNO;
+    file_info.uncompressed_size = uL;
+
+    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.size_filename) != UNZ_OK)
+        err=UNZ_ERRNO;
+
+    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.size_file_extra) != UNZ_OK)
+        err=UNZ_ERRNO;
+
+    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.size_file_comment) != UNZ_OK)
+        err=UNZ_ERRNO;
+
+    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.disk_num_start) != UNZ_OK)
+        err=UNZ_ERRNO;
+
+    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.internal_fa) != UNZ_OK)
+        err=UNZ_ERRNO;
+
+    if (unz64local_getLong(&s->z_filefunc, s->filestream,&file_info.external_fa) != UNZ_OK)
+        err=UNZ_ERRNO;
+
+                /* relative offset of local header */
+    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uL) != UNZ_OK)
+        err=UNZ_ERRNO;
+    file_info_internal.offset_curfile = uL;
+
+    llSeek+=file_info.size_filename;
+    if ((err==UNZ_OK) && (szFileName!=NULL))
+    {
+        uLong uSizeRead ;
+        if (file_info.size_filename<fileNameBufferSize)
+        {
+            *(szFileName+file_info.size_filename)='\0';
+            uSizeRead = file_info.size_filename;
+        }
+        else
+            uSizeRead = fileNameBufferSize;
+
+        if ((file_info.size_filename>0) && (fileNameBufferSize>0))
+            if (ZREAD64(s->z_filefunc, s->filestream,szFileName,uSizeRead)!=uSizeRead)
+                err=UNZ_ERRNO;
+        llSeek -= uSizeRead;
+    }
+
+    /* Read extrafield */
+    if ((err==UNZ_OK) && (extraField!=NULL))
+    {
+        ZPOS64_T uSizeRead ;
+        if (file_info.size_file_extra<extraFieldBufferSize)
+            uSizeRead = file_info.size_file_extra;
+        else
+            uSizeRead = extraFieldBufferSize;
+
+        if (llSeek!=0)
+        {
+            if (ZSEEK64(s->z_filefunc, s->filestream,llSeek,ZLIB_FILEFUNC_SEEK_CUR)==0)
+                llSeek=0;
+            else
+                err=UNZ_ERRNO;
+        }
+
+        if ((file_info.size_file_extra>0) && (extraFieldBufferSize>0))
+            if (ZREAD64(s->z_filefunc, s->filestream,extraField,(uLong)uSizeRead)!=uSizeRead)
+                err=UNZ_ERRNO;
+
+        llSeek += file_info.size_file_extra - (uLong)uSizeRead;
+    }
+    else
+        llSeek += file_info.size_file_extra;
+
+
+    if ((err==UNZ_OK) && (file_info.size_file_extra != 0))
+    {
+                                uLong acc = 0;
+
+        /* since lSeek now points to after the extra field we need to move back */
+        llSeek -= file_info.size_file_extra;
+
+        if (llSeek!=0)
+        {
+            if (ZSEEK64(s->z_filefunc, s->filestream,llSeek,ZLIB_FILEFUNC_SEEK_CUR)==0)
+                llSeek=0;
+            else
+                err=UNZ_ERRNO;
+        }
+
+        while(acc < file_info.size_file_extra)
+        {
+            uLong headerId;
+                                                uLong dataSize;
+
+            if (unz64local_getShort(&s->z_filefunc, s->filestream,&headerId) != UNZ_OK)
+                err=UNZ_ERRNO;
+
+            if (unz64local_getShort(&s->z_filefunc, s->filestream,&dataSize) != UNZ_OK)
+                err=UNZ_ERRNO;
+
+            /* ZIP64 extra fields */
+            if (headerId == 0x0001)
+            {
+                uLong uL;
+
+                if(file_info.uncompressed_size == (ZPOS64_T)0xFFFFFFFFu)
+                {
+                    if (unz64local_getLong64(&s->z_filefunc, s->filestream,&file_info.uncompressed_size) != UNZ_OK)
+                        err=UNZ_ERRNO;
+                }
+
+                if(file_info.compressed_size == (ZPOS64_T)0xFFFFFFFFu)
+                {
+                    if (unz64local_getLong64(&s->z_filefunc, s->filestream,&file_info.compressed_size) != UNZ_OK)
+                        err=UNZ_ERRNO;
+                }
+
+                if(file_info_internal.offset_curfile == (ZPOS64_T)0xFFFFFFFFu)
+                {
+                    /* Relative Header offset */
+                    if (unz64local_getLong64(&s->z_filefunc, s->filestream,&file_info_internal.offset_curfile) != UNZ_OK)
+                        err=UNZ_ERRNO;
+                }
+
+                if(file_info.disk_num_start == 0xFFFFFFFFu)
+                {
+                    /* Disk Start Number */
+                    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uL) != UNZ_OK)
+                        err=UNZ_ERRNO;
+                }
+
+            }
+            else
+            {
+                if (ZSEEK64(s->z_filefunc, s->filestream,dataSize,ZLIB_FILEFUNC_SEEK_CUR)!=0)
+                    err=UNZ_ERRNO;
+            }
+
+            acc += 2 + 2 + dataSize;
+        }
+    }
+
+    if ((err==UNZ_OK) && (szComment!=NULL))
+    {
+        uLong uSizeRead ;
+        if (file_info.size_file_comment<commentBufferSize)
+        {
+            *(szComment+file_info.size_file_comment)='\0';
+            uSizeRead = file_info.size_file_comment;
+        }
+        else
+            uSizeRead = commentBufferSize;
+
+        if (llSeek!=0)
+        {
+            if (ZSEEK64(s->z_filefunc, s->filestream,llSeek,ZLIB_FILEFUNC_SEEK_CUR)==0)
+                llSeek=0;
+            else
+                err=UNZ_ERRNO;
+        }
+
+        if ((file_info.size_file_comment>0) && (commentBufferSize>0))
+            if (ZREAD64(s->z_filefunc, s->filestream,szComment,uSizeRead)!=uSizeRead)
+                err=UNZ_ERRNO;
+        llSeek+=file_info.size_file_comment - uSizeRead;
+    }
+    else
+        llSeek+=file_info.size_file_comment;
+
+
+    if ((err==UNZ_OK) && (pfile_info!=NULL))
+        *pfile_info=file_info;
+
+    if ((err==UNZ_OK) && (pfile_info_internal!=NULL))
+        *pfile_info_internal=file_info_internal;
+
+    return err;
+}
+
+
+
+/*
+  Write info about the ZipFile in the *pglobal_info structure.
+  No preparation of the structure is needed
+  return UNZ_OK if there is no problem.
+*/
+extern int ZEXPORT unzGetCurrentFileInfo64 (unzFile file,
+                                          unz_file_info64 * pfile_info,
+                                          char * szFileName, uLong fileNameBufferSize,
+                                          void *extraField, uLong extraFieldBufferSize,
+                                          char* szComment,  uLong commentBufferSize)
+{
+    return unz64local_GetCurrentFileInfoInternal(file,pfile_info,NULL,
+                                                szFileName,fileNameBufferSize,
+                                                extraField,extraFieldBufferSize,
+                                                szComment,commentBufferSize);
+}
+
+extern int ZEXPORT unzGetCurrentFileInfo (unzFile file,
+                                          unz_file_info * pfile_info,
+                                          char * szFileName, uLong fileNameBufferSize,
+                                          void *extraField, uLong extraFieldBufferSize,
+                                          char* szComment,  uLong commentBufferSize)
+{
+    int err;
+    unz_file_info64 file_info64;
+    err = unz64local_GetCurrentFileInfoInternal(file,&file_info64,NULL,
+                                                szFileName,fileNameBufferSize,
+                                                extraField,extraFieldBufferSize,
+                                                szComment,commentBufferSize);
+    if (err==UNZ_OK && pfile_info != NULL)
+    {
+        pfile_info->version = file_info64.version;
+        pfile_info->version_needed = file_info64.version_needed;
+        pfile_info->flag = file_info64.flag;
+        pfile_info->compression_method = file_info64.compression_method;
+        pfile_info->dosDate = file_info64.dosDate;
+        pfile_info->crc = file_info64.crc;
+
+        pfile_info->size_filename = file_info64.size_filename;
+        pfile_info->size_file_extra = file_info64.size_file_extra;
+        pfile_info->size_file_comment = file_info64.size_file_comment;
+
+        pfile_info->disk_num_start = file_info64.disk_num_start;
+        pfile_info->internal_fa = file_info64.internal_fa;
+        pfile_info->external_fa = file_info64.external_fa;
+
+        pfile_info->tmu_date = file_info64.tmu_date,
+
+
+        pfile_info->compressed_size = (uLong)file_info64.compressed_size;
+        pfile_info->uncompressed_size = (uLong)file_info64.uncompressed_size;
+
+    }
+    return err;
+}
+/*
+  Set the current file of the zipfile to the first file.
+  return UNZ_OK if there is no problem
+*/
+extern int ZEXPORT unzGoToFirstFile (unzFile file)
+{
+    int err=UNZ_OK;
+    unz64_s* s;
+    if (file==NULL)
+        return UNZ_PARAMERROR;
+    s=(unz64_s*)file;
+    s->pos_in_central_dir=s->offset_central_dir;
+    s->num_file=0;
+    err=unz64local_GetCurrentFileInfoInternal(file,&s->cur_file_info,
+                                             &s->cur_file_info_internal,
+                                             NULL,0,NULL,0,NULL,0);
+    s->current_file_ok = (err == UNZ_OK);
+    if (s->cur_file_info.flag & UNZ_ENCODING_UTF8)
+        unzSetFlags(file, UNZ_ENCODING_UTF8);
+    return err;
+}
+
+/*
+  Set the current file of the zipfile to the next file.
+  return UNZ_OK if there is no problem
+  return UNZ_END_OF_LIST_OF_FILE if the actual file was the latest.
+*/
+extern int ZEXPORT unzGoToNextFile (unzFile  file)
+{
+    unz64_s* s;
+    int err;
+
+    if (file==NULL)
+        return UNZ_PARAMERROR;
+    s=(unz64_s*)file;
+    if (!s->current_file_ok)
+        return UNZ_END_OF_LIST_OF_FILE;
+    if (s->gi.number_entry != 0xffff)    /* 2^16 files overflow hack */
+      if (s->num_file+1==s->gi.number_entry)
+        return UNZ_END_OF_LIST_OF_FILE;
+
+    s->pos_in_central_dir += SIZECENTRALDIRITEM + s->cur_file_info.size_filename +
+            s->cur_file_info.size_file_extra + s->cur_file_info.size_file_comment ;
+    s->num_file++;
+    err = unz64local_GetCurrentFileInfoInternal(file,&s->cur_file_info,
+                                               &s->cur_file_info_internal,
+                                               NULL,0,NULL,0,NULL,0);
+    s->current_file_ok = (err == UNZ_OK);
+    return err;
+}
+
+
+/*
+  Try locate the file szFileName in the zipfile.
+  For the iCaseSensitivity signification, see unzipStringFileNameCompare
+
+  return value :
+  UNZ_OK if the file is found. It becomes the current file.
+  UNZ_END_OF_LIST_OF_FILE if the file is not found
+*/
+extern int ZEXPORT unzLocateFile (unzFile file, const char *szFileName, int iCaseSensitivity)
+{
+    unz64_s* s;
+    int err;
+
+    /* We remember the 'current' position in the file so that we can jump
+     * back there if we fail.
+     */
+    unz_file_info64 cur_file_infoSaved;
+    unz_file_info64_internal cur_file_info_internalSaved;
+    ZPOS64_T num_fileSaved;
+    ZPOS64_T pos_in_central_dirSaved;
+
+
+    if (file==NULL)
+        return UNZ_PARAMERROR;
+
+    if (strlen(szFileName)>=UNZ_MAXFILENAMEINZIP)
+        return UNZ_PARAMERROR;
+
+    s=(unz64_s*)file;
+    if (!s->current_file_ok)
+        return UNZ_END_OF_LIST_OF_FILE;
+
+    /* Save the current state */
+    num_fileSaved = s->num_file;
+    pos_in_central_dirSaved = s->pos_in_central_dir;
+    cur_file_infoSaved = s->cur_file_info;
+    cur_file_info_internalSaved = s->cur_file_info_internal;
+
+    err = unzGoToFirstFile(file);
+
+    while (err == UNZ_OK)
+    {
+        char szCurrentFileName[UNZ_MAXFILENAMEINZIP+1];
+        err = unzGetCurrentFileInfo64(file,NULL,
+                                    szCurrentFileName,sizeof(szCurrentFileName)-1,
+                                    NULL,0,NULL,0);
+        if (err == UNZ_OK)
+        {
+            if (unzStringFileNameCompare(szCurrentFileName,
+                                            szFileName,iCaseSensitivity)==0)
+                return UNZ_OK;
+            err = unzGoToNextFile(file);
+        }
+    }
+
+    /* We failed, so restore the state of the 'current file' to where we
+     * were.
+     */
+    s->num_file = num_fileSaved ;
+    s->pos_in_central_dir = pos_in_central_dirSaved ;
+    s->cur_file_info = cur_file_infoSaved;
+    s->cur_file_info_internal = cur_file_info_internalSaved;
+    return err;
+}
+
+
+/*
+///////////////////////////////////////////
+// Contributed by Ryan Haksi (mailto://cryogen@infoserve.net)
+// I need random access
+//
+// Further optimization could be realized by adding an ability
+// to cache the directory in memory. The goal being a single
+// comprehensive file read to put the file I need in a memory.
+*/
+
+/*
+typedef struct unz_file_pos_s
+{
+    ZPOS64_T pos_in_zip_directory;   // offset in file
+    ZPOS64_T num_of_file;            // # of file
+} unz_file_pos;
+*/
+
+extern int ZEXPORT unzGetFilePos64(unzFile file, unz64_file_pos*  file_pos)
+{
+    unz64_s* s;
+
+    if (file==NULL || file_pos==NULL)
+        return UNZ_PARAMERROR;
+    s=(unz64_s*)file;
+    if (!s->current_file_ok)
+        return UNZ_END_OF_LIST_OF_FILE;
+
+    file_pos->pos_in_zip_directory  = s->pos_in_central_dir;
+    file_pos->num_of_file           = s->num_file;
+
+    return UNZ_OK;
+}
+
+extern int ZEXPORT unzGetFilePos(
+    unzFile file,
+    unz_file_pos* file_pos)
+{
+    unz64_file_pos file_pos64;
+    int err = unzGetFilePos64(file,&file_pos64);
+    if (err==UNZ_OK)
+    {
+        file_pos->pos_in_zip_directory = (uLong)file_pos64.pos_in_zip_directory;
+        file_pos->num_of_file = (uLong)file_pos64.num_of_file;
+    }
+    return err;
+}
+
+extern int ZEXPORT unzGoToFilePos64(unzFile file, const unz64_file_pos* file_pos)
+{
+    unz64_s* s;
+    int err;
+
+    if (file==NULL || file_pos==NULL)
+        return UNZ_PARAMERROR;
+    s=(unz64_s*)file;
+
+    /* jump to the right spot */
+    s->pos_in_central_dir = file_pos->pos_in_zip_directory;
+    s->num_file           = file_pos->num_of_file;
+
+    /* set the current file */
+    err = unz64local_GetCurrentFileInfoInternal(file,&s->cur_file_info,
+                                               &s->cur_file_info_internal,
+                                               NULL,0,NULL,0,NULL,0);
+    /* return results */
+    s->current_file_ok = (err == UNZ_OK);
+    return err;
+}
+
+extern int ZEXPORT unzGoToFilePos(
+    unzFile file,
+    unz_file_pos* file_pos)
+{
+    unz64_file_pos file_pos64;
+    if (file_pos == NULL)
+        return UNZ_PARAMERROR;
+
+    file_pos64.pos_in_zip_directory = file_pos->pos_in_zip_directory;
+    file_pos64.num_of_file = file_pos->num_of_file;
+    return unzGoToFilePos64(file,&file_pos64);
+}
+
+/* Unzip Helper Functions - should be here? */
+/*///////////////////////////////////////// */
+
+/*
+  Read the local header of the current zipfile
+  Check the coherency of the local header and info in the end of central
+        directory about this file
+  store in *piSizeVar the size of extra info in local header
+        (filename and size of extra field data)
+*/
+local int unz64local_CheckCurrentFileCoherencyHeader (unz64_s* s, uInt* piSizeVar,
+                                                    ZPOS64_T * poffset_local_extrafield,
+                                                    uInt  * psize_local_extrafield)
+{
+    uLong uMagic,uData,uFlags;
+    uLong size_filename;
+    uLong size_extra_field;
+    int err=UNZ_OK;
+
+    *piSizeVar = 0;
+    *poffset_local_extrafield = 0;
+    *psize_local_extrafield = 0;
+
+    if (ZSEEK64(s->z_filefunc, s->filestream,s->cur_file_info_internal.offset_curfile +
+                                s->byte_before_the_zipfile,ZLIB_FILEFUNC_SEEK_SET)!=0)
+        return UNZ_ERRNO;
+
+
+    if (err==UNZ_OK)
+    {
+        if (unz64local_getLong(&s->z_filefunc, s->filestream,&uMagic) != UNZ_OK)
+            err=UNZ_ERRNO;
+        else if (uMagic!=0x04034b50)
+            err=UNZ_BADZIPFILE;
+    }
+
+    if (unz64local_getShort(&s->z_filefunc, s->filestream,&uData) != UNZ_OK)
+        err=UNZ_ERRNO;
+/*
+    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.wVersion))
+        err=UNZ_BADZIPFILE;
+*/
+    if (unz64local_getShort(&s->z_filefunc, s->filestream,&uFlags) != UNZ_OK)
+        err=UNZ_ERRNO;
+
+    if (unz64local_getShort(&s->z_filefunc, s->filestream,&uData) != UNZ_OK)
+        err=UNZ_ERRNO;
+    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.compression_method))
+        err=UNZ_BADZIPFILE;
+
+    if ((err==UNZ_OK) && (s->cur_file_info.compression_method!=0) &&
+/* #ifdef HAVE_BZIP2 */
+                         (s->cur_file_info.compression_method!=Z_BZIP2ED) &&
+/* #endif */
+                         (s->cur_file_info.compression_method!=Z_DEFLATED))
+        err=UNZ_BADZIPFILE;
+
+    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* date/time */
+        err=UNZ_ERRNO;
+
+    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* crc */
+        err=UNZ_ERRNO;
+    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.crc) && ((uFlags & 8)==0))
+        err=UNZ_BADZIPFILE;
+
+    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* size compr */
+        err=UNZ_ERRNO;
+    else if (uData != 0xFFFFFFFF && (err==UNZ_OK) && (uData!=s->cur_file_info.compressed_size) && ((uFlags & 8)==0))
+        err=UNZ_BADZIPFILE;
+
+    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* size uncompr */
+        err=UNZ_ERRNO;
+    else if (uData != 0xFFFFFFFF && (err==UNZ_OK) && (uData!=s->cur_file_info.uncompressed_size) && ((uFlags & 8)==0))
+        err=UNZ_BADZIPFILE;
+
+    if (unz64local_getShort(&s->z_filefunc, s->filestream,&size_filename) != UNZ_OK)
+        err=UNZ_ERRNO;
+    else if ((err==UNZ_OK) && (size_filename!=s->cur_file_info.size_filename))
+        err=UNZ_BADZIPFILE;
+
+    *piSizeVar += (uInt)size_filename;
+
+    if (unz64local_getShort(&s->z_filefunc, s->filestream,&size_extra_field) != UNZ_OK)
+        err=UNZ_ERRNO;
+    *poffset_local_extrafield= s->cur_file_info_internal.offset_curfile +
+                                    SIZEZIPLOCALHEADER + size_filename;
+    *psize_local_extrafield = (uInt)size_extra_field;
+
+    *piSizeVar += (uInt)size_extra_field;
+
+    return err;
+}
+
+/*
+  Open for reading data the current file in the zipfile.
+  If there is no error and the file is opened, the return value is UNZ_OK.
+*/
+extern int ZEXPORT unzOpenCurrentFile3 (unzFile file, int* method,
+                                            int* level, int raw, const char* password)
+{
+    int err=UNZ_OK;
+    uInt iSizeVar;
+    unz64_s* s;
+    file_in_zip64_read_info_s* pfile_in_zip_read_info;
+    ZPOS64_T offset_local_extrafield;  /* offset of the local extra field */
+    uInt  size_local_extrafield;    /* size of the local extra field */
+#    ifndef NOUNCRYPT
+    char source[12];
+#    else
+    if (password != NULL)
+        return UNZ_PARAMERROR;
+#    endif
+
+    if (file==NULL)
+        return UNZ_PARAMERROR;
+    s=(unz64_s*)file;
+    if (!s->current_file_ok)
+        return UNZ_PARAMERROR;
+
+    if (s->pfile_in_zip_read != NULL)
+        unzCloseCurrentFile(file);
+
+    if (unz64local_CheckCurrentFileCoherencyHeader(s,&iSizeVar, &offset_local_extrafield,&size_local_extrafield)!=UNZ_OK)
+        return UNZ_BADZIPFILE;
+
+    pfile_in_zip_read_info = (file_in_zip64_read_info_s*)ALLOC(sizeof(file_in_zip64_read_info_s));
+    if (pfile_in_zip_read_info==NULL)
+        return UNZ_INTERNALERROR;
+
+    pfile_in_zip_read_info->read_buffer=(char*)ALLOC(UNZ_BUFSIZE);
+    pfile_in_zip_read_info->offset_local_extrafield = offset_local_extrafield;
+    pfile_in_zip_read_info->size_local_extrafield = size_local_extrafield;
+    pfile_in_zip_read_info->pos_local_extrafield=0;
+    pfile_in_zip_read_info->raw=raw;
+
+    if (pfile_in_zip_read_info->read_buffer==NULL)
+    {
+        TRYFREE(pfile_in_zip_read_info);
+        return UNZ_INTERNALERROR;
+    }
+
+    pfile_in_zip_read_info->stream_initialised=0;
+
+    if (method!=NULL)
+        *method = (int)s->cur_file_info.compression_method;
+
+    if (level!=NULL)
+    {
+        *level = 6;
+        switch (s->cur_file_info.flag & 0x06)
+        {
+          case 6 : *level = 1; break;
+          case 4 : *level = 2; break;
+          case 2 : *level = 9; break;
+        }
+    }
+
+    if ((s->cur_file_info.compression_method!=0) &&
+/* #ifdef HAVE_BZIP2 */
+        (s->cur_file_info.compression_method!=Z_BZIP2ED) &&
+/* #endif */
+        (s->cur_file_info.compression_method!=Z_DEFLATED))
+
+        err=UNZ_BADZIPFILE;
+
+    pfile_in_zip_read_info->crc32_wait=s->cur_file_info.crc;
+    pfile_in_zip_read_info->crc32=0;
+    pfile_in_zip_read_info->total_out_64=0;
+    pfile_in_zip_read_info->compression_method = s->cur_file_info.compression_method;
+    pfile_in_zip_read_info->filestream=s->filestream;
+    pfile_in_zip_read_info->z_filefunc=s->z_filefunc;
+    pfile_in_zip_read_info->byte_before_the_zipfile=s->byte_before_the_zipfile;
+
+    pfile_in_zip_read_info->stream.total_out = 0;
+
+    if ((s->cur_file_info.compression_method==Z_BZIP2ED) && (!raw))
+    {
+#ifdef HAVE_BZIP2
+      pfile_in_zip_read_info->bstream.bzalloc = (void *(*) (void *, int, int))0;
+      pfile_in_zip_read_info->bstream.bzfree = (free_func)0;
+      pfile_in_zip_read_info->bstream.opaque = (voidpf)0;
+      pfile_in_zip_read_info->bstream.state = (voidpf)0;
+
+      pfile_in_zip_read_info->stream.zalloc = (alloc_func)0;
+      pfile_in_zip_read_info->stream.zfree = (free_func)0;
+      pfile_in_zip_read_info->stream.opaque = (voidpf)0;
+      pfile_in_zip_read_info->stream.next_in = (voidpf)0;
+      pfile_in_zip_read_info->stream.avail_in = 0;
+
+      err=BZ2_bzDecompressInit(&pfile_in_zip_read_info->bstream, 0, 0);
+      if (err == Z_OK)
+        pfile_in_zip_read_info->stream_initialised=Z_BZIP2ED;
+      else
+      {
+        TRYFREE(pfile_in_zip_read_info);
+        return err;
+      }
+#else
+      pfile_in_zip_read_info->raw=1;
+#endif
+    }
+    else if ((s->cur_file_info.compression_method==Z_DEFLATED) && (!raw))
+    {
+      pfile_in_zip_read_info->stream.zalloc = (alloc_func)0;
+      pfile_in_zip_read_info->stream.zfree = (free_func)0;
+      pfile_in_zip_read_info->stream.opaque = (voidpf)0;
+      pfile_in_zip_read_info->stream.next_in = 0;
+      pfile_in_zip_read_info->stream.avail_in = 0;
+
+      err=inflateInit2(&pfile_in_zip_read_info->stream, -MAX_WBITS);
+      if (err == Z_OK)
+        pfile_in_zip_read_info->stream_initialised=Z_DEFLATED;
+      else
+      {
+        TRYFREE(pfile_in_zip_read_info->read_buffer);
+        TRYFREE(pfile_in_zip_read_info);
+        return err;
+      }
+        /* windowBits is passed < 0 to tell that there is no zlib header.
+         * Note that in this case inflate *requires* an extra "dummy" byte
+         * after the compressed stream in order to complete decompression and
+         * return Z_STREAM_END.
+         * In unzip, i don't wait absolutely Z_STREAM_END because I known the
+         * size of both compressed and uncompressed data
+         */
+    }
+    pfile_in_zip_read_info->rest_read_compressed =
+            s->cur_file_info.compressed_size ;
+    pfile_in_zip_read_info->rest_read_uncompressed =
+            s->cur_file_info.uncompressed_size ;
+
+
+    pfile_in_zip_read_info->pos_in_zipfile =
+            s->cur_file_info_internal.offset_curfile + SIZEZIPLOCALHEADER +
+              iSizeVar;
+
+    pfile_in_zip_read_info->stream.avail_in = (uInt)0;
+
+    s->pfile_in_zip_read = pfile_in_zip_read_info;
+                s->encrypted = 0;
+
+#    ifndef NOUNCRYPT
+    if (password != NULL)
+    {
+        int i;
+        s->pcrc_32_tab = get_crc_table();
+        init_keys(password,s->keys,s->pcrc_32_tab);
+        if (ZSEEK64(s->z_filefunc, s->filestream,
+                  s->pfile_in_zip_read->pos_in_zipfile +
+                     s->pfile_in_zip_read->byte_before_the_zipfile,
+                  SEEK_SET)!=0)
+            return UNZ_INTERNALERROR;
+        if(ZREAD64(s->z_filefunc, s->filestream,source, 12)<12)
+            return UNZ_INTERNALERROR;
+
+        for (i = 0; i<12; i++)
+            zdecode(s->keys,s->pcrc_32_tab,source[i]);
+
+        s->pfile_in_zip_read->pos_in_zipfile+=12;
+        s->encrypted=1;
+    }
+#    endif
+
+
+    return UNZ_OK;
+}
+
+extern int ZEXPORT unzOpenCurrentFile (unzFile file)
+{
+    return unzOpenCurrentFile3(file, NULL, NULL, 0, NULL);
+}
+
+extern int ZEXPORT unzOpenCurrentFilePassword (unzFile file, const char*  password)
+{
+    return unzOpenCurrentFile3(file, NULL, NULL, 0, password);
+}
+
+extern int ZEXPORT unzOpenCurrentFile2 (unzFile file, int* method, int* level, int raw)
+{
+    return unzOpenCurrentFile3(file, method, level, raw, NULL);
+}
+
+/** Addition for GDAL : START */
+
+extern ZPOS64_T ZEXPORT unzGetCurrentFileZStreamPos64( unzFile file)
+{
+    unz64_s* s;
+    file_in_zip64_read_info_s* pfile_in_zip_read_info;
+    s=(unz64_s*)file;
+    if (file==NULL)
+        return 0; /*UNZ_PARAMERROR; */
+    pfile_in_zip_read_info=s->pfile_in_zip_read;
+    if (pfile_in_zip_read_info==NULL)
+        return 0; /*UNZ_PARAMERROR; */
+    return pfile_in_zip_read_info->pos_in_zipfile +
+                         pfile_in_zip_read_info->byte_before_the_zipfile;
+}
+
+/** Addition for GDAL : END */
+
+/*
+  Read bytes from the current file.
+  buf contain buffer where data must be copied
+  len the size of buf.
+
+  return the number of byte copied if somes bytes are copied
+  return 0 if the end of file was reached
+  return <0 with error code if there is an error
+    (UNZ_ERRNO for IO error, or zLib error for uncompress error)
+*/
+extern int ZEXPORT unzReadCurrentFile  (unzFile file, voidp buf, unsigned len)
+{
+    int err=UNZ_OK;
+    uInt iRead = 0;
+    unz64_s* s;
+    file_in_zip64_read_info_s* pfile_in_zip_read_info;
+    if (file==NULL)
+        return UNZ_PARAMERROR;
+    s=(unz64_s*)file;
+    pfile_in_zip_read_info=s->pfile_in_zip_read;
+
+    if (pfile_in_zip_read_info==NULL)
+        return UNZ_PARAMERROR;
+
+
+    if (pfile_in_zip_read_info->read_buffer == NULL)
+        return UNZ_END_OF_LIST_OF_FILE;
+    if (len==0)
+        return 0;
+
+    pfile_in_zip_read_info->stream.next_out = (Bytef*)buf;
+
+    pfile_in_zip_read_info->stream.avail_out = (uInt)len;
+
+    if ((len>pfile_in_zip_read_info->rest_read_uncompressed) &&
+        (!(pfile_in_zip_read_info->raw)))
+        pfile_in_zip_read_info->stream.avail_out =
+            (uInt)pfile_in_zip_read_info->rest_read_uncompressed;
+
+    if ((len>pfile_in_zip_read_info->rest_read_compressed+
+           pfile_in_zip_read_info->stream.avail_in) &&
+         (pfile_in_zip_read_info->raw))
+        pfile_in_zip_read_info->stream.avail_out =
+            (uInt)pfile_in_zip_read_info->rest_read_compressed+
+            pfile_in_zip_read_info->stream.avail_in;
+
+    while (pfile_in_zip_read_info->stream.avail_out>0)
+    {
+        if ((pfile_in_zip_read_info->stream.avail_in==0) &&
+            (pfile_in_zip_read_info->rest_read_compressed>0))
+        {
+            uInt uReadThis = UNZ_BUFSIZE;
+            if (pfile_in_zip_read_info->rest_read_compressed<uReadThis)
+                uReadThis = (uInt)pfile_in_zip_read_info->rest_read_compressed;
+            if (uReadThis == 0)
+                return UNZ_EOF;
+            if (ZSEEK64(pfile_in_zip_read_info->z_filefunc,
+                      pfile_in_zip_read_info->filestream,
+                      pfile_in_zip_read_info->pos_in_zipfile +
+                         pfile_in_zip_read_info->byte_before_the_zipfile,
+                         ZLIB_FILEFUNC_SEEK_SET)!=0)
+                return UNZ_ERRNO;
+            if (ZREAD64(pfile_in_zip_read_info->z_filefunc,
+                      pfile_in_zip_read_info->filestream,
+                      pfile_in_zip_read_info->read_buffer,
+                      uReadThis)!=uReadThis)
+                return UNZ_ERRNO;
+
+
+#            ifndef NOUNCRYPT
+            if(s->encrypted)
+            {
+                uInt i;
+                for(i=0;i<uReadThis;i++)
+                  pfile_in_zip_read_info->read_buffer[i] =
+                      zdecode(s->keys,s->pcrc_32_tab,
+                              pfile_in_zip_read_info->read_buffer[i]);
+            }
+#            endif
+
+
+            pfile_in_zip_read_info->pos_in_zipfile += uReadThis;
+
+            pfile_in_zip_read_info->rest_read_compressed-=uReadThis;
+
+            pfile_in_zip_read_info->stream.next_in =
+                (Bytef*)pfile_in_zip_read_info->read_buffer;
+            pfile_in_zip_read_info->stream.avail_in = (uInt)uReadThis;
+        }
+
+        if ((pfile_in_zip_read_info->compression_method==0) || (pfile_in_zip_read_info->raw))
+        {
+            uInt uDoCopy,i ;
+
+            if ((pfile_in_zip_read_info->stream.avail_in == 0) &&
+                (pfile_in_zip_read_info->rest_read_compressed == 0))
+                return (iRead==0) ? UNZ_EOF : iRead;
+
+            if (pfile_in_zip_read_info->stream.avail_out <
+                            pfile_in_zip_read_info->stream.avail_in)
+                uDoCopy = pfile_in_zip_read_info->stream.avail_out ;
+            else
+                uDoCopy = pfile_in_zip_read_info->stream.avail_in ;
+
+            for (i=0;i<uDoCopy;i++)
+                *(pfile_in_zip_read_info->stream.next_out+i) =
+                        *(pfile_in_zip_read_info->stream.next_in+i);
+
+            pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + uDoCopy;
+
+            pfile_in_zip_read_info->crc32 = crc32(pfile_in_zip_read_info->crc32,
+                                pfile_in_zip_read_info->stream.next_out,
+                                uDoCopy);
+            pfile_in_zip_read_info->rest_read_uncompressed-=uDoCopy;
+            pfile_in_zip_read_info->stream.avail_in -= uDoCopy;
+            pfile_in_zip_read_info->stream.avail_out -= uDoCopy;
+            pfile_in_zip_read_info->stream.next_out += uDoCopy;
+            pfile_in_zip_read_info->stream.next_in += uDoCopy;
+            pfile_in_zip_read_info->stream.total_out += uDoCopy;
+            iRead += uDoCopy;
+        }
+        else if (pfile_in_zip_read_info->compression_method==Z_BZIP2ED)
+        {
+#ifdef HAVE_BZIP2
+            uLong uTotalOutBefore,uTotalOutAfter;
+            const Bytef *bufBefore;
+            uLong uOutThis;
+
+            pfile_in_zip_read_info->bstream.next_in        = (char*)pfile_in_zip_read_info->stream.next_in;
+            pfile_in_zip_read_info->bstream.avail_in       = pfile_in_zip_read_info->stream.avail_in;
+            pfile_in_zip_read_info->bstream.total_in_lo32  = pfile_in_zip_read_info->stream.total_in;
+            pfile_in_zip_read_info->bstream.total_in_hi32  = 0;
+            pfile_in_zip_read_info->bstream.next_out       = (char*)pfile_in_zip_read_info->stream.next_out;
+            pfile_in_zip_read_info->bstream.avail_out      = pfile_in_zip_read_info->stream.avail_out;
+            pfile_in_zip_read_info->bstream.total_out_lo32 = pfile_in_zip_read_info->stream.total_out;
+            pfile_in_zip_read_info->bstream.total_out_hi32 = 0;
+
+            uTotalOutBefore = pfile_in_zip_read_info->bstream.total_out_lo32;
+            bufBefore = (const Bytef *)pfile_in_zip_read_info->bstream.next_out;
+
+            err=BZ2_bzDecompress(&pfile_in_zip_read_info->bstream);
+
+            uTotalOutAfter = pfile_in_zip_read_info->bstream.total_out_lo32;
+            uOutThis = uTotalOutAfter-uTotalOutBefore;
+
+            pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + uOutThis;
+
+            pfile_in_zip_read_info->crc32 = crc32(pfile_in_zip_read_info->crc32,bufBefore, (uInt)(uOutThis));
+            pfile_in_zip_read_info->rest_read_uncompressed -= uOutThis;
+            iRead += (uInt)(uTotalOutAfter - uTotalOutBefore);
+
+            pfile_in_zip_read_info->stream.next_in   = (Bytef*)pfile_in_zip_read_info->bstream.next_in;
+            pfile_in_zip_read_info->stream.avail_in  = pfile_in_zip_read_info->bstream.avail_in;
+            pfile_in_zip_read_info->stream.total_in  = pfile_in_zip_read_info->bstream.total_in_lo32;
+            pfile_in_zip_read_info->stream.next_out  = (Bytef*)pfile_in_zip_read_info->bstream.next_out;
+            pfile_in_zip_read_info->stream.avail_out = pfile_in_zip_read_info->bstream.avail_out;
+            pfile_in_zip_read_info->stream.total_out = pfile_in_zip_read_info->bstream.total_out_lo32;
+
+            if (err==BZ_STREAM_END)
+              return (iRead==0) ? UNZ_EOF : iRead;
+            if (err!=BZ_OK)
+              break;
+#endif
+        } /* end Z_BZIP2ED */
+        else
+        {
+            uInt uAvailOutBefore,uAvailOutAfter;
+            const Bytef *bufBefore;
+            uInt uOutThis;
+            int flush=Z_SYNC_FLUSH;
+
+            uAvailOutBefore = pfile_in_zip_read_info->stream.avail_out;
+            bufBefore = pfile_in_zip_read_info->stream.next_out;
+
+            err=inflate(&pfile_in_zip_read_info->stream,flush);
+
+            if ((err>=0) && (pfile_in_zip_read_info->stream.msg!=NULL))
+              err = Z_DATA_ERROR;
+
+            uAvailOutAfter = pfile_in_zip_read_info->stream.avail_out;
+            uOutThis = uAvailOutBefore - uAvailOutAfter;
+
+            pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + uOutThis;
+
+            pfile_in_zip_read_info->crc32
+                    = crc32(pfile_in_zip_read_info->crc32,bufBefore, uOutThis);
+
+            pfile_in_zip_read_info->rest_read_uncompressed -= uOutThis;
+
+            iRead += uAvailOutBefore - uAvailOutAfter;
+
+            if (err==Z_STREAM_END)
+                return (iRead==0) ? UNZ_EOF : iRead;
+            if (err!=Z_OK)
+                break;
+        }
+    }
+
+    if (err==Z_OK)
+        return iRead;
+    return err;
+}
+
+
+/*
+  Give the current position in uncompressed data
+*/
+extern z_off_t ZEXPORT unztell (unzFile file)
+{
+    unz64_s* s;
+    file_in_zip64_read_info_s* pfile_in_zip_read_info;
+    if (file==NULL)
+        return UNZ_PARAMERROR;
+    s=(unz64_s*)file;
+    pfile_in_zip_read_info=s->pfile_in_zip_read;
+
+    if (pfile_in_zip_read_info==NULL)
+        return UNZ_PARAMERROR;
+
+    return (z_off_t)pfile_in_zip_read_info->stream.total_out;
+}
+
+extern ZPOS64_T ZEXPORT unztell64 (unzFile file)
+{
+
+    unz64_s* s;
+    file_in_zip64_read_info_s* pfile_in_zip_read_info;
+    if (file==NULL)
+        return (ZPOS64_T)-1;
+    s=(unz64_s*)file;
+    pfile_in_zip_read_info=s->pfile_in_zip_read;
+
+    if (pfile_in_zip_read_info==NULL)
+        return (ZPOS64_T)-1;
+
+    return pfile_in_zip_read_info->total_out_64;
+}
+
+
+/*
+  return 1 if the end of file was reached, 0 elsewhere
+*/
+extern int ZEXPORT unzeof (unzFile file)
+{
+    unz64_s* s;
+    file_in_zip64_read_info_s* pfile_in_zip_read_info;
+    if (file==NULL)
+        return UNZ_PARAMERROR;
+    s=(unz64_s*)file;
+    pfile_in_zip_read_info=s->pfile_in_zip_read;
+
+    if (pfile_in_zip_read_info==NULL)
+        return UNZ_PARAMERROR;
+
+    if (pfile_in_zip_read_info->rest_read_uncompressed == 0)
+        return 1;
+    else
+        return 0;
+}
+
+
+
+/*
+Read extra field from the current file (opened by unzOpenCurrentFile)
+This is the local-header version of the extra field (sometimes, there is
+more info in the local-header version than in the central-header)
+
+  if buf==NULL, it return the size of the local extra field that can be read
+
+  if buf!=NULL, len is the size of the buffer, the extra header is copied in
+    buf.
+  the return value is the number of bytes copied in buf, or (if <0)
+    the error code
+*/
+extern int ZEXPORT unzGetLocalExtrafield (unzFile file, voidp buf, unsigned len)
+{
+    unz64_s* s;
+    file_in_zip64_read_info_s* pfile_in_zip_read_info;
+    uInt read_now;
+    ZPOS64_T size_to_read;
+
+    if (file==NULL)
+        return UNZ_PARAMERROR;
+    s=(unz64_s*)file;
+    pfile_in_zip_read_info=s->pfile_in_zip_read;
+
+    if (pfile_in_zip_read_info==NULL)
+        return UNZ_PARAMERROR;
+
+    size_to_read = (pfile_in_zip_read_info->size_local_extrafield -
+                pfile_in_zip_read_info->pos_local_extrafield);
+
+    if (buf==NULL)
+        return (int)size_to_read;
+
+    if (len>size_to_read)
+        read_now = (uInt)size_to_read;
+    else
+        read_now = (uInt)len ;
+
+    if (read_now==0)
+        return 0;
+
+    if (ZSEEK64(pfile_in_zip_read_info->z_filefunc,
+              pfile_in_zip_read_info->filestream,
+              pfile_in_zip_read_info->offset_local_extrafield +
+              pfile_in_zip_read_info->pos_local_extrafield,
+              ZLIB_FILEFUNC_SEEK_SET)!=0)
+        return UNZ_ERRNO;
+
+    if (ZREAD64(pfile_in_zip_read_info->z_filefunc,
+              pfile_in_zip_read_info->filestream,
+              buf,read_now)!=read_now)
+        return UNZ_ERRNO;
+
+    return (int)read_now;
+}
+
+/*
+  Close the file in zip opened with unzipOpenCurrentFile
+  Return UNZ_CRCERROR if all the file was read but the CRC is not good
+*/
+extern int ZEXPORT unzCloseCurrentFile (unzFile file)
+{
+    int err=UNZ_OK;
+
+    unz64_s* s;
+    file_in_zip64_read_info_s* pfile_in_zip_read_info;
+    if (file==NULL)
+        return UNZ_PARAMERROR;
+    s=(unz64_s*)file;
+    pfile_in_zip_read_info=s->pfile_in_zip_read;
+
+    if (pfile_in_zip_read_info==NULL)
+        return UNZ_PARAMERROR;
+
+
+    if ((pfile_in_zip_read_info->rest_read_uncompressed == 0) &&
+        (!pfile_in_zip_read_info->raw))
+    {
+        if (pfile_in_zip_read_info->crc32 != pfile_in_zip_read_info->crc32_wait)
+            err=UNZ_CRCERROR;
+    }
+
+
+    TRYFREE(pfile_in_zip_read_info->read_buffer);
+    pfile_in_zip_read_info->read_buffer = NULL;
+    if (pfile_in_zip_read_info->stream_initialised == Z_DEFLATED)
+        inflateEnd(&pfile_in_zip_read_info->stream);
+#ifdef HAVE_BZIP2
+    else if (pfile_in_zip_read_info->stream_initialised == Z_BZIP2ED)
+        BZ2_bzDecompressEnd(&pfile_in_zip_read_info->bstream);
+#endif
+
+
+    pfile_in_zip_read_info->stream_initialised = 0;
+    TRYFREE(pfile_in_zip_read_info);
+
+    s->pfile_in_zip_read=NULL;
+
+    return err;
+}
+
+
+/*
+  Get the global comment string of the ZipFile, in the szComment buffer.
+  uSizeBuf is the size of the szComment buffer.
+  return the number of byte copied or an error code <0
+*/
+extern int ZEXPORT unzGetGlobalComment (unzFile file, char * szComment, uLong uSizeBuf)
+{
+    unz64_s* s;
+    uLong uReadThis ;
+    if (file==NULL)
+        return (int)UNZ_PARAMERROR;
+    s=(unz64_s*)file;
+
+    uReadThis = uSizeBuf;
+    if (uReadThis>s->gi.size_comment)
+        uReadThis = s->gi.size_comment;
+
+    if (ZSEEK64(s->z_filefunc,s->filestream,s->central_pos+22,ZLIB_FILEFUNC_SEEK_SET)!=0)
+        return UNZ_ERRNO;
+
+    if (uReadThis>0)
+    {
+      *szComment='\0';
+      if (ZREAD64(s->z_filefunc,s->filestream,szComment,uReadThis)!=uReadThis)
+        return UNZ_ERRNO;
+    }
+
+    if ((szComment != NULL) && (uSizeBuf > s->gi.size_comment))
+        *(szComment+s->gi.size_comment)='\0';
+    return (int)uReadThis;
+}
+
+/* Additions by RX '2004 */
+extern ZPOS64_T ZEXPORT unzGetOffset64(unzFile file)
+{
+    unz64_s* s;
+
+    if (file==NULL)
+          return 0; /*UNZ_PARAMERROR; */
+    s=(unz64_s*)file;
+    if (!s->current_file_ok)
+      return 0;
+    if (s->gi.number_entry != 0 && s->gi.number_entry != 0xffff)
+      if (s->num_file==s->gi.number_entry)
+         return 0;
+    return s->pos_in_central_dir;
+}
+
+extern uLong ZEXPORT unzGetOffset (unzFile file)
+{
+    ZPOS64_T offset64;
+
+    if (file==NULL)
+          return 0; /*UNZ_PARAMERROR; */
+    offset64 = unzGetOffset64(file);
+    return (uLong)offset64;
+}
+
+extern int ZEXPORT unzSetOffset64(unzFile file, ZPOS64_T pos)
+{
+    unz64_s* s;
+    int err;
+
+    if (file==NULL)
+        return UNZ_PARAMERROR;
+    s=(unz64_s*)file;
+
+    s->pos_in_central_dir = pos;
+    s->num_file = s->gi.number_entry;      /* hack */
+    err = unz64local_GetCurrentFileInfoInternal(file,&s->cur_file_info,
+                                              &s->cur_file_info_internal,
+                                              NULL,0,NULL,0,NULL,0);
+    s->current_file_ok = (err == UNZ_OK);
+    return err;
+}
+
+extern int ZEXPORT unzSetOffset (unzFile file, uLong pos)
+{
+    return unzSetOffset64(file,pos);
+}
+
+
+int ZEXPORT unzSetFlags(unzFile file, unsigned flags)
+{
+    unz64_s* s;
+    if (file == NULL)
+        return UNZ_PARAMERROR;
+    s = (unz64_s*)file;
+    s->flags |= flags;
+    return UNZ_OK;
+}
+
+
+int ZEXPORT unzClearFlags(unzFile file, unsigned flags)
+{
+    unz64_s* s;
+    if (file == NULL)
+        return UNZ_PARAMERROR;
+    s = (unz64_s*)file;
+    s->flags &= ~flags;
+    return UNZ_OK;
+}
diff -ruN ./unzip.h ../../dep/quazip/quazip/unzip.h
--- ./unzip.h	2020-11-27 04:16:54.992498165 +0200
+++ ../../dep/quazip/quazip/unzip.h	2020-11-27 04:08:04.065851277 +0200
@@ -1,356 +1,461 @@
-/* unzip.h -- IO for uncompress .zip files using zlib
-   Version 1.01e, February 12th, 2005
-
-   Copyright (C) 1998-2005 Gilles Vollant
-
-   This unzip package allow extract file from .ZIP file, compatible with PKZip 2.04g
-     WinZip, InfoZip tools and compatible.
-
-   Multi volume ZipFile (span) are not supported.
-   Encryption compatible with pkzip 2.04g only supported
-   Old compressions used by old PKZip 1.x are not supported
-
-
-   I WAIT FEEDBACK at mail info@winimage.com
-   Visit also http://www.winimage.com/zLibDll/unzip.htm for evolution
-
-   Condition of use and distribution are the same than zlib :
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-   Modified by Sergey A. Tachenov to integrate with Qt.
-
-
-*/
-
-/* for more info about .ZIP format, see
-      http://www.info-zip.org/pub/infozip/doc/appnote-981119-iz.zip
-      http://www.info-zip.org/pub/infozip/doc/
-   PkWare has also a specification at :
-      ftp://ftp.pkware.com/probdesc.zip
-*/
-
-#ifndef _unz_H
-#define _unz_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#ifndef _ZLIB_H
-#include "zlib.h"
-#endif
-
-#ifndef _ZLIBIOAPI_H
-#include "ioapi.h"
-#endif
-
-#if defined(STRICTUNZIP) || defined(STRICTZIPUNZIP)
-/* like the STRICT of WIN32, we define a pointer that cannot be converted
-    from (void*) without cast */
-typedef struct TagunzFile__ { int unused; } unzFile__;
-typedef unzFile__ *unzFile;
-#else
-typedef voidp unzFile;
-#endif
-
-
-#define UNZ_OK                          (0)
-#define UNZ_END_OF_LIST_OF_FILE         (-100)
-#define UNZ_ERRNO                       (Z_ERRNO)
-#define UNZ_EOF                         (0)
-#define UNZ_PARAMERROR                  (-102)
-#define UNZ_BADZIPFILE                  (-103)
-#define UNZ_INTERNALERROR               (-104)
-#define UNZ_CRCERROR                    (-105)
-
-/* tm_unz contain date/time info */
-typedef struct tm_unz_s
-{
-    uInt tm_sec;            /* seconds after the minute - [0,59] */
-    uInt tm_min;            /* minutes after the hour - [0,59] */
-    uInt tm_hour;           /* hours since midnight - [0,23] */
-    uInt tm_mday;           /* day of the month - [1,31] */
-    uInt tm_mon;            /* months since January - [0,11] */
-    uInt tm_year;           /* years - [1980..2044] */
-} tm_unz;
-
-/* unz_global_info structure contain global data about the ZIPfile
-   These data comes from the end of central dir */
-typedef struct unz_global_info_s
-{
-    uLong number_entry;         /* total number of entries in
-                       the central dir on this disk */
-    uLong size_comment;         /* size of the global comment of the zipfile */
-} unz_global_info;
-
-
-/* unz_file_info contain information about a file in the zipfile */
-typedef struct unz_file_info_s
-{
-    uLong version;              /* version made by                 2 bytes */
-    uLong version_needed;       /* version needed to extract       2 bytes */
-    uLong flag;                 /* general purpose bit flag        2 bytes */
-    uLong compression_method;   /* compression method              2 bytes */
-    uLong dosDate;              /* last mod file date in Dos fmt   4 bytes */
-    uLong crc;                  /* crc-32                          4 bytes */
-    uLong compressed_size;      /* compressed size                 4 bytes */
-    uLong uncompressed_size;    /* uncompressed size               4 bytes */
-    uLong size_filename;        /* filename length                 2 bytes */
-    uLong size_file_extra;      /* extra field length              2 bytes */
-    uLong size_file_comment;    /* file comment length             2 bytes */
-
-    uLong disk_num_start;       /* disk number start               2 bytes */
-    uLong internal_fa;          /* internal file attributes        2 bytes */
-    uLong external_fa;          /* external file attributes        4 bytes */
-
-    tm_unz tmu_date;
-} unz_file_info;
-
-extern int ZEXPORT unzStringFileNameCompare OF ((const char* fileName1,
-                                                 const char* fileName2,
-                                                 int iCaseSensitivity));
-/*
-   Compare two filename (fileName1,fileName2).
-   If iCaseSenisivity = 1, comparision is case sensitivity (like strcmp)
-   If iCaseSenisivity = 2, comparision is not case sensitivity (like strcmpi
-                                or strcasecmp)
-   If iCaseSenisivity = 0, case sensitivity is defaut of your operating system
-    (like 1 on Unix, 2 on Windows)
-*/
-
-
-extern unzFile ZEXPORT unzOpen OF((voidpf file));
-/*
-  Open a Zip file. path contain whatever zopen_file from the IO API
-  accepts. For Qt implementation it is a pointer to QIODevice, for
-  fopen() implementation it's a file name.
-     If the zipfile cannot be opened (file don't exist or in not valid), the
-       return value is NULL.
-     Else, the return value is a unzFile Handle, usable with other function
-       of this unzip package.
-*/
-
-extern unzFile ZEXPORT unzOpen2 OF((voidpf file,
-                                    zlib_filefunc_def* pzlib_filefunc_def));
-/*
-   Open a Zip file, like unzOpen, but provide a set of file low level API
-      for read/write the zip file (see ioapi.h)
-*/
-
-extern int ZEXPORT unzClose OF((unzFile file));
-/*
-  Close a ZipFile opened with unzipOpen.
-  If there is files inside the .Zip opened with unzOpenCurrentFile (see later),
-    these files MUST be closed with unzipCloseCurrentFile before call unzipClose.
-  return UNZ_OK if there is no problem. */
-
-extern int ZEXPORT unzGetGlobalInfo OF((unzFile file,
-                                        unz_global_info *pglobal_info));
-/*
-  Write info about the ZipFile in the *pglobal_info structure.
-  No preparation of the structure is needed
-  return UNZ_OK if there is no problem. */
-
-
-extern int ZEXPORT unzGetGlobalComment OF((unzFile file,
-                                           char *szComment,
-                                           uLong uSizeBuf));
-/*
-  Get the global comment string of the ZipFile, in the szComment buffer.
-  uSizeBuf is the size of the szComment buffer.
-  return the number of byte copied or an error code <0
-*/
-
-
-/***************************************************************************/
-/* Unzip package allow you browse the directory of the zipfile */
-
-extern int ZEXPORT unzGoToFirstFile OF((unzFile file));
-/*
-  Set the current file of the zipfile to the first file.
-  return UNZ_OK if there is no problem
-*/
-
-extern int ZEXPORT unzGoToNextFile OF((unzFile file));
-/*
-  Set the current file of the zipfile to the next file.
-  return UNZ_OK if there is no problem
-  return UNZ_END_OF_LIST_OF_FILE if the actual file was the latest.
-*/
-
-extern int ZEXPORT unzLocateFile OF((unzFile file,
-                     const char *szFileName,
-                     int iCaseSensitivity));
-/*
-  Try locate the file szFileName in the zipfile.
-  For the iCaseSensitivity signification, see unzStringFileNameCompare
-
-  return value :
-  UNZ_OK if the file is found. It becomes the current file.
-  UNZ_END_OF_LIST_OF_FILE if the file is not found
-*/
-
-
-/* ****************************************** */
-/* Ryan supplied functions */
-/* unz_file_info contain information about a file in the zipfile */
-typedef struct unz_file_pos_s
-{
-    uLong pos_in_zip_directory;   /* offset in zip file directory */
-    uLong num_of_file;            /* # of file */
-} unz_file_pos;
-
-extern int ZEXPORT unzGetFilePos(
-    unzFile file,
-    unz_file_pos* file_pos);
-
-extern int ZEXPORT unzGoToFilePos(
-    unzFile file,
-    unz_file_pos* file_pos);
-
-/* ****************************************** */
-
-extern int ZEXPORT unzGetCurrentFileInfo OF((unzFile file,
-                         unz_file_info *pfile_info,
-                         char *szFileName,
-                         uLong fileNameBufferSize,
-                         void *extraField,
-                         uLong extraFieldBufferSize,
-                         char *szComment,
-                         uLong commentBufferSize));
-/*
-  Get Info about the current file
-  if pfile_info!=NULL, the *pfile_info structure will contain somes info about
-        the current file
-  if szFileName!=NULL, the filemane string will be copied in szFileName
-            (fileNameBufferSize is the size of the buffer)
-  if extraField!=NULL, the extra field information will be copied in extraField
-            (extraFieldBufferSize is the size of the buffer).
-            This is the Central-header version of the extra field
-  if szComment!=NULL, the comment string of the file will be copied in szComment
-            (commentBufferSize is the size of the buffer)
-*/
-
-/***************************************************************************/
-/* for reading the content of the current zipfile, you can open it, read data
-   from it, and close it (you can close it before reading all the file)
-   */
-
-extern int ZEXPORT unzOpenCurrentFile OF((unzFile file));
-/*
-  Open for reading data the current file in the zipfile.
-  If there is no error, the return value is UNZ_OK.
-*/
-
-extern int ZEXPORT unzOpenCurrentFilePassword OF((unzFile file,
-                                                  const char* password));
-/*
-  Open for reading data the current file in the zipfile.
-  password is a crypting password
-  If there is no error, the return value is UNZ_OK.
-*/
-
-extern int ZEXPORT unzOpenCurrentFile2 OF((unzFile file,
-                                           int* method,
-                                           int* level,
-                                           int raw));
-/*
-  Same than unzOpenCurrentFile, but open for read raw the file (not uncompress)
-    if raw==1
-  *method will receive method of compression, *level will receive level of
-     compression
-  note : you can set level parameter as NULL (if you did not want known level,
-         but you CANNOT set method parameter as NULL
-*/
-
-extern int ZEXPORT unzOpenCurrentFile3 OF((unzFile file,
-                                           int* method,
-                                           int* level,
-                                           int raw,
-                                           const char* password));
-/*
-  Same than unzOpenCurrentFile, but open for read raw the file (not uncompress)
-    if raw==1
-  *method will receive method of compression, *level will receive level of
-     compression
-  note : you can set level parameter as NULL (if you did not want known level,
-         but you CANNOT set method parameter as NULL
-*/
-
-
-extern int ZEXPORT unzCloseCurrentFile OF((unzFile file));
-/*
-  Close the file in zip opened with unzOpenCurrentFile
-  Return UNZ_CRCERROR if all the file was read but the CRC is not good
-*/
-
-extern int ZEXPORT unzReadCurrentFile OF((unzFile file,
-                      voidp buf,
-                      unsigned len));
-/*
-  Read bytes from the current file (opened by unzOpenCurrentFile)
-  buf contain buffer where data must be copied
-  len the size of buf.
-
-  return the number of byte copied if somes bytes are copied
-  return 0 if the end of file was reached
-  return <0 with error code if there is an error
-    (UNZ_ERRNO for IO error, or zLib error for uncompress error)
-*/
-
-extern z_off_t ZEXPORT unztell OF((unzFile file));
-/*
-  Give the current position in uncompressed data
-*/
-
-extern int ZEXPORT unzeof OF((unzFile file));
-/*
-  return 1 if the end of file was reached, 0 elsewhere
-*/
-
-extern int ZEXPORT unzGetLocalExtrafield OF((unzFile file,
-                                             voidp buf,
-                                             unsigned len));
-/*
-  Read extra field from the current file (opened by unzOpenCurrentFile)
-  This is the local-header version of the extra field (sometimes, there is
-    more info in the local-header version than in the central-header)
-
-  if buf==NULL, it return the size of the local extra field
-
-  if buf!=NULL, len is the size of the buffer, the extra header is copied in
-    buf.
-  the return value is the number of bytes copied in buf, or (if <0)
-    the error code
-*/
-
-/***************************************************************************/
-
-/* Get the current file offset */
-extern uLong ZEXPORT unzGetOffset (unzFile file);
-
-/* Set the current file offset */
-extern int ZEXPORT unzSetOffset (unzFile file, uLong pos);
-
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _unz_H */
+/* unzip.h -- IO for uncompress .zip files using zlib
+   Version 1.1, February 14h, 2010
+   part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )
+
+         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )
+
+         Modifications of Unzip for Zip64
+         Copyright (C) 2007-2008 Even Rouault
+
+         Modifications for Zip64 support on both zip and unzip
+         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )
+
+         For more info read MiniZip_info.txt
+
+         ---------------------------------------------------------------------------------
+
+        Condition of use and distribution are the same than zlib :
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+
+  ---------------------------------------------------------------------------------
+
+        Changes
+
+        See header of unzip64.c
+
+  ---------------------------------------------------------------------------
+
+  As per the requirement above, this file is plainly marked as modified
+  by Sergey A. Tachenov. Most modifications include the I/O API redesign
+  to support QIODevice interface. Some improvements and small fixes were also made.
+*/
+
+#ifndef _unz64_H
+#define _unz64_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef _ZLIB_H
+#include <zlib.h>
+#endif
+
+#ifndef  _ZLIBIOAPI_H
+#include "ioapi.h"
+#endif
+
+#ifdef HAVE_BZIP2
+#include "bzlib.h"
+#endif
+
+#define Z_BZIP2ED 12
+
+#if defined(STRICTUNZIP) || defined(STRICTZIPUNZIP)
+/* like the STRICT of WIN32, we define a pointer that cannot be converted
+    from (void*) without cast */
+typedef struct TagunzFile__ { int unused; } unzFile__;
+typedef unzFile__ *unzFile;
+#else
+typedef voidp unzFile;
+#endif
+
+
+#define UNZ_OK                          (0)
+#define UNZ_END_OF_LIST_OF_FILE         (-100)
+#define UNZ_ERRNO                       (Z_ERRNO)
+#define UNZ_EOF                         (0)
+#define UNZ_PARAMERROR                  (-102)
+#define UNZ_BADZIPFILE                  (-103)
+#define UNZ_INTERNALERROR               (-104)
+#define UNZ_CRCERROR                    (-105)
+
+#define UNZ_AUTO_CLOSE 0x01u
+#define UNZ_DEFAULT_FLAGS UNZ_AUTO_CLOSE
+#define UNZ_ENCODING_UTF8 0x0800u
+
+/* tm_unz contain date/time info */
+typedef struct tm_unz_s
+{
+    uInt tm_sec;            /* seconds after the minute - [0,59] */
+    uInt tm_min;            /* minutes after the hour - [0,59] */
+    uInt tm_hour;           /* hours since midnight - [0,23] */
+    uInt tm_mday;           /* day of the month - [1,31] */
+    uInt tm_mon;            /* months since January - [0,11] */
+    uInt tm_year;           /* years - [1980..2044] */
+} tm_unz;
+
+/* unz_global_info structure contain global data about the ZIPfile
+   These data comes from the end of central dir */
+typedef struct unz_global_info64_s
+{
+    ZPOS64_T number_entry;         /* total number of entries in
+                                     the central dir on this disk */
+    uLong size_comment;         /* size of the global comment of the zipfile */
+} unz_global_info64;
+
+typedef struct unz_global_info_s
+{
+    uLong number_entry;         /* total number of entries in
+                                     the central dir on this disk */
+    uLong size_comment;         /* size of the global comment of the zipfile */
+} unz_global_info;
+
+/* unz_file_info contain information about a file in the zipfile */
+typedef struct unz_file_info64_s
+{
+    uLong version;              /* version made by                 2 bytes */
+    uLong version_needed;       /* version needed to extract       2 bytes */
+    uLong flag;                 /* general purpose bit flag        2 bytes */
+    uLong compression_method;   /* compression method              2 bytes */
+    uLong dosDate;              /* last mod file date in Dos fmt   4 bytes */
+    uLong crc;                  /* crc-32                          4 bytes */
+    ZPOS64_T compressed_size;   /* compressed size                 8 bytes */
+    ZPOS64_T uncompressed_size; /* uncompressed size               8 bytes */
+    uLong size_filename;        /* filename length                 2 bytes */
+    uLong size_file_extra;      /* extra field length              2 bytes */
+    uLong size_file_comment;    /* file comment length             2 bytes */
+
+    uLong disk_num_start;       /* disk number start               2 bytes */
+    uLong internal_fa;          /* internal file attributes        2 bytes */
+    uLong external_fa;          /* external file attributes        4 bytes */
+
+    tm_unz tmu_date;
+} unz_file_info64;
+
+typedef struct unz_file_info_s
+{
+    uLong version;              /* version made by                 2 bytes */
+    uLong version_needed;       /* version needed to extract       2 bytes */
+    uLong flag;                 /* general purpose bit flag        2 bytes */
+    uLong compression_method;   /* compression method              2 bytes */
+    uLong dosDate;              /* last mod file date in Dos fmt   4 bytes */
+    uLong crc;                  /* crc-32                          4 bytes */
+    uLong compressed_size;      /* compressed size                 4 bytes */
+    uLong uncompressed_size;    /* uncompressed size               4 bytes */
+    uLong size_filename;        /* filename length                 2 bytes */
+    uLong size_file_extra;      /* extra field length              2 bytes */
+    uLong size_file_comment;    /* file comment length             2 bytes */
+
+    uLong disk_num_start;       /* disk number start               2 bytes */
+    uLong internal_fa;          /* internal file attributes        2 bytes */
+    uLong external_fa;          /* external file attributes        4 bytes */
+
+    tm_unz tmu_date;
+} unz_file_info;
+
+extern int ZEXPORT unzStringFileNameCompare OF ((const char* fileName1,
+                                                 const char* fileName2,
+                                                 int iCaseSensitivity));
+/*
+   Compare two filename (fileName1,fileName2).
+   If iCaseSenisivity = 1, comparision is case sensitivity (like strcmp)
+   If iCaseSenisivity = 2, comparision is not case sensitivity (like strcmpi
+                                or strcasecmp)
+   If iCaseSenisivity = 0, case sensitivity is defaut of your operating system
+    (like 1 on Unix, 2 on Windows)
+*/
+
+
+extern unzFile ZEXPORT unzOpen OF((voidpf file));
+extern unzFile ZEXPORT unzOpen64 OF((voidpf file));
+/*
+  Open a Zip file. path contain the full pathname (by example,
+     on a Windows XP computer "c:\\zlib\\zlib113.zip" or on an Unix computer
+     "zlib/zlib113.zip".
+     If the zipfile cannot be opened (file don't exist or in not valid), the
+       return value is NULL.
+     Else, the return value is a unzFile Handle, usable with other function
+       of this unzip package.
+     the "64" function take a const void* pointer, because the path is just the
+       value passed to the open64_file_func callback.
+     Under Windows, if UNICODE is defined, using fill_fopen64_filefunc, the path
+       is a pointer to a wide unicode string (LPCTSTR is LPCWSTR), so const char*
+       does not describe the reality
+*/
+
+
+extern unzFile ZEXPORT unzOpen2 OF((voidpf file,
+                                    zlib_filefunc_def* pzlib_filefunc_def));
+/*
+   Open a Zip file, like unzOpen, but provide a set of file low level API
+      for read/write the zip file (see ioapi.h)
+*/
+
+extern unzFile ZEXPORT unzOpen2_64 OF((voidpf file,
+                                    zlib_filefunc64_def* pzlib_filefunc_def));
+/*
+   Open a Zip file, like unz64Open, but provide a set of file low level API
+      for read/write the zip file (see ioapi.h)
+*/
+
+
+/*
+ * Exported by Sergey A. Tachenov to implement some QuaZip features. This
+ * function MAY change signature in order to implement even more features.
+ * You have been warned!
+ * */
+extern unzFile unzOpenInternal (voidpf file,
+                               zlib_filefunc64_32_def* pzlib_filefunc64_32_def,
+                               int is64bitOpenFunction, unsigned flags);
+
+
+
+extern int ZEXPORT unzClose OF((unzFile file));
+/*
+  Close a ZipFile opened with unzipOpen.
+  If there is files inside the .Zip opened with unzOpenCurrentFile (see later),
+    these files MUST be closed with unzipCloseCurrentFile before call unzipClose.
+  return UNZ_OK if there is no problem. */
+
+extern int ZEXPORT unzGetGlobalInfo OF((unzFile file,
+                                        unz_global_info *pglobal_info));
+
+extern int ZEXPORT unzGetGlobalInfo64 OF((unzFile file,
+                                        unz_global_info64 *pglobal_info));
+
+extern int ZEXPORT unzGetFileFlags OF((unzFile file, unsigned* pflags));
+/*
+  Write info about the ZipFile in the *pglobal_info structure.
+  No preparation of the structure is needed
+  return UNZ_OK if there is no problem. */
+
+
+extern int ZEXPORT unzGetGlobalComment OF((unzFile file,
+                                           char *szComment,
+                                           uLong uSizeBuf));
+/*
+  Get the global comment string of the ZipFile, in the szComment buffer.
+  uSizeBuf is the size of the szComment buffer.
+  return the number of byte copied or an error code <0
+*/
+
+
+/***************************************************************************/
+/* Unzip package allow you browse the directory of the zipfile */
+
+extern int ZEXPORT unzGoToFirstFile OF((unzFile file));
+/*
+  Set the current file of the zipfile to the first file.
+  return UNZ_OK if there is no problem
+*/
+
+extern int ZEXPORT unzGoToNextFile OF((unzFile file));
+/*
+  Set the current file of the zipfile to the next file.
+  return UNZ_OK if there is no problem
+  return UNZ_END_OF_LIST_OF_FILE if the actual file was the latest.
+*/
+
+extern int ZEXPORT unzLocateFile OF((unzFile file,
+                     const char *szFileName,
+                     int iCaseSensitivity));
+/*
+  Try locate the file szFileName in the zipfile.
+  For the iCaseSensitivity signification, see unzStringFileNameCompare
+
+  return value :
+  UNZ_OK if the file is found. It becomes the current file.
+  UNZ_END_OF_LIST_OF_FILE if the file is not found
+*/
+
+
+/* ****************************************** */
+/* Ryan supplied functions */
+/* unz_file_info contain information about a file in the zipfile */
+typedef struct unz_file_pos_s
+{
+    uLong pos_in_zip_directory;   /* offset in zip file directory */
+    uLong num_of_file;            /* # of file */
+} unz_file_pos;
+
+extern int ZEXPORT unzGetFilePos(
+    unzFile file,
+    unz_file_pos* file_pos);
+
+extern int ZEXPORT unzGoToFilePos(
+    unzFile file,
+    unz_file_pos* file_pos);
+
+typedef struct unz64_file_pos_s
+{
+    ZPOS64_T pos_in_zip_directory;   /* offset in zip file directory */
+    ZPOS64_T num_of_file;            /* # of file */
+} unz64_file_pos;
+
+extern int ZEXPORT unzGetFilePos64(
+    unzFile file,
+    unz64_file_pos* file_pos);
+
+extern int ZEXPORT unzGoToFilePos64(
+    unzFile file,
+    const unz64_file_pos* file_pos);
+
+/* ****************************************** */
+
+extern int ZEXPORT unzGetCurrentFileInfo64 OF((unzFile file,
+                         unz_file_info64 *pfile_info,
+                         char *szFileName,
+                         uLong fileNameBufferSize,
+                         void *extraField,
+                         uLong extraFieldBufferSize,
+                         char *szComment,
+                         uLong commentBufferSize));
+
+extern int ZEXPORT unzGetCurrentFileInfo OF((unzFile file,
+                         unz_file_info *pfile_info,
+                         char *szFileName,
+                         uLong fileNameBufferSize,
+                         void *extraField,
+                         uLong extraFieldBufferSize,
+                         char *szComment,
+                         uLong commentBufferSize));
+/*
+  Get Info about the current file
+  if pfile_info!=NULL, the *pfile_info structure will contain somes info about
+        the current file
+  if szFileName!=NULL, the filemane string will be copied in szFileName
+            (fileNameBufferSize is the size of the buffer)
+  if extraField!=NULL, the extra field information will be copied in extraField
+            (extraFieldBufferSize is the size of the buffer).
+            This is the Central-header version of the extra field
+  if szComment!=NULL, the comment string of the file will be copied in szComment
+            (commentBufferSize is the size of the buffer)
+*/
+
+
+/** Addition for GDAL : START */
+
+extern ZPOS64_T ZEXPORT unzGetCurrentFileZStreamPos64 OF((unzFile file));
+
+/** Addition for GDAL : END */
+
+
+/***************************************************************************/
+/* for reading the content of the current zipfile, you can open it, read data
+   from it, and close it (you can close it before reading all the file)
+   */
+
+extern int ZEXPORT unzOpenCurrentFile OF((unzFile file));
+/*
+  Open for reading data the current file in the zipfile.
+  If there is no error, the return value is UNZ_OK.
+*/
+
+extern int ZEXPORT unzOpenCurrentFilePassword OF((unzFile file,
+                                                  const char* password));
+/*
+  Open for reading data the current file in the zipfile.
+  password is a crypting password
+  If there is no error, the return value is UNZ_OK.
+*/
+
+extern int ZEXPORT unzOpenCurrentFile2 OF((unzFile file,
+                                           int* method,
+                                           int* level,
+                                           int raw));
+/*
+  Same than unzOpenCurrentFile, but open for read raw the file (not uncompress)
+    if raw==1
+  *method will receive method of compression, *level will receive level of
+     compression
+  note : you can set level parameter as NULL (if you did not want known level,
+         but you CANNOT set method parameter as NULL
+*/
+
+extern int ZEXPORT unzOpenCurrentFile3 OF((unzFile file,
+                                           int* method,
+                                           int* level,
+                                           int raw,
+                                           const char* password));
+/*
+  Same than unzOpenCurrentFile, but open for read raw the file (not uncompress)
+    if raw==1
+  *method will receive method of compression, *level will receive level of
+     compression
+  note : you can set level parameter as NULL (if you did not want known level,
+         but you CANNOT set method parameter as NULL
+*/
+
+
+extern int ZEXPORT unzCloseCurrentFile OF((unzFile file));
+/*
+  Close the file in zip opened with unzOpenCurrentFile
+  Return UNZ_CRCERROR if all the file was read but the CRC is not good
+*/
+
+extern int ZEXPORT unzReadCurrentFile OF((unzFile file,
+                      voidp buf,
+                      unsigned len));
+/*
+  Read bytes from the current file (opened by unzOpenCurrentFile)
+  buf contain buffer where data must be copied
+  len the size of buf.
+
+  return the number of byte copied if somes bytes are copied
+  return 0 if the end of file was reached
+  return <0 with error code if there is an error
+    (UNZ_ERRNO for IO error, or zLib error for uncompress error)
+*/
+
+extern z_off_t ZEXPORT unztell OF((unzFile file));
+
+extern ZPOS64_T ZEXPORT unztell64 OF((unzFile file));
+/*
+  Give the current position in uncompressed data
+*/
+
+extern int ZEXPORT unzeof OF((unzFile file));
+/*
+  return 1 if the end of file was reached, 0 elsewhere
+*/
+
+extern int ZEXPORT unzGetLocalExtrafield OF((unzFile file,
+                                             voidp buf,
+                                             unsigned len));
+/*
+  Read extra field from the current file (opened by unzOpenCurrentFile)
+  This is the local-header version of the extra field (sometimes, there is
+    more info in the local-header version than in the central-header)
+
+  if buf==NULL, it return the size of the local extra field
+
+  if buf!=NULL, len is the size of the buffer, the extra header is copied in
+    buf.
+  the return value is the number of bytes copied in buf, or (if <0)
+    the error code
+*/
+
+/***************************************************************************/
+
+/* Get the current file offset */
+extern ZPOS64_T ZEXPORT unzGetOffset64 (unzFile file);
+extern uLong ZEXPORT unzGetOffset (unzFile file);
+
+/* Set the current file offset */
+extern int ZEXPORT unzSetOffset64 (unzFile file, ZPOS64_T pos);
+extern int ZEXPORT unzSetOffset (unzFile file, uLong pos);
+
+extern int ZEXPORT unzSetFlags(unzFile file, unsigned flags);
+extern int ZEXPORT unzClearFlags(unzFile file, unsigned flags);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _unz64_H */
diff -ruN ./zip.c ../../dep/quazip/quazip/zip.c
--- ./zip.c	2020-11-27 04:16:54.992498165 +0200
+++ ../../dep/quazip/quazip/zip.c	2020-11-27 04:08:04.065851277 +0200
@@ -1,1280 +1,2111 @@
-/* zip.c -- IO on .zip files using zlib
-   Version 1.01e, February 12th, 2005
-
-   27 Dec 2004 Rolf Kalbermatter
-   Modification to zipOpen2 to support globalComment retrieval.
-
-   Copyright (C) 1998-2005 Gilles Vollant
-
-   Read zip.h for more info
-
-   Modified by Sergey A. Tachenov to integrate with Qt.
-*/
-
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <time.h>
-//#include "zlib.h"
-#include "zip.h"
-#include "quazip_global.h"
-
-#ifdef STDC
-#  include <stddef.h>
-#  include <string.h>
-#  include <stdlib.h>
-#endif
-#ifdef NO_ERRNO_H
-    extern int errno;
-#else
-#   include <errno.h>
-#endif
-
-
-#ifndef local
-#  define local static
-#endif
-/* compile with -Dlocal if your debugger can't find static symbols */
-
-#ifndef VERSIONMADEBY
-# define VERSIONMADEBY   (0x031e) /* best for standard pkware crypt */
-#endif
-
-#ifndef Z_BUFSIZE
-#define Z_BUFSIZE (16384)
-#endif
-
-#ifndef Z_MAXFILENAMEINZIP
-#define Z_MAXFILENAMEINZIP (256)
-#endif
-
-#ifndef ALLOC
-# define ALLOC(size) (malloc(size))
-#endif
-#ifndef TRYFREE
-# define TRYFREE(p) {if (p) free(p);}
-#endif
-
-/*
-#define SIZECENTRALDIRITEM (0x2e)
-#define SIZEZIPLOCALHEADER (0x1e)
-*/
-
-/* I've found an old Unix (a SunOS 4.1.3_U1) without all SEEK_* defined.... */
-
-#ifndef SEEK_CUR
-#define SEEK_CUR    1
-#endif
-
-#ifndef SEEK_END
-#define SEEK_END    2
-#endif
-
-#ifndef SEEK_SET
-#define SEEK_SET    0
-#endif
-
-#ifndef DEF_MEM_LEVEL
-#if MAX_MEM_LEVEL >= 8
-#  define DEF_MEM_LEVEL 8
-#else
-#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
-#endif
-#endif
-const char zip_copyright[] =
-   " zip 1.01 Copyright 1998-2004 Gilles Vollant - http://www.winimage.com/zLibDll";
-
-
-#define SIZEDATA_INDATABLOCK (4096-(4*4))
-
-#define LOCALHEADERMAGIC    (0x04034b50)
-#define DESCRIPTORHEADERMAGIC    (0x08074b50)
-#define CENTRALHEADERMAGIC  (0x02014b50)
-#define ENDHEADERMAGIC      (0x06054b50)
-
-#define FLAG_LOCALHEADER_OFFSET (0x06)
-#define CRC_LOCALHEADER_OFFSET  (0x0e)
-
-#define SIZECENTRALHEADER (0x2e) /* 46 */
-
-typedef struct linkedlist_datablock_internal_s
-{
-  struct linkedlist_datablock_internal_s* next_datablock;
-  uLong  avail_in_this_block;
-  uLong  filled_in_this_block;
-  uLong  unused; /* for future use and alignement */
-  unsigned char data[SIZEDATA_INDATABLOCK];
-} linkedlist_datablock_internal;
-
-typedef struct linkedlist_data_s
-{
-    linkedlist_datablock_internal* first_block;
-    linkedlist_datablock_internal* last_block;
-} linkedlist_data;
-
-
-typedef struct
-{
-    z_stream stream;            /* zLib stream structure for inflate */
-    int  stream_initialised;    /* 1 is stream is initialised */
-    uInt pos_in_buffered_data;  /* last written byte in buffered_data */
-
-    uLong pos_local_header;     /* offset of the local header of the file
-                                     currenty writing */
-    char* central_header;       /* central header data for the current file */
-    uLong size_centralheader;   /* size of the central header for cur file */
-    uLong flag;                 /* flag of the file currently writing */
-
-    int  method;                /* compression method of file currenty wr.*/
-    int  raw;                   /* 1 for directly writing raw data */
-    Byte buffered_data[Z_BUFSIZE];/* buffer contain compressed data to be writ*/
-    uLong dosDate;
-    uLong crc32;
-    int  encrypt;
-#ifndef NOCRYPT
-    unsigned long keys[3];     /* keys defining the pseudo-random sequence */
-    const unsigned long* pcrc_32_tab;
-    int crypt_header_size;
-#endif
-} curfile_info;
-
-typedef struct
-{
-    zlib_filefunc_def z_filefunc;
-    voidpf filestream;        /* io structore of the zipfile */
-    linkedlist_data central_dir;/* datablock with central dir in construction*/
-    int  in_opened_file_inzip;  /* 1 if a file in the zip is currently writ.*/
-    curfile_info ci;            /* info on the file curretly writing */
-
-    uLong begin_pos;            /* position of the beginning of the zipfile */
-    uLong add_position_when_writting_offset;
-    uLong number_entry;
-#ifndef NO_ADDFILEINEXISTINGZIP
-    char *globalcomment;
-#endif
-    unsigned flags;
-} zip_internal;
-
-
-
-#ifndef NOCRYPT
-#define INCLUDECRYPTINGCODE_IFCRYPTALLOWED
-#include "crypt.h"
-#endif
-
-local linkedlist_datablock_internal* allocate_new_datablock()
-{
-    linkedlist_datablock_internal* ldi;
-    ldi = (linkedlist_datablock_internal*)
-                 ALLOC(sizeof(linkedlist_datablock_internal));
-    if (ldi!=NULL)
-    {
-        ldi->next_datablock = NULL ;
-        ldi->filled_in_this_block = 0 ;
-        ldi->avail_in_this_block = SIZEDATA_INDATABLOCK ;
-    }
-    return ldi;
-}
-
-local void free_datablock(ldi)
-    linkedlist_datablock_internal* ldi;
-{
-    while (ldi!=NULL)
-    {
-        linkedlist_datablock_internal* ldinext = ldi->next_datablock;
-        TRYFREE(ldi);
-        ldi = ldinext;
-    }
-}
-
-local void init_linkedlist(ll)
-    linkedlist_data* ll;
-{
-    ll->first_block = ll->last_block = NULL;
-}
-
-#if 0 // unused
-local void free_linkedlist(ll)
-    linkedlist_data* ll;
-{
-    free_datablock(ll->first_block);
-    ll->first_block = ll->last_block = NULL;
-}
-#endif
-
-local int add_data_in_datablock(ll,buf,len)
-    linkedlist_data* ll;
-    const void* buf;
-    uLong len;
-{
-    linkedlist_datablock_internal* ldi;
-    const unsigned char* from_copy;
-
-    if (ll==NULL)
-        return ZIP_INTERNALERROR;
-
-    if (ll->last_block == NULL)
-    {
-        ll->first_block = ll->last_block = allocate_new_datablock();
-        if (ll->first_block == NULL)
-            return ZIP_INTERNALERROR;
-    }
-
-    ldi = ll->last_block;
-    from_copy = (unsigned char*)buf;
-
-    while (len>0)
-    {
-        uInt copy_this;
-        uInt i;
-        unsigned char* to_copy;
-
-        if (ldi->avail_in_this_block==0)
-        {
-            ldi->next_datablock = allocate_new_datablock();
-            if (ldi->next_datablock == NULL)
-                return ZIP_INTERNALERROR;
-            ldi = ldi->next_datablock ;
-            ll->last_block = ldi;
-        }
-
-        if (ldi->avail_in_this_block < len)
-            copy_this = (uInt)ldi->avail_in_this_block;
-        else
-            copy_this = (uInt)len;
-
-        to_copy = &(ldi->data[ldi->filled_in_this_block]);
-
-        for (i=0;i<copy_this;i++)
-            *(to_copy+i)=*(from_copy+i);
-
-        ldi->filled_in_this_block += copy_this;
-        ldi->avail_in_this_block -= copy_this;
-        from_copy += copy_this ;
-        len -= copy_this;
-    }
-    return ZIP_OK;
-}
-
-
-
-/****************************************************************************/
-
-#ifndef NO_ADDFILEINEXISTINGZIP
-/* ===========================================================================
-   Inputs a long in LSB order to the given file
-   nbByte == 1, 2 or 4 (byte, short or long)
-*/
-
-local int ziplocal_putValue OF((const zlib_filefunc_def* pzlib_filefunc_def,
-                                voidpf filestream, uLong x, int nbByte));
-local int ziplocal_putValue (pzlib_filefunc_def, filestream, x, nbByte)
-    const zlib_filefunc_def* pzlib_filefunc_def;
-    voidpf filestream;
-    uLong x;
-    int nbByte;
-{
-    unsigned char buf[4];
-    int n;
-    for (n = 0; n < nbByte; n++)
-    {
-        buf[n] = (unsigned char)(x & 0xff);
-        x >>= 8;
-    }
-    if (x != 0)
-      {     /* data overflow - hack for ZIP64 (X Roche) */
-      for (n = 0; n < nbByte; n++)
-        {
-          buf[n] = 0xff;
-        }
-      }
-
-    if (ZWRITE(*pzlib_filefunc_def,filestream,buf,nbByte)!=(uLong)nbByte)
-        return ZIP_ERRNO;
-    else
-        return ZIP_OK;
-}
-
-local void ziplocal_putValue_inmemory OF((void* dest, uLong x, int nbByte));
-local void ziplocal_putValue_inmemory (dest, x, nbByte)
-    void* dest;
-    uLong x;
-    int nbByte;
-{
-    unsigned char* buf=(unsigned char*)dest;
-    int n;
-    for (n = 0; n < nbByte; n++) {
-        buf[n] = (unsigned char)(x & 0xff);
-        x >>= 8;
-    }
-
-    if (x != 0)
-    {     /* data overflow - hack for ZIP64 */
-       for (n = 0; n < nbByte; n++)
-       {
-          buf[n] = 0xff;
-       }
-    }
-}
-
-/****************************************************************************/
-
-
-local uLong ziplocal_TmzDateToDosDate(ptm,dosDate)
-    const tm_zip* ptm;
-    uLong dosDate UNUSED;
-{
-    uLong year = (uLong)ptm->tm_year;
-    if (year>1980)
-        year-=1980;
-    else if (year>80)
-        year-=80;
-    return
-      (uLong) (((ptm->tm_mday) + (32 * (ptm->tm_mon+1)) + (512 * year)) << 16) |
-        ((ptm->tm_sec/2) + (32* ptm->tm_min) + (2048 * (uLong)ptm->tm_hour));
-}
-
-
-/****************************************************************************/
-
-local int ziplocal_getByte OF((
-    const zlib_filefunc_def* pzlib_filefunc_def,
-    voidpf filestream,
-    int *pi));
-
-local int ziplocal_getByte(pzlib_filefunc_def,filestream,pi)
-    const zlib_filefunc_def* pzlib_filefunc_def;
-    voidpf filestream;
-    int *pi;
-{
-    unsigned char c;
-    int err = (int)ZREAD(*pzlib_filefunc_def,filestream,&c,1);
-    if (err==1)
-    {
-        *pi = (int)c;
-        return ZIP_OK;
-    }
-    else
-    {
-        if (ZERROR(*pzlib_filefunc_def,filestream))
-            return ZIP_ERRNO;
-        else
-            return ZIP_EOF;
-    }
-}
-
-
-/* ===========================================================================
-   Reads a long in LSB order from the given gz_stream. Sets
-*/
-local int ziplocal_getShort OF((
-    const zlib_filefunc_def* pzlib_filefunc_def,
-    voidpf filestream,
-    uLong *pX));
-
-local int ziplocal_getShort (pzlib_filefunc_def,filestream,pX)
-    const zlib_filefunc_def* pzlib_filefunc_def;
-    voidpf filestream;
-    uLong *pX;
-{
-    uLong x ;
-    int i;
-    int err;
-
-    err = ziplocal_getByte(pzlib_filefunc_def,filestream,&i);
-    x = (uLong)i;
-
-    if (err==ZIP_OK)
-        err = ziplocal_getByte(pzlib_filefunc_def,filestream,&i);
-    x += ((uLong)i)<<8;
-
-    if (err==ZIP_OK)
-        *pX = x;
-    else
-        *pX = 0;
-    return err;
-}
-
-local int ziplocal_getLong OF((
-    const zlib_filefunc_def* pzlib_filefunc_def,
-    voidpf filestream,
-    uLong *pX));
-
-local int ziplocal_getLong (pzlib_filefunc_def,filestream,pX)
-    const zlib_filefunc_def* pzlib_filefunc_def;
-    voidpf filestream;
-    uLong *pX;
-{
-    uLong x ;
-    int i;
-    int err;
-
-    err = ziplocal_getByte(pzlib_filefunc_def,filestream,&i);
-    x = (uLong)i;
-
-    if (err==ZIP_OK)
-        err = ziplocal_getByte(pzlib_filefunc_def,filestream,&i);
-    x += ((uLong)i)<<8;
-
-    if (err==ZIP_OK)
-        err = ziplocal_getByte(pzlib_filefunc_def,filestream,&i);
-    x += ((uLong)i)<<16;
-
-    if (err==ZIP_OK)
-        err = ziplocal_getByte(pzlib_filefunc_def,filestream,&i);
-    x += ((uLong)i)<<24;
-
-    if (err==ZIP_OK)
-        *pX = x;
-    else
-        *pX = 0;
-    return err;
-}
-
-#ifndef BUFREADCOMMENT
-#define BUFREADCOMMENT (0x400)
-#endif
-/*
-  Locate the Central directory of a zipfile (at the end, just before
-    the global comment)
-*/
-local uLong ziplocal_SearchCentralDir OF((
-    const zlib_filefunc_def* pzlib_filefunc_def,
-    voidpf filestream));
-
-local uLong ziplocal_SearchCentralDir(pzlib_filefunc_def,filestream)
-    const zlib_filefunc_def* pzlib_filefunc_def;
-    voidpf filestream;
-{
-    unsigned char* buf;
-    uLong uSizeFile;
-    uLong uBackRead;
-    uLong uMaxBack=0xffff; /* maximum size of global comment */
-    uLong uPosFound=0;
-
-    if (ZSEEK(*pzlib_filefunc_def,filestream,0,ZLIB_FILEFUNC_SEEK_END) != 0)
-        return 0;
-
-
-    uSizeFile = ZTELL(*pzlib_filefunc_def,filestream);
-
-    if (uMaxBack>uSizeFile)
-        uMaxBack = uSizeFile;
-
-    buf = (unsigned char*)ALLOC(BUFREADCOMMENT+4);
-    if (buf==NULL)
-        return 0;
-
-    uBackRead = 4;
-    while (uBackRead<uMaxBack)
-    {
-        uLong uReadSize,uReadPos ;
-        int i;
-        if (uBackRead+BUFREADCOMMENT>uMaxBack)
-            uBackRead = uMaxBack;
-        else
-            uBackRead+=BUFREADCOMMENT;
-        uReadPos = uSizeFile-uBackRead ;
-
-        uReadSize = ((BUFREADCOMMENT+4) < (uSizeFile-uReadPos)) ?
-                     (BUFREADCOMMENT+4) : (uSizeFile-uReadPos);
-        if (ZSEEK(*pzlib_filefunc_def,filestream,uReadPos,ZLIB_FILEFUNC_SEEK_SET)!=0)
-            break;
-
-        if (ZREAD(*pzlib_filefunc_def,filestream,buf,uReadSize)!=uReadSize)
-            break;
-
-        for (i=(int)uReadSize-3; (i--)>0;)
-            if (((*(buf+i))==0x50) && ((*(buf+i+1))==0x4b) &&
-                ((*(buf+i+2))==0x05) && ((*(buf+i+3))==0x06))
-            {
-                uPosFound = uReadPos+i;
-                break;
-            }
-
-        if (uPosFound!=0)
-            break;
-    }
-    TRYFREE(buf);
-    return uPosFound;
-}
-#endif /* !NO_ADDFILEINEXISTINGZIP*/
-
-/************************************************************/
-extern zipFile ZEXPORT zipOpen2 (file, append, globalcomment, pzlib_filefunc_def)
-    voidpf file;
-    int append;
-    zipcharpc* globalcomment;
-    zlib_filefunc_def* pzlib_filefunc_def;
-{
-    zip_internal ziinit;
-    zip_internal* zi;
-    int err=ZIP_OK;
-
-
-    if (pzlib_filefunc_def==NULL)
-        fill_qiodevice_filefunc(&ziinit.z_filefunc);
-    else
-        ziinit.z_filefunc = *pzlib_filefunc_def;
-
-    ziinit.filestream = (*(ziinit.z_filefunc.zopen_file))
-                 (ziinit.z_filefunc.opaque,
-                  file,
-                  (append == APPEND_STATUS_CREATE) ?
-                  (ZLIB_FILEFUNC_MODE_READ | ZLIB_FILEFUNC_MODE_WRITE | ZLIB_FILEFUNC_MODE_CREATE) :
-                    (ZLIB_FILEFUNC_MODE_READ | ZLIB_FILEFUNC_MODE_WRITE | ZLIB_FILEFUNC_MODE_EXISTING));
-
-    if (ziinit.filestream == NULL)
-        return NULL;
-    ziinit.begin_pos = ZTELL(ziinit.z_filefunc,ziinit.filestream);
-    ziinit.in_opened_file_inzip = 0;
-    ziinit.ci.stream_initialised = 0;
-    ziinit.number_entry = 0;
-    ziinit.add_position_when_writting_offset = 0;
-    ziinit.flags = ZIP_WRITE_DATA_DESCRIPTOR;
-    init_linkedlist(&(ziinit.central_dir));
-
-
-    zi = (zip_internal*)ALLOC(sizeof(zip_internal));
-    if (zi==NULL)
-    {
-        ZCLOSE(ziinit.z_filefunc,ziinit.filestream);
-        return NULL;
-    }
-
-    /* now we add file in a zipfile */
-#    ifndef NO_ADDFILEINEXISTINGZIP
-    ziinit.globalcomment = NULL;
-    if (append == APPEND_STATUS_ADDINZIP)
-    {
-        uLong byte_before_the_zipfile;/* byte before the zipfile, (>0 for sfx)*/
-
-        uLong size_central_dir;     /* size of the central directory  */
-        uLong offset_central_dir;   /* offset of start of central directory */
-        uLong central_pos,uL;
-
-        uLong number_disk;          /* number of the current dist, used for
-                                    spaning ZIP, unsupported, always 0*/
-        uLong number_disk_with_CD;  /* number the the disk with central dir, used
-                                    for spaning ZIP, unsupported, always 0*/
-        uLong number_entry;
-        uLong number_entry_CD;      /* total number of entries in
-                                    the central dir
-                                    (same than number_entry on nospan) */
-        uLong size_comment;
-
-        central_pos = ziplocal_SearchCentralDir(&ziinit.z_filefunc,ziinit.filestream);
-        if (central_pos==0)
-            err=ZIP_ERRNO;
-
-        if (ZSEEK(ziinit.z_filefunc, ziinit.filestream,
-                                        central_pos,ZLIB_FILEFUNC_SEEK_SET)!=0)
-            err=ZIP_ERRNO;
-
-        /* the signature, already checked */
-        if (ziplocal_getLong(&ziinit.z_filefunc, ziinit.filestream,&uL)!=ZIP_OK)
-            err=ZIP_ERRNO;
-
-        /* number of this disk */
-        if (ziplocal_getShort(&ziinit.z_filefunc, ziinit.filestream,&number_disk)!=ZIP_OK)
-            err=ZIP_ERRNO;
-
-        /* number of the disk with the start of the central directory */
-        if (ziplocal_getShort(&ziinit.z_filefunc, ziinit.filestream,&number_disk_with_CD)!=ZIP_OK)
-            err=ZIP_ERRNO;
-
-        /* total number of entries in the central dir on this disk */
-        if (ziplocal_getShort(&ziinit.z_filefunc, ziinit.filestream,&number_entry)!=ZIP_OK)
-            err=ZIP_ERRNO;
-
-        /* total number of entries in the central dir */
-        if (ziplocal_getShort(&ziinit.z_filefunc, ziinit.filestream,&number_entry_CD)!=ZIP_OK)
-            err=ZIP_ERRNO;
-
-        if ((number_entry_CD!=number_entry) ||
-            (number_disk_with_CD!=0) ||
-            (number_disk!=0))
-            err=ZIP_BADZIPFILE;
-
-        /* size of the central directory */
-        if (ziplocal_getLong(&ziinit.z_filefunc, ziinit.filestream,&size_central_dir)!=ZIP_OK)
-            err=ZIP_ERRNO;
-
-        /* offset of start of central directory with respect to the
-            starting disk number */
-        if (ziplocal_getLong(&ziinit.z_filefunc, ziinit.filestream,&offset_central_dir)!=ZIP_OK)
-            err=ZIP_ERRNO;
-
-        /* zipfile global comment length */
-        if (ziplocal_getShort(&ziinit.z_filefunc, ziinit.filestream,&size_comment)!=ZIP_OK)
-            err=ZIP_ERRNO;
-
-        if ((central_pos<offset_central_dir+size_central_dir) &&
-            (err==ZIP_OK))
-            err=ZIP_BADZIPFILE;
-
-        if (err!=ZIP_OK)
-        {
-            ZCLOSE(ziinit.z_filefunc, ziinit.filestream);
-            return NULL;
-        }
-
-        if (size_comment>0)
-        {
-            ziinit.globalcomment = ALLOC(size_comment+1);
-            if (ziinit.globalcomment)
-            {
-               size_comment = ZREAD(ziinit.z_filefunc, ziinit.filestream,ziinit.globalcomment,size_comment);
-               ziinit.globalcomment[size_comment]=0;
-            }
-        }
-
-        byte_before_the_zipfile = central_pos -
-                                (offset_central_dir+size_central_dir);
-        ziinit.add_position_when_writting_offset = byte_before_the_zipfile;
-
-        {
-            uLong size_central_dir_to_read = size_central_dir;
-            size_t buf_size = SIZEDATA_INDATABLOCK;
-            void* buf_read = (void*)ALLOC(buf_size);
-            if (ZSEEK(ziinit.z_filefunc, ziinit.filestream,
-                  offset_central_dir + byte_before_the_zipfile,
-                  ZLIB_FILEFUNC_SEEK_SET) != 0)
-                  err=ZIP_ERRNO;
-
-            while ((size_central_dir_to_read>0) && (err==ZIP_OK))
-            {
-                uLong read_this = SIZEDATA_INDATABLOCK;
-                if (read_this > size_central_dir_to_read)
-                    read_this = size_central_dir_to_read;
-                if (ZREAD(ziinit.z_filefunc, ziinit.filestream,buf_read,read_this) != read_this)
-                    err=ZIP_ERRNO;
-
-                if (err==ZIP_OK)
-                    err = add_data_in_datablock(&ziinit.central_dir,buf_read,
-                                                (uLong)read_this);
-                size_central_dir_to_read-=read_this;
-            }
-            TRYFREE(buf_read);
-        }
-        ziinit.begin_pos = byte_before_the_zipfile;
-        ziinit.number_entry = number_entry_CD;
-
-        if (ZSEEK(ziinit.z_filefunc, ziinit.filestream,
-                  offset_central_dir+byte_before_the_zipfile,ZLIB_FILEFUNC_SEEK_SET)!=0)
-            err=ZIP_ERRNO;
-    }
-
-    if (globalcomment)
-    {
-      *globalcomment = ziinit.globalcomment;
-    }
-#    endif /* !NO_ADDFILEINEXISTINGZIP*/
-
-    if (err != ZIP_OK)
-    {
-#    ifndef NO_ADDFILEINEXISTINGZIP
-        TRYFREE(ziinit.globalcomment);
-#    endif /* !NO_ADDFILEINEXISTINGZIP*/
-        TRYFREE(zi);
-        return NULL;
-    }
-    else
-    {
-        *zi = ziinit;
-        return (zipFile)zi;
-    }
-}
-
-extern zipFile ZEXPORT zipOpen (file, append)
-    voidpf file;
-    int append;
-{
-    return zipOpen2(file,append,NULL,NULL);
-}
-
-extern int ZEXPORT zipOpenNewFileInZip3 (file, filename, zipfi,
-                                         extrafield_local, size_extrafield_local,
-                                         extrafield_global, size_extrafield_global,
-                                         comment, method, level, raw,
-                                         windowBits, memLevel, strategy,
-                                         password, crcForCrypting)
-    zipFile file;
-    const char* filename;
-    const zip_fileinfo* zipfi;
-    const void* extrafield_local;
-    uInt size_extrafield_local;
-    const void* extrafield_global;
-    uInt size_extrafield_global;
-    const char* comment;
-    int method;
-    int level;
-    int raw;
-    int windowBits;
-    int memLevel;
-    int strategy;
-    const char* password;
-    uLong crcForCrypting;
-{
-    zip_internal* zi;
-    uInt size_filename;
-    uInt size_comment;
-    uInt i;
-    int err = ZIP_OK;
-    uLong version_to_extract;
-
-#    ifdef NOCRYPT
-    if (password != NULL)
-        return ZIP_PARAMERROR;
-#    endif
-
-    if (file == NULL)
-        return ZIP_PARAMERROR;
-    if ((method!=0) && (method!=Z_DEFLATED))
-        return ZIP_PARAMERROR;
-
-    zi = (zip_internal*)file;
-
-    if (zi->in_opened_file_inzip == 1)
-    {
-        err = zipCloseFileInZip (file);
-        if (err != ZIP_OK)
-            return err;
-    }
-
-    if (method == 0
-            && (level == 0 || (zi->flags & ZIP_WRITE_DATA_DESCRIPTOR) == 0))
-    {
-        version_to_extract = 10;
-    }
-    else
-    {
-        version_to_extract = 20;
-    }
-
-
-    if (filename==NULL)
-        filename="-";
-
-    if (comment==NULL)
-        size_comment = 0;
-    else
-        size_comment = (uInt)strlen(comment);
-
-    size_filename = (uInt)strlen(filename);
-
-    if (zipfi == NULL)
-        zi->ci.dosDate = 0;
-    else
-    {
-        if (zipfi->dosDate != 0)
-            zi->ci.dosDate = zipfi->dosDate;
-        else zi->ci.dosDate = ziplocal_TmzDateToDosDate(&zipfi->tmz_date,zipfi->dosDate);
-    }
-
-    zi->ci.flag = 0;
-    if ((level==8) || (level==9))
-      zi->ci.flag |= 2;
-    if ((level==2))
-      zi->ci.flag |= 4;
-    if ((level==1))
-      zi->ci.flag |= 6;
-    if (password != NULL)
-    {
-      zi->ci.flag |= 1;
-    }
-    if (version_to_extract >= 20
-            && (zi->flags & ZIP_WRITE_DATA_DESCRIPTOR) != 0)
-        zi->ci.flag |= 8;
-    zi->ci.crc32 = 0;
-    zi->ci.method = method;
-    zi->ci.encrypt = 0;
-    zi->ci.stream_initialised = 0;
-    zi->ci.pos_in_buffered_data = 0;
-    zi->ci.raw = raw;
-    zi->ci.pos_local_header = ZTELL(zi->z_filefunc,zi->filestream) ;
-    zi->ci.size_centralheader = SIZECENTRALHEADER + size_filename +
-                                      size_extrafield_global + size_comment;
-    zi->ci.central_header = (char*)ALLOC((uInt)zi->ci.size_centralheader);
-
-    ziplocal_putValue_inmemory(zi->ci.central_header,(uLong)CENTRALHEADERMAGIC,4);
-    /* version info */
-    ziplocal_putValue_inmemory(zi->ci.central_header+4,(uLong)VERSIONMADEBY,2);
-    ziplocal_putValue_inmemory(zi->ci.central_header+6,(uLong)version_to_extract,2);
-    ziplocal_putValue_inmemory(zi->ci.central_header+8,(uLong)zi->ci.flag,2);
-    ziplocal_putValue_inmemory(zi->ci.central_header+10,(uLong)zi->ci.method,2);
-    ziplocal_putValue_inmemory(zi->ci.central_header+12,(uLong)zi->ci.dosDate,4);
-    ziplocal_putValue_inmemory(zi->ci.central_header+16,(uLong)0,4); /*crc*/
-    ziplocal_putValue_inmemory(zi->ci.central_header+20,(uLong)0,4); /*compr size*/
-    ziplocal_putValue_inmemory(zi->ci.central_header+24,(uLong)0,4); /*uncompr size*/
-    ziplocal_putValue_inmemory(zi->ci.central_header+28,(uLong)size_filename,2);
-    ziplocal_putValue_inmemory(zi->ci.central_header+30,(uLong)size_extrafield_global,2);
-    ziplocal_putValue_inmemory(zi->ci.central_header+32,(uLong)size_comment,2);
-    ziplocal_putValue_inmemory(zi->ci.central_header+34,(uLong)0,2); /*disk nm start*/
-
-    if (zipfi==NULL)
-        ziplocal_putValue_inmemory(zi->ci.central_header+36,(uLong)0,2);
-    else
-        ziplocal_putValue_inmemory(zi->ci.central_header+36,(uLong)zipfi->internal_fa,2);
-
-    if (zipfi==NULL)
-        ziplocal_putValue_inmemory(zi->ci.central_header+38,(uLong)0,4);
-    else
-        ziplocal_putValue_inmemory(zi->ci.central_header+38,(uLong)zipfi->external_fa,4);
-
-    ziplocal_putValue_inmemory(zi->ci.central_header+42,(uLong)zi->ci.pos_local_header- zi->add_position_when_writting_offset,4);
-
-    for (i=0;i<size_filename;i++)
-        *(zi->ci.central_header+SIZECENTRALHEADER+i) = *(filename+i);
-
-    for (i=0;i<size_extrafield_global;i++)
-        *(zi->ci.central_header+SIZECENTRALHEADER+size_filename+i) =
-              *(((const char*)extrafield_global)+i);
-
-    for (i=0;i<size_comment;i++)
-        *(zi->ci.central_header+SIZECENTRALHEADER+size_filename+
-              size_extrafield_global+i) = *(comment+i);
-    if (zi->ci.central_header == NULL)
-        return ZIP_INTERNALERROR;
-
-    /* write the local header */
-    err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)LOCALHEADERMAGIC,4);
-
-    if (err==ZIP_OK)
-        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)version_to_extract,2);
-    if (err==ZIP_OK)
-        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->ci.flag,2);
-
-    if (err==ZIP_OK)
-        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->ci.method,2);
-
-    if (err==ZIP_OK)
-        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->ci.dosDate,4);
-
-    if (err==ZIP_OK)
-        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4); /* crc 32, unknown */
-    if (err==ZIP_OK)
-        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4); /* compressed size, unknown */
-    if (err==ZIP_OK)
-        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4); /* uncompressed size, unknown */
-
-    if (err==ZIP_OK)
-        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_filename,2);
-
-    if (err==ZIP_OK)
-        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_extrafield_local,2);
-
-    if ((err==ZIP_OK) && (size_filename>0))
-        if (ZWRITE(zi->z_filefunc,zi->filestream,filename,size_filename)!=size_filename)
-                err = ZIP_ERRNO;
-
-    if ((err==ZIP_OK) && (size_extrafield_local>0))
-        if (ZWRITE(zi->z_filefunc,zi->filestream,extrafield_local,size_extrafield_local)
-                                                                           !=size_extrafield_local)
-                err = ZIP_ERRNO;
-
-    zi->ci.stream.avail_in = (uInt)0;
-    zi->ci.stream.avail_out = (uInt)Z_BUFSIZE;
-    zi->ci.stream.next_out = zi->ci.buffered_data;
-    zi->ci.stream.total_in = 0;
-    zi->ci.stream.total_out = 0;
-
-    if ((err==ZIP_OK) && (zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))
-    {
-        zi->ci.stream.zalloc = (alloc_func)0;
-        zi->ci.stream.zfree = (free_func)0;
-        zi->ci.stream.opaque = (voidpf)0;
-
-        if (windowBits>0)
-            windowBits = -windowBits;
-
-        err = deflateInit2(&zi->ci.stream, level,
-               Z_DEFLATED, windowBits, memLevel, strategy);
-
-        if (err==Z_OK)
-            zi->ci.stream_initialised = 1;
-    }
-#    ifndef NOCRYPT
-    zi->ci.crypt_header_size = 0;
-    if ((err==Z_OK) && (password != NULL))
-    {
-        unsigned char bufHead[RAND_HEAD_LEN];
-        unsigned int sizeHead;
-        zi->ci.encrypt = 1;
-        zi->ci.pcrc_32_tab = get_crc_table();
-        /*init_keys(password,zi->ci.keys,zi->ci.pcrc_32_tab);*/
-
-        crcForCrypting = (uLong)zi->ci.dosDate << 16; // ATTANTION! Without this row, you don't unpack your password protected archive in other app.
-
-        sizeHead=crypthead(password,bufHead,RAND_HEAD_LEN,zi->ci.keys,zi->ci.pcrc_32_tab,crcForCrypting);
-        zi->ci.crypt_header_size = sizeHead;
-
-        if (ZWRITE(zi->z_filefunc,zi->filestream,bufHead,sizeHead) != sizeHead)
-                err = ZIP_ERRNO;
-    }
-#    endif
-
-    if (err==Z_OK)
-        zi->in_opened_file_inzip = 1;
-    return err;
-}
-
-extern int ZEXPORT zipOpenNewFileInZip2(file, filename, zipfi,
-                                        extrafield_local, size_extrafield_local,
-                                        extrafield_global, size_extrafield_global,
-                                        comment, method, level, raw)
-    zipFile file;
-    const char* filename;
-    const zip_fileinfo* zipfi;
-    const void* extrafield_local;
-    uInt size_extrafield_local;
-    const void* extrafield_global;
-    uInt size_extrafield_global;
-    const char* comment;
-    int method;
-    int level;
-    int raw;
-{
-    return zipOpenNewFileInZip3 (file, filename, zipfi,
-                                 extrafield_local, size_extrafield_local,
-                                 extrafield_global, size_extrafield_global,
-                                 comment, method, level, raw,
-                                 -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,
-                                 NULL, 0);
-}
-
-extern int ZEXPORT zipOpenNewFileInZip (file, filename, zipfi,
-                                        extrafield_local, size_extrafield_local,
-                                        extrafield_global, size_extrafield_global,
-                                        comment, method, level)
-    zipFile file;
-    const char* filename;
-    const zip_fileinfo* zipfi;
-    const void* extrafield_local;
-    uInt size_extrafield_local;
-    const void* extrafield_global;
-    uInt size_extrafield_global;
-    const char* comment;
-    int method;
-    int level;
-{
-    return zipOpenNewFileInZip2 (file, filename, zipfi,
-                                 extrafield_local, size_extrafield_local,
-                                 extrafield_global, size_extrafield_global,
-                                 comment, method, level, 0);
-}
-
-local int zipFlushWriteBuffer(zi)
-  zip_internal* zi;
-{
-    int err=ZIP_OK;
-
-    if (zi->ci.encrypt != 0)
-    {
-#ifndef NOCRYPT
-        uInt i;
-        int t;
-        for (i=0;i<zi->ci.pos_in_buffered_data;i++)
-            zi->ci.buffered_data[i] = zencode(zi->ci.keys, zi->ci.pcrc_32_tab,
-                                       zi->ci.buffered_data[i],t);
-#endif
-    }
-    if (ZWRITE(zi->z_filefunc,zi->filestream,zi->ci.buffered_data,zi->ci.pos_in_buffered_data)
-                                                                    !=zi->ci.pos_in_buffered_data)
-      err = ZIP_ERRNO;
-    zi->ci.pos_in_buffered_data = 0;
-    return err;
-}
-
-extern int ZEXPORT zipWriteInFileInZip (file, buf, len)
-    zipFile file;
-    const void* buf;
-    unsigned len;
-{
-    zip_internal* zi;
-    int err=ZIP_OK;
-
-    if (file == NULL)
-        return ZIP_PARAMERROR;
-    zi = (zip_internal*)file;
-
-    if (zi->in_opened_file_inzip == 0)
-        return ZIP_PARAMERROR;
-
-    zi->ci.stream.next_in = (void*)buf;
-    zi->ci.stream.avail_in = len;
-    zi->ci.crc32 = crc32(zi->ci.crc32,buf,len);
-
-    while ((err==ZIP_OK) && (zi->ci.stream.avail_in>0))
-    {
-        if (zi->ci.stream.avail_out == 0)
-        {
-            if (zipFlushWriteBuffer(zi) == ZIP_ERRNO)
-                err = ZIP_ERRNO;
-            zi->ci.stream.avail_out = (uInt)Z_BUFSIZE;
-            zi->ci.stream.next_out = zi->ci.buffered_data;
-        }
-
-
-        if(err != ZIP_OK)
-            break;
-
-        if ((zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))
-        {
-            uLong uTotalOutBefore = zi->ci.stream.total_out;
-            err=deflate(&zi->ci.stream,  Z_NO_FLUSH);
-            zi->ci.pos_in_buffered_data += (uInt)(zi->ci.stream.total_out - uTotalOutBefore) ;
-
-        }
-        else
-        {
-            uInt copy_this,i;
-            if (zi->ci.stream.avail_in < zi->ci.stream.avail_out)
-                copy_this = zi->ci.stream.avail_in;
-            else
-                copy_this = zi->ci.stream.avail_out;
-            for (i=0;i<copy_this;i++)
-                *(((char*)zi->ci.stream.next_out)+i) =
-                    *(((const char*)zi->ci.stream.next_in)+i);
-            {
-                zi->ci.stream.avail_in -= copy_this;
-                zi->ci.stream.avail_out-= copy_this;
-                zi->ci.stream.next_in+= copy_this;
-                zi->ci.stream.next_out+= copy_this;
-                zi->ci.stream.total_in+= copy_this;
-                zi->ci.stream.total_out+= copy_this;
-                zi->ci.pos_in_buffered_data += copy_this;
-            }
-        }
-    }
-
-    return err;
-}
-
-extern int ZEXPORT zipCloseFileInZipRaw (file, uncompressed_size, crc32)
-    zipFile file;
-    uLong uncompressed_size;
-    uLong crc32;
-{
-    zip_internal* zi;
-    uLong compressed_size;
-    int err=ZIP_OK;
-
-    if (file == NULL)
-        return ZIP_PARAMERROR;
-    zi = (zip_internal*)file;
-
-    if (zi->in_opened_file_inzip == 0)
-        return ZIP_PARAMERROR;
-    zi->ci.stream.avail_in = 0;
-
-    if ((zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))
-        while (err==ZIP_OK)
-    {
-        uLong uTotalOutBefore;
-        if (zi->ci.stream.avail_out == 0)
-        {
-            if (zipFlushWriteBuffer(zi) == ZIP_ERRNO)
-                err = ZIP_ERRNO;
-            zi->ci.stream.avail_out = (uInt)Z_BUFSIZE;
-            zi->ci.stream.next_out = zi->ci.buffered_data;
-        }
-        uTotalOutBefore = zi->ci.stream.total_out;
-        err=deflate(&zi->ci.stream,  Z_FINISH);
-        zi->ci.pos_in_buffered_data += (uInt)(zi->ci.stream.total_out - uTotalOutBefore) ;
-    }
-
-    if (err==Z_STREAM_END)
-        err=ZIP_OK; /* this is normal */
-
-    if ((zi->ci.pos_in_buffered_data>0) && (err==ZIP_OK))
-        if (zipFlushWriteBuffer(zi)==ZIP_ERRNO)
-            err = ZIP_ERRNO;
-
-    if ((zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))
-    {
-        err=deflateEnd(&zi->ci.stream);
-        zi->ci.stream_initialised = 0;
-    }
-
-    if (!zi->ci.raw)
-    {
-        crc32 = (uLong)zi->ci.crc32;
-        uncompressed_size = (uLong)zi->ci.stream.total_in;
-    }
-    compressed_size = (uLong)zi->ci.stream.total_out;
-#    ifndef NOCRYPT
-    compressed_size += zi->ci.crypt_header_size;
-#    endif
-
-    ziplocal_putValue_inmemory(zi->ci.central_header+16,crc32,4); /*crc*/
-    ziplocal_putValue_inmemory(zi->ci.central_header+20,
-                                compressed_size,4); /*compr size*/
-    if (zi->ci.stream.data_type == Z_ASCII)
-        ziplocal_putValue_inmemory(zi->ci.central_header+36,(uLong)Z_ASCII,2);
-    ziplocal_putValue_inmemory(zi->ci.central_header+24,
-                                uncompressed_size,4); /*uncompr size*/
-
-    if (err==ZIP_OK)
-        err = add_data_in_datablock(&zi->central_dir,zi->ci.central_header,
-                                       (uLong)zi->ci.size_centralheader);
-    free(zi->ci.central_header);
-
-    if (err==ZIP_OK)
-    {
-        uLong cur_pos_inzip = ZTELL(zi->z_filefunc,zi->filestream);
-        if (ZSEEK(zi->z_filefunc,zi->filestream,
-                  zi->ci.pos_local_header + 14,ZLIB_FILEFUNC_SEEK_SET)!=0)
-            err = ZIP_ERRNO;
-
-        if (err==ZIP_OK)
-            err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,crc32,4); /* crc 32, unknown */
-
-        if (err==ZIP_OK) /* compressed size, unknown */
-            err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,compressed_size,4);
-
-        if (err==ZIP_OK) /* uncompressed size, unknown */
-            err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,uncompressed_size,4);
-
-        if (ZSEEK(zi->z_filefunc,zi->filestream,
-                  cur_pos_inzip,ZLIB_FILEFUNC_SEEK_SET)!=0)
-            err = ZIP_ERRNO;
-
-        if ((zi->ci.flag & 8) != 0) {
-            /* Write local Descriptor after file data */
-            if (err==ZIP_OK)
-                err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)DESCRIPTORHEADERMAGIC,4);
-
-            if (err==ZIP_OK)
-                err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,crc32,4); /* crc 32, unknown */
-
-            if (err==ZIP_OK) /* compressed size, unknown */
-                err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,compressed_size,4);
-
-            if (err==ZIP_OK) /* uncompressed size, unknown */
-                err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,uncompressed_size,4);
-        }
-
-
-    }
-
-    zi->number_entry ++;
-    zi->in_opened_file_inzip = 0;
-
-    return err;
-}
-
-extern int ZEXPORT zipCloseFileInZip (file)
-    zipFile file;
-{
-    return zipCloseFileInZipRaw (file,0,0);
-}
-
-extern int ZEXPORT zipClose (file, global_comment)
-    zipFile file;
-    const char* global_comment;
-{
-    zip_internal* zi;
-    int err = 0;
-    uLong size_centraldir = 0;
-    uLong centraldir_pos_inzip;
-    uInt size_global_comment;
-    if (file == NULL)
-        return ZIP_PARAMERROR;
-    zi = (zip_internal*)file;
-
-    if (zi->in_opened_file_inzip == 1)
-    {
-        err = zipCloseFileInZip (file);
-    }
-
-#ifndef NO_ADDFILEINEXISTINGZIP
-    if (global_comment==NULL)
-        global_comment = zi->globalcomment;
-#endif
-    if (global_comment==NULL)
-        size_global_comment = 0;
-    else
-        size_global_comment = (uInt)strlen(global_comment);
-
-    centraldir_pos_inzip = ZTELL(zi->z_filefunc,zi->filestream);
-    if (err==ZIP_OK)
-    {
-        linkedlist_datablock_internal* ldi = zi->central_dir.first_block ;
-        while (ldi!=NULL)
-        {
-            if ((err==ZIP_OK) && (ldi->filled_in_this_block>0))
-                if (ZWRITE(zi->z_filefunc,zi->filestream,
-                           ldi->data,ldi->filled_in_this_block)
-                              !=ldi->filled_in_this_block )
-                    err = ZIP_ERRNO;
-
-            size_centraldir += ldi->filled_in_this_block;
-            ldi = ldi->next_datablock;
-        }
-    }
-    free_datablock(zi->central_dir.first_block);
-
-    if (err==ZIP_OK) /* Magic End */
-        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)ENDHEADERMAGIC,4);
-
-    if (err==ZIP_OK) /* number of this disk */
-        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,2);
-
-    if (err==ZIP_OK) /* number of the disk with the start of the central directory */
-        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,2);
-
-    if (err==ZIP_OK) /* total number of entries in the central dir on this disk */
-        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->number_entry,2);
-
-    if (err==ZIP_OK) /* total number of entries in the central dir */
-        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->number_entry,2);
-
-    if (err==ZIP_OK) /* size of the central directory */
-        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_centraldir,4);
-
-    if (err==ZIP_OK) /* offset of start of central directory with respect to the
-                            starting disk number */
-        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,
-                                (uLong)(centraldir_pos_inzip - zi->add_position_when_writting_offset),4);
-
-    if (err==ZIP_OK) /* zipfile comment length */
-        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_global_comment,2);
-
-    if ((err==ZIP_OK) && (size_global_comment>0))
-        if (ZWRITE(zi->z_filefunc,zi->filestream,
-                   global_comment,size_global_comment) != size_global_comment)
-                err = ZIP_ERRNO;
-
-    if (ZCLOSE(zi->z_filefunc,zi->filestream) != 0)
-        if (err == ZIP_OK)
-            err = ZIP_ERRNO;
-
-#ifndef NO_ADDFILEINEXISTINGZIP
-    TRYFREE(zi->globalcomment);
-#endif
-    TRYFREE(zi);
-
-    return err;
-}
-
-extern int ZEXPORT zipSetFlags(zipFile file, unsigned flags)
-{
-    zip_internal* zi;
-    if (file == NULL)
-        return ZIP_PARAMERROR;
-    zi = (zip_internal*)file;
-    zi->flags |= flags;
-    return ZIP_OK;
-}
-
-extern int ZEXPORT zipClearFlags(zipFile file, unsigned flags)
-{
-    zip_internal* zi;
-    if (file == NULL)
-        return ZIP_PARAMERROR;
-    zi = (zip_internal*)file;
-    zi->flags &= ~flags;
-    return ZIP_OK;
-}
+/* zip.c -- IO on .zip files using zlib
+   Version 1.1, February 14h, 2010
+   part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )
+
+         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )
+
+         Modifications for Zip64 support
+         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )
+
+         For more info read MiniZip_info.txt
+
+         Modifications for QIODevice support and other QuaZip fixes
+         Copyright (C) 2005-2014 Sergey A. Tachenov
+
+         Fixing static code analysis issues
+         Copyright (C) 2016 Intel Deutschland GmbH
+
+         Changes
+   Oct-2009 - Mathias Svensson - Remove old C style function prototypes
+   Oct-2009 - Mathias Svensson - Added Zip64 Support when creating new file archives
+   Oct-2009 - Mathias Svensson - Did some code cleanup and refactoring to get better overview of some functions.
+   Oct-2009 - Mathias Svensson - Added zipRemoveExtraInfoBlock to strip extra field data from its ZIP64 data
+                                 It is used when recreting zip archive with RAW when deleting items from a zip.
+                                 ZIP64 data is automaticly added to items that needs it, and existing ZIP64 data need to be removed.
+   Oct-2009 - Mathias Svensson - Added support for BZIP2 as compression mode (bzip2 lib is required)
+   Jan-2010 - back to unzip and minizip 1.0 name scheme, with compatibility layer
+
+*/
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+
+#include <zlib.h>
+#if (ZLIB_VERNUM < 0x1270)
+typedef uLongf z_crc_t;
+#endif
+#include "zip.h"
+
+#ifdef STDC
+#  include <stddef.h>
+#  include <string.h>
+#  include <stdlib.h>
+#endif
+#ifdef NO_ERRNO_H
+    extern int errno;
+#else
+#   include <errno.h>
+#endif
+
+
+#ifndef local
+#  define local static
+#endif
+/* compile with -Dlocal if your debugger can't find static symbols */
+
+#ifndef VERSIONMADEBY
+# define VERSIONMADEBY   (0x031e) /* best for standard pkware crypt */
+#endif
+
+#ifndef Z_BUFSIZE
+#define Z_BUFSIZE (64*1024) /* (16384) */
+#endif
+
+#ifndef Z_MAXFILENAMEINZIP
+#define Z_MAXFILENAMEINZIP (256)
+#endif
+
+#ifndef ALLOC
+# define ALLOC(size) (malloc(size))
+#endif
+#ifndef TRYFREE
+# define TRYFREE(p) {if (p) free(p);}
+#endif
+
+/*
+#define SIZECENTRALDIRITEM (0x2e)
+#define SIZEZIPLOCALHEADER (0x1e)
+*/
+
+/* I've found an old Unix (a SunOS 4.1.3_U1) without all SEEK_* defined.... */
+
+
+/* NOT sure that this work on ALL platform */
+#define MAKEULONG64(a, b) ((ZPOS64_T)(((unsigned long)(a)) | ((ZPOS64_T)((unsigned long)(b))) << 32))
+
+#ifndef SEEK_CUR
+#define SEEK_CUR    1
+#endif
+
+#ifndef SEEK_END
+#define SEEK_END    2
+#endif
+
+#ifndef SEEK_SET
+#define SEEK_SET    0
+#endif
+
+#ifndef DEF_MEM_LEVEL
+#if MAX_MEM_LEVEL >= 8
+#  define DEF_MEM_LEVEL 8
+#else
+#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
+#endif
+#endif
+const char zip_copyright[] =" zip 1.01 Copyright 1998-2004 Gilles Vollant - http://www.winimage.com/zLibDll";
+
+
+#define SIZEDATA_INDATABLOCK (4096-(4*4))
+
+#define LOCALHEADERMAGIC    (0x04034b50)
+#define DESCRIPTORHEADERMAGIC    (0x08074b50)
+#define CENTRALHEADERMAGIC  (0x02014b50)
+#define ENDHEADERMAGIC      (0x06054b50)
+#define ZIP64ENDHEADERMAGIC      (0x6064b50)
+#define ZIP64ENDLOCHEADERMAGIC   (0x7064b50)
+
+#define FLAG_LOCALHEADER_OFFSET (0x06)
+#define CRC_LOCALHEADER_OFFSET  (0x0e)
+
+#define SIZECENTRALHEADER (0x2e) /* 46 */
+
+typedef struct linkedlist_datablock_internal_s
+{
+  struct linkedlist_datablock_internal_s* next_datablock;
+  uLong  avail_in_this_block;
+  uLong  filled_in_this_block;
+  uLong  unused; /* for future use and alignement */
+  unsigned char data[SIZEDATA_INDATABLOCK];
+} linkedlist_datablock_internal;
+
+typedef struct linkedlist_data_s
+{
+    linkedlist_datablock_internal* first_block;
+    linkedlist_datablock_internal* last_block;
+} linkedlist_data;
+
+
+typedef struct
+{
+    z_stream stream;            /* zLib stream structure for inflate */
+#ifdef HAVE_BZIP2
+    bz_stream bstream;          /* bzLib stream structure for bziped */
+#endif
+
+    int  stream_initialised;    /* 1 is stream is initialised */
+    uInt pos_in_buffered_data;  /* last written byte in buffered_data */
+
+    ZPOS64_T pos_local_header;     /* offset of the local header of the file
+                                     currenty writing */
+    char* central_header;       /* central header data for the current file */
+    uLong size_centralExtra;
+    uLong size_centralheader;   /* size of the central header for cur file */
+    uLong size_centralExtraFree; /* Extra bytes allocated to the centralheader but that are not used */
+    uLong flag;                 /* flag of the file currently writing */
+
+    int  method;                /* compression method of file currenty wr.*/
+    int  raw;                   /* 1 for directly writing raw data */
+    Byte buffered_data[Z_BUFSIZE];/* buffer contain compressed data to be writ*/
+    uLong dosDate;
+    uLong crc32;
+    int  encrypt;
+    int  zip64;               /* Add ZIP64 extened information in the extra field */
+    ZPOS64_T pos_zip64extrainfo;
+    ZPOS64_T totalCompressedData;
+    ZPOS64_T totalUncompressedData;
+#ifndef NOCRYPT
+    unsigned long keys[3];     /* keys defining the pseudo-random sequence */
+    const z_crc_t FAR * pcrc_32_tab;
+    int crypt_header_size;
+#endif
+} curfile64_info;
+
+typedef struct
+{
+    zlib_filefunc64_32_def z_filefunc;
+    voidpf filestream;        /* io structore of the zipfile */
+    linkedlist_data central_dir;/* datablock with central dir in construction*/
+    int  in_opened_file_inzip;  /* 1 if a file in the zip is currently writ.*/
+    curfile64_info ci;            /* info on the file curretly writing */
+
+    ZPOS64_T begin_pos;            /* position of the beginning of the zipfile */
+    ZPOS64_T add_position_when_writting_offset;
+    ZPOS64_T number_entry;
+
+#ifndef NO_ADDFILEINEXISTINGZIP
+    char *globalcomment;
+#endif
+
+    unsigned flags;
+
+} zip64_internal;
+
+
+#ifndef NOCRYPT
+#define INCLUDECRYPTINGCODE_IFCRYPTALLOWED
+#include "minizip_crypt.h"
+#endif
+
+local linkedlist_datablock_internal* allocate_new_datablock()
+{
+    linkedlist_datablock_internal* ldi;
+    ldi = (linkedlist_datablock_internal*)
+                 ALLOC(sizeof(linkedlist_datablock_internal));
+    if (ldi!=NULL)
+    {
+        ldi->next_datablock = NULL ;
+        ldi->filled_in_this_block = 0 ;
+        ldi->avail_in_this_block = SIZEDATA_INDATABLOCK ;
+    }
+    return ldi;
+}
+
+local void free_datablock(linkedlist_datablock_internal* ldi)
+{
+    while (ldi!=NULL)
+    {
+        linkedlist_datablock_internal* ldinext = ldi->next_datablock;
+        TRYFREE(ldi);
+        ldi = ldinext;
+    }
+}
+
+local void init_linkedlist(linkedlist_data* ll)
+{
+    ll->first_block = ll->last_block = NULL;
+}
+
+local void free_linkedlist(linkedlist_data* ll)
+{
+    free_datablock(ll->first_block);
+    ll->first_block = ll->last_block = NULL;
+}
+
+
+local int add_data_in_datablock(linkedlist_data* ll, const void* buf, uLong len)
+{
+    linkedlist_datablock_internal* ldi;
+    const unsigned char* from_copy;
+
+    if (ll==NULL)
+        return ZIP_INTERNALERROR;
+
+    if (ll->last_block == NULL)
+    {
+        ll->first_block = ll->last_block = allocate_new_datablock();
+        if (ll->first_block == NULL)
+            return ZIP_INTERNALERROR;
+    }
+
+    ldi = ll->last_block;
+    from_copy = (unsigned char*)buf;
+
+    while (len>0)
+    {
+        uInt copy_this;
+        uInt i;
+        unsigned char* to_copy;
+
+        if (ldi->avail_in_this_block==0)
+        {
+            ldi->next_datablock = allocate_new_datablock();
+            if (ldi->next_datablock == NULL)
+                return ZIP_INTERNALERROR;
+            ldi = ldi->next_datablock ;
+            ll->last_block = ldi;
+        }
+
+        if (ldi->avail_in_this_block < len)
+            copy_this = (uInt)ldi->avail_in_this_block;
+        else
+            copy_this = (uInt)len;
+
+        to_copy = &(ldi->data[ldi->filled_in_this_block]);
+
+        for (i=0;i<copy_this;i++)
+            *(to_copy+i)=*(from_copy+i);
+
+        ldi->filled_in_this_block += copy_this;
+        ldi->avail_in_this_block -= copy_this;
+        from_copy += copy_this ;
+        len -= copy_this;
+    }
+    return ZIP_OK;
+}
+
+
+
+/****************************************************************************/
+
+#ifndef NO_ADDFILEINEXISTINGZIP
+/* ===========================================================================
+   Inputs a long in LSB order to the given file
+   nbByte == 1, 2 ,4 or 8 (byte, short or long, ZPOS64_T)
+*/
+
+local int zip64local_putValue OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, ZPOS64_T x, int nbByte));
+local int zip64local_putValue (const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, ZPOS64_T x, int nbByte)
+{
+    unsigned char buf[8];
+    int n;
+    for (n = 0; n < nbByte; n++)
+    {
+        buf[n] = (unsigned char)(x & 0xff);
+        x >>= 8;
+    }
+    if (x != 0)
+      {     /* data overflow - hack for ZIP64 (X Roche) */
+      for (n = 0; n < nbByte; n++)
+        {
+          buf[n] = 0xff;
+        }
+      }
+
+    if (ZWRITE64(*pzlib_filefunc_def,filestream,buf,nbByte)!=(uLong)nbByte)
+        return ZIP_ERRNO;
+    else
+        return ZIP_OK;
+}
+
+local void zip64local_putValue_inmemory OF((void* dest, ZPOS64_T x, int nbByte));
+local void zip64local_putValue_inmemory (void* dest, ZPOS64_T x, int nbByte)
+{
+    unsigned char* buf=(unsigned char*)dest;
+    int n;
+    for (n = 0; n < nbByte; n++) {
+        buf[n] = (unsigned char)(x & 0xff);
+        x >>= 8;
+    }
+
+    if (x != 0)
+    {     /* data overflow - hack for ZIP64 */
+       for (n = 0; n < nbByte; n++)
+       {
+          buf[n] = 0xff;
+       }
+    }
+}
+
+/****************************************************************************/
+
+
+local uLong zip64local_TmzDateToDosDate(const tm_zip* ptm)
+{
+    uLong year = (uLong)ptm->tm_year;
+    if (year>=1980)
+        year-=1980;
+    else if (year>=80)
+        year-=80;
+    return
+      (uLong) (((ptm->tm_mday) + (32 * (ptm->tm_mon+1)) + (512 * year)) << 16) |
+        ((ptm->tm_sec/2) + (32* ptm->tm_min) + (2048 * (uLong)ptm->tm_hour));
+}
+
+
+/****************************************************************************/
+
+local int zip64local_getByte OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, int *pi));
+
+local int zip64local_getByte(const zlib_filefunc64_32_def* pzlib_filefunc_def,voidpf filestream,int* pi)
+{
+    unsigned char c;
+    int err = (int)ZREAD64(*pzlib_filefunc_def,filestream,&c,1);
+    if (err==1)
+    {
+        *pi = (int)c;
+        return ZIP_OK;
+    }
+    else
+    {
+        if (ZERROR64(*pzlib_filefunc_def,filestream))
+            return ZIP_ERRNO;
+        else
+            return ZIP_EOF;
+    }
+}
+
+
+/* ===========================================================================
+   Reads a long in LSB order from the given gz_stream. Sets
+*/
+local int zip64local_getShort OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, uLong *pX));
+
+local int zip64local_getShort (const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, uLong* pX)
+{
+    uLong x ;
+    int i = 0;
+    int err;
+
+    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);
+    x = (uLong)i;
+
+    if (err==ZIP_OK)
+        err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);
+    x += ((uLong)i)<<8;
+
+    if (err==ZIP_OK)
+        *pX = x;
+    else
+        *pX = 0;
+    return err;
+}
+
+local int zip64local_getLong OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, uLong *pX));
+
+local int zip64local_getLong (const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, uLong* pX)
+{
+    uLong x ;
+    int i = 0;
+    int err;
+
+    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);
+    x = (uLong)i;
+
+    if (err==ZIP_OK)
+        err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);
+    x += ((uLong)i)<<8;
+
+    if (err==ZIP_OK)
+        err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);
+    x += ((uLong)i)<<16;
+
+    if (err==ZIP_OK)
+        err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);
+    x += ((uLong)i)<<24;
+
+    if (err==ZIP_OK)
+        *pX = x;
+    else
+        *pX = 0;
+    return err;
+}
+
+local int zip64local_getLong64 OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, ZPOS64_T *pX));
+
+
+local int zip64local_getLong64 (const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, ZPOS64_T *pX)
+{
+  ZPOS64_T x;
+  int i = 0;
+  int err;
+
+  err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);
+  x = (ZPOS64_T)i;
+
+  if (err==ZIP_OK)
+    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);
+  x += ((ZPOS64_T)i)<<8;
+
+  if (err==ZIP_OK)
+    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);
+  x += ((ZPOS64_T)i)<<16;
+
+  if (err==ZIP_OK)
+    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);
+  x += ((ZPOS64_T)i)<<24;
+
+  if (err==ZIP_OK)
+    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);
+  x += ((ZPOS64_T)i)<<32;
+
+  if (err==ZIP_OK)
+    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);
+  x += ((ZPOS64_T)i)<<40;
+
+  if (err==ZIP_OK)
+    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);
+  x += ((ZPOS64_T)i)<<48;
+
+  if (err==ZIP_OK)
+    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);
+  x += ((ZPOS64_T)i)<<56;
+
+  if (err==ZIP_OK)
+    *pX = x;
+  else
+    *pX = 0;
+
+  return err;
+}
+
+#ifndef BUFREADCOMMENT
+#define BUFREADCOMMENT (0x400)
+#endif
+/*
+  Locate the Central directory of a zipfile (at the end, just before
+    the global comment)
+*/
+local ZPOS64_T zip64local_SearchCentralDir OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream));
+
+local ZPOS64_T zip64local_SearchCentralDir(const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream)
+{
+  unsigned char* buf;
+  ZPOS64_T uSizeFile;
+  ZPOS64_T uBackRead;
+  ZPOS64_T uMaxBack=0xffff; /* maximum size of global comment */
+  ZPOS64_T uPosFound=0;
+
+  if (ZSEEK64(*pzlib_filefunc_def,filestream,0,ZLIB_FILEFUNC_SEEK_END) != 0)
+    return 0;
+
+
+  uSizeFile = ZTELL64(*pzlib_filefunc_def,filestream);
+
+  if (uMaxBack>uSizeFile)
+    uMaxBack = uSizeFile;
+
+  buf = (unsigned char*)ALLOC(BUFREADCOMMENT+4);
+  if (buf==NULL)
+    return 0;
+
+  uBackRead = 4;
+  while (uBackRead<uMaxBack)
+  {
+    uLong uReadSize;
+    ZPOS64_T uReadPos ;
+    int i;
+    if (uBackRead+BUFREADCOMMENT>uMaxBack)
+      uBackRead = uMaxBack;
+    else
+      uBackRead+=BUFREADCOMMENT;
+    uReadPos = uSizeFile-uBackRead ;
+
+    uReadSize = ((BUFREADCOMMENT+4) < (uSizeFile-uReadPos)) ?
+      (BUFREADCOMMENT+4) : (uLong)(uSizeFile-uReadPos);
+    if (ZSEEK64(*pzlib_filefunc_def,filestream,uReadPos,ZLIB_FILEFUNC_SEEK_SET)!=0)
+      break;
+
+    if (ZREAD64(*pzlib_filefunc_def,filestream,buf,uReadSize)!=uReadSize)
+      break;
+
+    for (i=(int)uReadSize-3; (i--)>0;){
+      if (((*(buf+i))==0x50) && ((*(buf+i+1))==0x4b) &&
+        ((*(buf+i+2))==0x05) && ((*(buf+i+3))==0x06))
+      {
+        uPosFound = uReadPos+i;
+        break;
+      }
+    }
+
+      if (uPosFound!=0)
+        break;
+  }
+  TRYFREE(buf);
+  return uPosFound;
+}
+
+/*
+Locate the End of Zip64 Central directory locator and from there find the CD of a zipfile (at the end, just before
+the global comment)
+*/
+local ZPOS64_T zip64local_SearchCentralDir64 OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream));
+
+local ZPOS64_T zip64local_SearchCentralDir64(const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream)
+{
+  unsigned char* buf;
+  ZPOS64_T uSizeFile;
+  ZPOS64_T uBackRead;
+  ZPOS64_T uMaxBack=0xffff; /* maximum size of global comment */
+  ZPOS64_T uPosFound=0;
+  uLong uL;
+  ZPOS64_T relativeOffset;
+
+  if (ZSEEK64(*pzlib_filefunc_def,filestream,0,ZLIB_FILEFUNC_SEEK_END) != 0)
+    return 0;
+
+  uSizeFile = ZTELL64(*pzlib_filefunc_def,filestream);
+
+  if (uMaxBack>uSizeFile)
+    uMaxBack = uSizeFile;
+
+  buf = (unsigned char*)ALLOC(BUFREADCOMMENT+4);
+  if (buf==NULL)
+    return 0;
+
+  uBackRead = 4;
+  while (uBackRead<uMaxBack)
+  {
+    uLong uReadSize;
+    ZPOS64_T uReadPos;
+    int i;
+    if (uBackRead+BUFREADCOMMENT>uMaxBack)
+      uBackRead = uMaxBack;
+    else
+      uBackRead+=BUFREADCOMMENT;
+    uReadPos = uSizeFile-uBackRead ;
+
+    uReadSize = ((BUFREADCOMMENT+4) < (uSizeFile-uReadPos)) ?
+      (BUFREADCOMMENT+4) : (uLong)(uSizeFile-uReadPos);
+    if (ZSEEK64(*pzlib_filefunc_def,filestream,uReadPos,ZLIB_FILEFUNC_SEEK_SET)!=0)
+      break;
+
+    if (ZREAD64(*pzlib_filefunc_def,filestream,buf,uReadSize)!=uReadSize)
+      break;
+
+    for (i=(int)uReadSize-3; (i--)>0;)
+    {
+      /* Signature "0x07064b50" Zip64 end of central directory locater */
+      if (((*(buf+i))==0x50) && ((*(buf+i+1))==0x4b) && ((*(buf+i+2))==0x06) && ((*(buf+i+3))==0x07))
+      {
+        uPosFound = uReadPos+i;
+        break;
+      }
+    }
+
+      if (uPosFound!=0)
+        break;
+  }
+
+  TRYFREE(buf);
+  if (uPosFound == 0)
+    return 0;
+
+  /* Zip64 end of central directory locator */
+  if (ZSEEK64(*pzlib_filefunc_def,filestream, uPosFound,ZLIB_FILEFUNC_SEEK_SET)!=0)
+    return 0;
+
+  /* the signature, already checked */
+  if (zip64local_getLong(pzlib_filefunc_def,filestream,&uL)!=ZIP_OK)
+    return 0;
+
+  /* number of the disk with the start of the zip64 end of  central directory */
+  if (zip64local_getLong(pzlib_filefunc_def,filestream,&uL)!=ZIP_OK)
+    return 0;
+  if (uL != 0)
+    return 0;
+
+  /* relative offset of the zip64 end of central directory record */
+  if (zip64local_getLong64(pzlib_filefunc_def,filestream,&relativeOffset)!=ZIP_OK)
+    return 0;
+
+  /* total number of disks */
+  if (zip64local_getLong(pzlib_filefunc_def,filestream,&uL)!=ZIP_OK)
+    return 0;
+  if (uL != 1)
+    return 0;
+
+  /* Goto Zip64 end of central directory record */
+  if (ZSEEK64(*pzlib_filefunc_def,filestream, relativeOffset,ZLIB_FILEFUNC_SEEK_SET)!=0)
+    return 0;
+
+  /* the signature */
+  if (zip64local_getLong(pzlib_filefunc_def,filestream,&uL)!=ZIP_OK)
+    return 0;
+
+  if (uL != 0x06064b50) /* signature of 'Zip64 end of central directory' */
+    return 0;
+
+  return relativeOffset;
+}
+
+int LoadCentralDirectoryRecord(zip64_internal* pziinit)
+{
+  int err=ZIP_OK;
+  ZPOS64_T byte_before_the_zipfile;/* byte before the zipfile, (>0 for sfx)*/
+
+  ZPOS64_T size_central_dir;     /* size of the central directory  */
+  ZPOS64_T offset_central_dir;   /* offset of start of central directory */
+  ZPOS64_T central_pos;
+  uLong uL;
+
+  uLong number_disk;          /* number of the current dist, used for
+                              spaning ZIP, unsupported, always 0*/
+  uLong number_disk_with_CD;  /* number the the disk with central dir, used
+                              for spaning ZIP, unsupported, always 0*/
+  ZPOS64_T number_entry;
+  ZPOS64_T number_entry_CD;      /* total number of entries in
+                                the central dir
+                                (same than number_entry on nospan) */
+  uLong VersionMadeBy;
+  uLong VersionNeeded;
+  uLong size_comment;
+
+  int hasZIP64Record = 0;
+
+  /* check first if we find a ZIP64 record */
+  central_pos = zip64local_SearchCentralDir64(&pziinit->z_filefunc,pziinit->filestream);
+  if(central_pos > 0)
+  {
+    hasZIP64Record = 1;
+  }
+  else if(central_pos == 0)
+  {
+    central_pos = zip64local_SearchCentralDir(&pziinit->z_filefunc,pziinit->filestream);
+  }
+
+/* disable to allow appending to empty ZIP archive
+        if (central_pos==0)
+            err=ZIP_ERRNO;
+*/
+
+  if(hasZIP64Record)
+  {
+    ZPOS64_T sizeEndOfCentralDirectory;
+    if (ZSEEK64(pziinit->z_filefunc, pziinit->filestream, central_pos, ZLIB_FILEFUNC_SEEK_SET) != 0)
+      err=ZIP_ERRNO;
+
+    /* the signature, already checked */
+    if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream,&uL)!=ZIP_OK)
+      err=ZIP_ERRNO;
+
+    /* size of zip64 end of central directory record */
+    if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream, &sizeEndOfCentralDirectory)!=ZIP_OK)
+      err=ZIP_ERRNO;
+
+    /* version made by */
+    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &VersionMadeBy)!=ZIP_OK)
+      err=ZIP_ERRNO;
+
+    /* version needed to extract */
+    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &VersionNeeded)!=ZIP_OK)
+      err=ZIP_ERRNO;
+
+    /* number of this disk */
+    if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream,&number_disk)!=ZIP_OK)
+      err=ZIP_ERRNO;
+
+    /* number of the disk with the start of the central directory */
+    if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream,&number_disk_with_CD)!=ZIP_OK)
+      err=ZIP_ERRNO;
+
+    /* total number of entries in the central directory on this disk */
+    if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream, &number_entry)!=ZIP_OK)
+      err=ZIP_ERRNO;
+
+    /* total number of entries in the central directory */
+    if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream,&number_entry_CD)!=ZIP_OK)
+      err=ZIP_ERRNO;
+
+    if ((number_entry_CD!=number_entry) || (number_disk_with_CD!=0) || (number_disk!=0))
+      err=ZIP_BADZIPFILE;
+
+    /* size of the central directory */
+    if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream,&size_central_dir)!=ZIP_OK)
+      err=ZIP_ERRNO;
+
+    /* offset of start of central directory with respect to the
+    starting disk number */
+    if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream,&offset_central_dir)!=ZIP_OK)
+      err=ZIP_ERRNO;
+
+    /* TODO.. */
+    /* read the comment from the standard central header. */
+    size_comment = 0;
+  }
+  else
+  {
+    /* Read End of central Directory info */
+    if (ZSEEK64(pziinit->z_filefunc, pziinit->filestream, central_pos,ZLIB_FILEFUNC_SEEK_SET)!=0)
+      err=ZIP_ERRNO;
+
+    /* the signature, already checked */
+    if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream,&uL)!=ZIP_OK)
+      err=ZIP_ERRNO;
+
+    /* number of this disk */
+    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream,&number_disk)!=ZIP_OK)
+      err=ZIP_ERRNO;
+
+    /* number of the disk with the start of the central directory */
+    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream,&number_disk_with_CD)!=ZIP_OK)
+      err=ZIP_ERRNO;
+
+    /* total number of entries in the central dir on this disk */
+    number_entry = 0;
+    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &uL)!=ZIP_OK)
+      err=ZIP_ERRNO;
+    else
+      number_entry = uL;
+
+    /* total number of entries in the central dir */
+    number_entry_CD = 0;
+    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &uL)!=ZIP_OK)
+      err=ZIP_ERRNO;
+    else
+      number_entry_CD = uL;
+
+    if ((number_entry_CD!=number_entry) || (number_disk_with_CD!=0) || (number_disk!=0))
+      err=ZIP_BADZIPFILE;
+
+    /* size of the central directory */
+    size_central_dir = 0;
+    if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream, &uL)!=ZIP_OK)
+      err=ZIP_ERRNO;
+    else
+      size_central_dir = uL;
+
+    /* offset of start of central directory with respect to the starting disk number */
+    offset_central_dir = 0;
+    if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream, &uL)!=ZIP_OK)
+      err=ZIP_ERRNO;
+    else
+      offset_central_dir = uL;
+
+
+    /* zipfile global comment length */
+    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &size_comment)!=ZIP_OK)
+      err=ZIP_ERRNO;
+  }
+
+  if ((central_pos<offset_central_dir+size_central_dir) &&
+    (err==ZIP_OK))
+    err=ZIP_BADZIPFILE;
+
+  if (err!=ZIP_OK)
+  {
+      if ((pziinit->flags & ZIP_AUTO_CLOSE) != 0) {
+        ZCLOSE64(pziinit->z_filefunc, pziinit->filestream);
+      } else {
+        ZFAKECLOSE64(pziinit->z_filefunc, pziinit->filestream);
+      }
+    return ZIP_ERRNO;
+  }
+
+  if (size_comment>0)
+  {
+    pziinit->globalcomment = (char*)ALLOC(size_comment+1);
+    if (pziinit->globalcomment)
+    {
+      size_comment = ZREAD64(pziinit->z_filefunc, pziinit->filestream, pziinit->globalcomment,size_comment);
+      pziinit->globalcomment[size_comment]=0;
+    }
+  }
+
+  byte_before_the_zipfile = central_pos - (offset_central_dir+size_central_dir);
+  pziinit->add_position_when_writting_offset = byte_before_the_zipfile;
+
+  {
+    ZPOS64_T size_central_dir_to_read = size_central_dir;
+    size_t buf_size = SIZEDATA_INDATABLOCK;
+    void* buf_read = (void*)ALLOC(buf_size);
+    if (ZSEEK64(pziinit->z_filefunc, pziinit->filestream, offset_central_dir + byte_before_the_zipfile, ZLIB_FILEFUNC_SEEK_SET) != 0)
+      err=ZIP_ERRNO;
+
+    while ((size_central_dir_to_read>0) && (err==ZIP_OK))
+    {
+      ZPOS64_T read_this = SIZEDATA_INDATABLOCK;
+      if (read_this > size_central_dir_to_read)
+        read_this = size_central_dir_to_read;
+
+      if (ZREAD64(pziinit->z_filefunc, pziinit->filestream,buf_read,(uLong)read_this) != read_this)
+        err=ZIP_ERRNO;
+
+      if (err==ZIP_OK)
+        err = add_data_in_datablock(&pziinit->central_dir,buf_read, (uLong)read_this);
+
+      size_central_dir_to_read-=read_this;
+    }
+    TRYFREE(buf_read);
+  }
+  pziinit->begin_pos = byte_before_the_zipfile;
+  pziinit->number_entry = number_entry_CD;
+
+  if (ZSEEK64(pziinit->z_filefunc, pziinit->filestream, offset_central_dir+byte_before_the_zipfile,ZLIB_FILEFUNC_SEEK_SET) != 0)
+    err=ZIP_ERRNO;
+
+  return err;
+}
+
+
+#endif /* !NO_ADDFILEINEXISTINGZIP*/
+
+
+/************************************************************/
+extern zipFile ZEXPORT zipOpen3 (voidpf file, int append, zipcharpc* globalcomment, zlib_filefunc64_32_def* pzlib_filefunc64_32_def,
+                                 unsigned flags)
+{
+    zip64_internal ziinit;
+    zip64_internal* zi;
+    int err=ZIP_OK;
+
+    ziinit.flags = flags;
+    ziinit.z_filefunc.zseek32_file = NULL;
+    ziinit.z_filefunc.ztell32_file = NULL;
+    if (pzlib_filefunc64_32_def==NULL)
+        fill_qiodevice64_filefunc(&ziinit.z_filefunc.zfile_func64);
+    else
+        ziinit.z_filefunc = *pzlib_filefunc64_32_def;
+
+    ziinit.filestream = ZOPEN64(ziinit.z_filefunc,
+                  file,
+                  (append == APPEND_STATUS_CREATE) ?
+                  (ZLIB_FILEFUNC_MODE_READ | ZLIB_FILEFUNC_MODE_WRITE | ZLIB_FILEFUNC_MODE_CREATE) :
+                    (ZLIB_FILEFUNC_MODE_READ | ZLIB_FILEFUNC_MODE_WRITE | ZLIB_FILEFUNC_MODE_EXISTING));
+
+    if (ziinit.filestream == NULL)
+        return NULL;
+
+    if (append == APPEND_STATUS_CREATEAFTER)
+        ZSEEK64(ziinit.z_filefunc,ziinit.filestream,0,SEEK_END);
+
+    ziinit.begin_pos = ZTELL64(ziinit.z_filefunc,ziinit.filestream);
+    ziinit.in_opened_file_inzip = 0;
+    ziinit.ci.stream_initialised = 0;
+    ziinit.number_entry = 0;
+    ziinit.add_position_when_writting_offset = 0;
+    init_linkedlist(&(ziinit.central_dir));
+
+
+
+    zi = (zip64_internal*)ALLOC(sizeof(zip64_internal));
+    if (zi==NULL)
+    {
+        if ((ziinit.flags & ZIP_AUTO_CLOSE) != 0) {
+            ZCLOSE64(ziinit.z_filefunc,ziinit.filestream);
+        } else {
+            ZFAKECLOSE64(ziinit.z_filefunc,ziinit.filestream);
+        }
+        return NULL;
+    }
+
+    /* now we add file in a zipfile */
+#    ifndef NO_ADDFILEINEXISTINGZIP
+    ziinit.globalcomment = NULL;
+    if (append == APPEND_STATUS_ADDINZIP)
+    {
+      /* Read and Cache Central Directory Records */
+      err = LoadCentralDirectoryRecord(&ziinit);
+    }
+
+    if (globalcomment)
+    {
+      *globalcomment = ziinit.globalcomment;
+    }
+#    endif /* !NO_ADDFILEINEXISTINGZIP*/
+
+    if (err != ZIP_OK)
+    {
+#    ifndef NO_ADDFILEINEXISTINGZIP
+        TRYFREE(ziinit.globalcomment);
+#    endif /* !NO_ADDFILEINEXISTINGZIP*/
+        TRYFREE(zi);
+        return NULL;
+    }
+    else
+    {
+        *zi = ziinit;
+        return (zipFile)zi;
+    }
+}
+
+extern zipFile ZEXPORT zipOpen2 (voidpf file, int append, zipcharpc* globalcomment, zlib_filefunc_def* pzlib_filefunc32_def)
+{
+    if (pzlib_filefunc32_def != NULL)
+    {
+        zlib_filefunc64_32_def zlib_filefunc64_32_def_fill;
+        fill_zlib_filefunc64_32_def_from_filefunc32(&zlib_filefunc64_32_def_fill,pzlib_filefunc32_def);
+        return zipOpen3(file, append, globalcomment, &zlib_filefunc64_32_def_fill, ZIP_DEFAULT_FLAGS);
+    }
+    else
+        return zipOpen3(file, append, globalcomment, NULL, ZIP_DEFAULT_FLAGS);
+}
+
+extern zipFile ZEXPORT zipOpen2_64 (voidpf file, int append, zipcharpc* globalcomment, zlib_filefunc64_def* pzlib_filefunc_def)
+{
+    if (pzlib_filefunc_def != NULL)
+    {
+        zlib_filefunc64_32_def zlib_filefunc64_32_def_fill;
+        zlib_filefunc64_32_def_fill.zfile_func64 = *pzlib_filefunc_def;
+        zlib_filefunc64_32_def_fill.ztell32_file = NULL;
+        zlib_filefunc64_32_def_fill.zseek32_file = NULL;
+        return zipOpen3(file, append, globalcomment, &zlib_filefunc64_32_def_fill, ZIP_DEFAULT_FLAGS);
+    }
+    else
+        return zipOpen3(file, append, globalcomment, NULL, ZIP_DEFAULT_FLAGS);
+}
+
+
+
+extern zipFile ZEXPORT zipOpen (voidpf file, int append)
+{
+    return zipOpen3(file,append,NULL,NULL, ZIP_DEFAULT_FLAGS);
+}
+
+extern zipFile ZEXPORT zipOpen64 (voidpf file, int append)
+{
+    return zipOpen3(file,append,NULL,NULL, ZIP_DEFAULT_FLAGS);
+}
+
+int Write_LocalFileHeader(zip64_internal* zi, const char* filename,
+                          uInt size_extrafield_local,
+                          const void* extrafield_local,
+                          uLong version_to_extract)
+{
+  /* write the local header */
+  int err;
+  uInt size_filename = (uInt)strlen(filename);
+  uInt size_extrafield = size_extrafield_local;
+
+  err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)LOCALHEADERMAGIC, 4);
+
+  if (err==ZIP_OK)
+  {
+    if(zi->ci.flag & ZIP_ENCODING_UTF8)
+      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)63,2);/* Version 6.3 is required for Unicode support */
+    else if(zi->ci.zip64)
+      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)45,2);/* version needed to extract */
+    else
+      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)version_to_extract,2);
+  }
+
+  if (err==ZIP_OK)
+    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->ci.flag,2);
+
+  if (err==ZIP_OK)
+    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->ci.method,2);
+
+  if (err==ZIP_OK)
+    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->ci.dosDate,4);
+
+  /* CRC / Compressed size / Uncompressed size will be filled in later and rewritten later */
+  if (err==ZIP_OK)
+    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4); /* crc 32, unknown */
+  if (err==ZIP_OK)
+  {
+    if(zi->ci.zip64)
+      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0xFFFFFFFF,4); /* compressed size, unknown */
+    else
+      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4); /* compressed size, unknown */
+  }
+  if (err==ZIP_OK)
+  {
+    if(zi->ci.zip64)
+      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0xFFFFFFFF,4); /* uncompressed size, unknown */
+    else
+      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4); /* uncompressed size, unknown */
+  }
+
+  if (err==ZIP_OK)
+    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_filename,2);
+
+  if(zi->ci.zip64)
+  {
+    size_extrafield += 20;
+  }
+
+  if (err==ZIP_OK)
+    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_extrafield,2);
+
+  if ((err==ZIP_OK) && (size_filename > 0))
+  {
+    if (ZWRITE64(zi->z_filefunc,zi->filestream,filename,size_filename)!=size_filename)
+      err = ZIP_ERRNO;
+  }
+
+  if ((err==ZIP_OK) && (size_extrafield_local > 0))
+  {
+    if (ZWRITE64(zi->z_filefunc, zi->filestream, extrafield_local, size_extrafield_local) != size_extrafield_local)
+      err = ZIP_ERRNO;
+  }
+
+
+  if ((err==ZIP_OK) && (zi->ci.zip64))
+  {
+      /* write the Zip64 extended info */
+      short HeaderID = 1;
+      short DataSize = 16;
+      ZPOS64_T CompressedSize = 0;
+      ZPOS64_T UncompressedSize = 0;
+
+      /* Remember position of Zip64 extended info for the local file header. (needed when we update size after done with file) */
+      zi->ci.pos_zip64extrainfo = ZTELL64(zi->z_filefunc,zi->filestream);
+
+      err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (short)HeaderID,2);
+      err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (short)DataSize,2);
+
+      err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (ZPOS64_T)UncompressedSize,8);
+      err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (ZPOS64_T)CompressedSize,8);
+  }
+
+  return err;
+}
+
+/*
+ NOTE.
+ When writing RAW the ZIP64 extended information in extrafield_local and extrafield_global needs to be stripped
+ before calling this function it can be done with zipRemoveExtraInfoBlock
+
+ It is not done here because then we need to realloc a new buffer since parameters are 'const' and I want to minimize
+ unnecessary allocations.
+ */
+extern int ZEXPORT zipOpenNewFileInZip4_64 (zipFile file, const char* filename, const zip_fileinfo* zipfi,
+                                         const void* extrafield_local, uInt size_extrafield_local,
+                                         const void* extrafield_global, uInt size_extrafield_global,
+                                         const char* comment, int method, int level, int raw,
+                                         int windowBits,int memLevel, int strategy,
+                                         const char* password, uLong crcForCrypting,
+                                         uLong versionMadeBy, uLong flagBase, int zip64)
+{
+    zip64_internal* zi;
+    uInt size_filename;
+    uInt size_comment;
+    uInt i;
+    int err = ZIP_OK;
+    uLong version_to_extract;
+
+#    ifdef NOCRYPT
+    if (password != NULL)
+        return ZIP_PARAMERROR;
+#    endif
+
+    if (file == NULL)
+        return ZIP_PARAMERROR;
+
+#ifdef HAVE_BZIP2
+    if ((method!=0) && (method!=Z_DEFLATED) && (method!=Z_BZIP2ED))
+      return ZIP_PARAMERROR;
+#else
+    if ((method!=0) && (method!=Z_DEFLATED))
+      return ZIP_PARAMERROR;
+#endif
+
+    zi = (zip64_internal*)file;
+
+    if (zi->in_opened_file_inzip == 1)
+    {
+        err = zipCloseFileInZip (file);
+        if (err != ZIP_OK)
+            return err;
+    }
+
+    if (method == 0
+            && (level == 0 || (zi->flags & ZIP_WRITE_DATA_DESCRIPTOR) == 0)
+            && (zi->flags & ZIP_SEQUENTIAL) == 0)
+    {
+        version_to_extract = 10;
+    }
+    else
+    {
+        version_to_extract = 20;
+    }
+
+    if (filename==NULL)
+        filename="-";
+
+    if (comment==NULL)
+        size_comment = 0;
+    else
+        size_comment = (uInt)strlen(comment);
+
+    size_filename = (uInt)strlen(filename);
+
+    if (zipfi == NULL)
+        zi->ci.dosDate = 0;
+    else
+    {
+        if (zipfi->dosDate != 0)
+            zi->ci.dosDate = zipfi->dosDate;
+        else
+          zi->ci.dosDate = zip64local_TmzDateToDosDate(&zipfi->tmz_date);
+    }
+
+    zi->ci.flag = flagBase;
+    if (zi->flags & ZIP_ENCODING_UTF8)
+        zi->ci.flag |= ZIP_ENCODING_UTF8;
+    if ((level==8) || (level==9))
+      zi->ci.flag |= 2;
+    if (level==2)
+      zi->ci.flag |= 4;
+    if (level==1)
+      zi->ci.flag |= 6;
+    if (password != NULL)
+      zi->ci.flag |= 1;
+    if (version_to_extract >= 20
+            && ((zi->flags & ZIP_WRITE_DATA_DESCRIPTOR) != 0
+                || (zi->flags & ZIP_SEQUENTIAL) != 0))
+      zi->ci.flag |= 8;
+
+    zi->ci.crc32 = 0;
+    zi->ci.method = method;
+    zi->ci.encrypt = 0;
+    zi->ci.stream_initialised = 0;
+    zi->ci.pos_in_buffered_data = 0;
+    zi->ci.raw = raw;
+    zi->ci.pos_local_header = ZTELL64(zi->z_filefunc,zi->filestream);
+
+    zi->ci.size_centralheader = SIZECENTRALHEADER + size_filename + size_extrafield_global + size_comment;
+    zi->ci.size_centralExtraFree = 32; /* Extra space we have reserved in case we need to add ZIP64 extra info data */
+
+    zi->ci.central_header = (char*)ALLOC((uInt)zi->ci.size_centralheader + zi->ci.size_centralExtraFree);
+    if(!zi->ci.central_header) {
+      return (Z_MEM_ERROR);
+    }
+
+    zi->ci.size_centralExtra = size_extrafield_global;
+    zip64local_putValue_inmemory(zi->ci.central_header,(uLong)CENTRALHEADERMAGIC,4);
+    /* version info */
+    zip64local_putValue_inmemory(zi->ci.central_header+4,(uLong)versionMadeBy,2);
+    zip64local_putValue_inmemory(zi->ci.central_header+6,(uLong)version_to_extract,2);
+    zip64local_putValue_inmemory(zi->ci.central_header+8,(uLong)zi->ci.flag,2);
+    zip64local_putValue_inmemory(zi->ci.central_header+10,(uLong)zi->ci.method,2);
+    zip64local_putValue_inmemory(zi->ci.central_header+12,(uLong)zi->ci.dosDate,4);
+    zip64local_putValue_inmemory(zi->ci.central_header+16,(uLong)0,4); /*crc*/
+    zip64local_putValue_inmemory(zi->ci.central_header+20,(uLong)0,4); /*compr size*/
+    zip64local_putValue_inmemory(zi->ci.central_header+24,(uLong)0,4); /*uncompr size*/
+    zip64local_putValue_inmemory(zi->ci.central_header+28,(uLong)size_filename,2);
+    zip64local_putValue_inmemory(zi->ci.central_header+30,(uLong)size_extrafield_global,2);
+    zip64local_putValue_inmemory(zi->ci.central_header+32,(uLong)size_comment,2);
+    zip64local_putValue_inmemory(zi->ci.central_header+34,(uLong)0,2); /*disk nm start*/
+
+    if (zipfi==NULL)
+        zip64local_putValue_inmemory(zi->ci.central_header+36,(uLong)0,2);
+    else
+        zip64local_putValue_inmemory(zi->ci.central_header+36,(uLong)zipfi->internal_fa,2);
+
+    if (zipfi==NULL)
+        zip64local_putValue_inmemory(zi->ci.central_header+38,(uLong)0,4);
+    else
+        zip64local_putValue_inmemory(zi->ci.central_header+38,(uLong)zipfi->external_fa,4);
+
+    if(zi->ci.pos_local_header >= 0xffffffff)
+      zip64local_putValue_inmemory(zi->ci.central_header+42,(uLong)0xffffffff,4);
+    else
+      zip64local_putValue_inmemory(zi->ci.central_header+42,(uLong)zi->ci.pos_local_header - zi->add_position_when_writting_offset,4);
+
+    for (i=0;i<size_filename;i++)
+        *(zi->ci.central_header+SIZECENTRALHEADER+i) = *(filename+i);
+
+    for (i=0;i<size_extrafield_global;i++)
+        *(zi->ci.central_header+SIZECENTRALHEADER+size_filename+i) =
+              *(((const char*)extrafield_global)+i);
+
+    for (i=0;i<size_comment;i++)
+        *(zi->ci.central_header+SIZECENTRALHEADER+size_filename+
+              size_extrafield_global+i) = *(comment+i);
+    if (zi->ci.central_header == NULL)
+        return ZIP_INTERNALERROR;
+
+    zi->ci.zip64 = zip64;
+    zi->ci.totalCompressedData = 0;
+    zi->ci.totalUncompressedData = 0;
+    zi->ci.pos_zip64extrainfo = 0;
+
+    err = Write_LocalFileHeader(zi, filename, size_extrafield_local,
+                                extrafield_local, version_to_extract);
+
+#ifdef HAVE_BZIP2
+    zi->ci.bstream.avail_in = (uInt)0;
+    zi->ci.bstream.avail_out = (uInt)Z_BUFSIZE;
+    zi->ci.bstream.next_out = (char*)zi->ci.buffered_data;
+    zi->ci.bstream.total_in_hi32 = 0;
+    zi->ci.bstream.total_in_lo32 = 0;
+    zi->ci.bstream.total_out_hi32 = 0;
+    zi->ci.bstream.total_out_lo32 = 0;
+#endif
+
+    zi->ci.stream.avail_in = (uInt)0;
+    zi->ci.stream.avail_out = (uInt)Z_BUFSIZE;
+    zi->ci.stream.next_out = zi->ci.buffered_data;
+    zi->ci.stream.total_in = 0;
+    zi->ci.stream.total_out = 0;
+    zi->ci.stream.data_type = Z_BINARY;
+
+#ifdef HAVE_BZIP2
+    if ((err==ZIP_OK) && (zi->ci.method == Z_DEFLATED || zi->ci.method == Z_BZIP2ED) && (!zi->ci.raw))
+#else
+    if ((err==ZIP_OK) && (zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))
+#endif
+    {
+        if(zi->ci.method == Z_DEFLATED)
+        {
+          zi->ci.stream.zalloc = (alloc_func)0;
+          zi->ci.stream.zfree = (free_func)0;
+          zi->ci.stream.opaque = (voidpf)0;
+
+          if (windowBits>0)
+              windowBits = -windowBits;
+
+          err = deflateInit2(&zi->ci.stream, level, Z_DEFLATED, windowBits, memLevel, strategy);
+
+          if (err==Z_OK)
+              zi->ci.stream_initialised = Z_DEFLATED;
+        }
+        else if(zi->ci.method == Z_BZIP2ED)
+        {
+#ifdef HAVE_BZIP2
+            /* Init BZip stuff here */
+          zi->ci.bstream.bzalloc = 0;
+          zi->ci.bstream.bzfree = 0;
+          zi->ci.bstream.opaque = (voidpf)0;
+
+          err = BZ2_bzCompressInit(&zi->ci.bstream, level, 0,35);
+          if(err == BZ_OK)
+            zi->ci.stream_initialised = Z_BZIP2ED;
+#endif
+        }
+
+    }
+
+#    ifndef NOCRYPT
+    zi->ci.crypt_header_size = 0;
+    if ((err==Z_OK) && (password != NULL))
+    {
+        unsigned char bufHead[RAND_HEAD_LEN];
+        unsigned int sizeHead;
+        zi->ci.encrypt = 1;
+        zi->ci.pcrc_32_tab = get_crc_table();
+        /*init_keys(password,zi->ci.keys,zi->ci.pcrc_32_tab);*/
+        if (crcForCrypting == 0) {
+            crcForCrypting = (uLong)zi->ci.dosDate << 16; /* ATTANTION! Without this row, you don't unpack your password protected archive in other app. */
+        }
+        sizeHead=crypthead(password,bufHead,RAND_HEAD_LEN,zi->ci.keys,zi->ci.pcrc_32_tab,crcForCrypting);
+        zi->ci.crypt_header_size = sizeHead;
+
+        if (ZWRITE64(zi->z_filefunc,zi->filestream,bufHead,sizeHead) != sizeHead)
+                err = ZIP_ERRNO;
+    }
+#    endif
+
+    if (err==Z_OK)
+        zi->in_opened_file_inzip = 1;
+    return err;
+}
+
+extern int ZEXPORT zipOpenNewFileInZip4 (zipFile file, const char* filename, const zip_fileinfo* zipfi,
+                                         const void* extrafield_local, uInt size_extrafield_local,
+                                         const void* extrafield_global, uInt size_extrafield_global,
+                                         const char* comment, int method, int level, int raw,
+                                         int windowBits,int memLevel, int strategy,
+                                         const char* password, uLong crcForCrypting,
+                                         uLong versionMadeBy, uLong flagBase)
+{
+    return zipOpenNewFileInZip4_64 (file, filename, zipfi,
+                                 extrafield_local, size_extrafield_local,
+                                 extrafield_global, size_extrafield_global,
+                                 comment, method, level, raw,
+                                 windowBits, memLevel, strategy,
+                                 password, crcForCrypting, versionMadeBy, flagBase, 0);
+}
+
+extern int ZEXPORT zipOpenNewFileInZip3 (zipFile file, const char* filename, const zip_fileinfo* zipfi,
+                                         const void* extrafield_local, uInt size_extrafield_local,
+                                         const void* extrafield_global, uInt size_extrafield_global,
+                                         const char* comment, int method, int level, int raw,
+                                         int windowBits,int memLevel, int strategy,
+                                         const char* password, uLong crcForCrypting)
+{
+    return zipOpenNewFileInZip4_64 (file, filename, zipfi,
+                                 extrafield_local, size_extrafield_local,
+                                 extrafield_global, size_extrafield_global,
+                                 comment, method, level, raw,
+                                 windowBits, memLevel, strategy,
+                                 password, crcForCrypting, VERSIONMADEBY, 0, 0);
+}
+
+extern int ZEXPORT zipOpenNewFileInZip3_64(zipFile file, const char* filename, const zip_fileinfo* zipfi,
+                                         const void* extrafield_local, uInt size_extrafield_local,
+                                         const void* extrafield_global, uInt size_extrafield_global,
+                                         const char* comment, int method, int level, int raw,
+                                         int windowBits,int memLevel, int strategy,
+                                         const char* password, uLong crcForCrypting, int zip64)
+{
+    return zipOpenNewFileInZip4_64 (file, filename, zipfi,
+                                 extrafield_local, size_extrafield_local,
+                                 extrafield_global, size_extrafield_global,
+                                 comment, method, level, raw,
+                                 windowBits, memLevel, strategy,
+                                 password, crcForCrypting, VERSIONMADEBY, 0, zip64);
+}
+
+extern int ZEXPORT zipOpenNewFileInZip2(zipFile file, const char* filename, const zip_fileinfo* zipfi,
+                                        const void* extrafield_local, uInt size_extrafield_local,
+                                        const void* extrafield_global, uInt size_extrafield_global,
+                                        const char* comment, int method, int level, int raw)
+{
+    return zipOpenNewFileInZip4_64 (file, filename, zipfi,
+                                 extrafield_local, size_extrafield_local,
+                                 extrafield_global, size_extrafield_global,
+                                 comment, method, level, raw,
+                                 -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,
+                                 NULL, 0, VERSIONMADEBY, 0, 0);
+}
+
+extern int ZEXPORT zipOpenNewFileInZip2_64(zipFile file, const char* filename, const zip_fileinfo* zipfi,
+                                        const void* extrafield_local, uInt size_extrafield_local,
+                                        const void* extrafield_global, uInt size_extrafield_global,
+                                        const char* comment, int method, int level, int raw, int zip64)
+{
+    return zipOpenNewFileInZip4_64 (file, filename, zipfi,
+                                 extrafield_local, size_extrafield_local,
+                                 extrafield_global, size_extrafield_global,
+                                 comment, method, level, raw,
+                                 -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,
+                                 NULL, 0, VERSIONMADEBY, 0, zip64);
+}
+
+extern int ZEXPORT zipOpenNewFileInZip64 (zipFile file, const char* filename, const zip_fileinfo* zipfi,
+                                        const void* extrafield_local, uInt size_extrafield_local,
+                                        const void*extrafield_global, uInt size_extrafield_global,
+                                        const char* comment, int method, int level, int zip64)
+{
+    return zipOpenNewFileInZip4_64 (file, filename, zipfi,
+                                 extrafield_local, size_extrafield_local,
+                                 extrafield_global, size_extrafield_global,
+                                 comment, method, level, 0,
+                                 -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,
+                                 NULL, 0, VERSIONMADEBY, 0, zip64);
+}
+
+extern int ZEXPORT zipOpenNewFileInZip (zipFile file, const char* filename, const zip_fileinfo* zipfi,
+                                        const void* extrafield_local, uInt size_extrafield_local,
+                                        const void*extrafield_global, uInt size_extrafield_global,
+                                        const char* comment, int method, int level)
+{
+    return zipOpenNewFileInZip4_64 (file, filename, zipfi,
+                                 extrafield_local, size_extrafield_local,
+                                 extrafield_global, size_extrafield_global,
+                                 comment, method, level, 0,
+                                 -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,
+                                 NULL, 0, VERSIONMADEBY, 0, 0);
+}
+
+local int zip64FlushWriteBuffer(zip64_internal* zi)
+{
+    int err=ZIP_OK;
+
+    if (zi->ci.encrypt != 0)
+    {
+#ifndef NOCRYPT
+        uInt i;
+        int t;
+        for (i=0;i<zi->ci.pos_in_buffered_data;i++)
+            zi->ci.buffered_data[i] = zencode(zi->ci.keys, zi->ci.pcrc_32_tab, zi->ci.buffered_data[i],t);
+#endif
+    }
+
+    if (ZWRITE64(zi->z_filefunc,zi->filestream,zi->ci.buffered_data,zi->ci.pos_in_buffered_data) != zi->ci.pos_in_buffered_data)
+      err = ZIP_ERRNO;
+
+    zi->ci.totalCompressedData += zi->ci.pos_in_buffered_data;
+
+#ifdef HAVE_BZIP2
+    if(zi->ci.method == Z_BZIP2ED)
+    {
+      zi->ci.totalUncompressedData += zi->ci.bstream.total_in_lo32;
+      zi->ci.bstream.total_in_lo32 = 0;
+      zi->ci.bstream.total_in_hi32 = 0;
+    }
+    else
+#endif
+    {
+      zi->ci.totalUncompressedData += zi->ci.stream.total_in;
+      zi->ci.stream.total_in = 0;
+    }
+
+
+    zi->ci.pos_in_buffered_data = 0;
+
+    return err;
+}
+
+extern int ZEXPORT zipWriteInFileInZip (zipFile file,const void* buf,unsigned int len)
+{
+    zip64_internal* zi;
+    int err=ZIP_OK;
+
+    if (file == NULL)
+        return ZIP_PARAMERROR;
+    zi = (zip64_internal*)file;
+
+    if (zi->in_opened_file_inzip == 0)
+        return ZIP_PARAMERROR;
+
+    zi->ci.crc32 = crc32(zi->ci.crc32,buf,(uInt)len);
+
+#ifdef HAVE_BZIP2
+    if(zi->ci.method == Z_BZIP2ED && (!zi->ci.raw))
+    {
+      zi->ci.bstream.next_in = (void*)buf;
+      zi->ci.bstream.avail_in = len;
+      err = BZ_RUN_OK;
+
+      while ((err==BZ_RUN_OK) && (zi->ci.bstream.avail_in>0))
+      {
+        if (zi->ci.bstream.avail_out == 0)
+        {
+          if (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)
+            err = ZIP_ERRNO;
+          zi->ci.bstream.avail_out = (uInt)Z_BUFSIZE;
+          zi->ci.bstream.next_out = (char*)zi->ci.buffered_data;
+        }
+
+
+        if(err != BZ_RUN_OK)
+          break;
+
+        if ((zi->ci.method == Z_BZIP2ED) && (!zi->ci.raw))
+        {
+          uLong uTotalOutBefore_lo = zi->ci.bstream.total_out_lo32;
+/*          uLong uTotalOutBefore_hi = zi->ci.bstream.total_out_hi32; */
+          err=BZ2_bzCompress(&zi->ci.bstream,  BZ_RUN);
+
+          zi->ci.pos_in_buffered_data += (uInt)(zi->ci.bstream.total_out_lo32 - uTotalOutBefore_lo) ;
+        }
+      }
+
+      if(err == BZ_RUN_OK)
+        err = ZIP_OK;
+    }
+    else
+#endif
+    {
+      zi->ci.stream.next_in = (Bytef*)buf;
+      zi->ci.stream.avail_in = len;
+
+      while ((err==ZIP_OK) && (zi->ci.stream.avail_in>0))
+      {
+          if (zi->ci.stream.avail_out == 0)
+          {
+              if (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)
+                  err = ZIP_ERRNO;
+              zi->ci.stream.avail_out = (uInt)Z_BUFSIZE;
+              zi->ci.stream.next_out = zi->ci.buffered_data;
+          }
+
+
+          if(err != ZIP_OK)
+              break;
+
+          if ((zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))
+          {
+              uInt uAvailOutBefore = zi->ci.stream.avail_out;
+              err=deflate(&zi->ci.stream,  Z_NO_FLUSH);
+              zi->ci.pos_in_buffered_data += uAvailOutBefore - zi->ci.stream.avail_out;
+          }
+          else
+          {
+              uInt copy_this,i;
+              if (zi->ci.stream.avail_in < zi->ci.stream.avail_out)
+                  copy_this = zi->ci.stream.avail_in;
+              else
+                  copy_this = zi->ci.stream.avail_out;
+
+              for (i = 0; i < copy_this; i++)
+                  *(((char*)zi->ci.stream.next_out)+i) =
+                      *(((const char*)zi->ci.stream.next_in)+i);
+              {
+                  zi->ci.stream.avail_in -= copy_this;
+                  zi->ci.stream.avail_out-= copy_this;
+                  zi->ci.stream.next_in+= copy_this;
+                  zi->ci.stream.next_out+= copy_this;
+                  zi->ci.stream.total_in+= copy_this;
+                  zi->ci.stream.total_out+= copy_this;
+                  zi->ci.pos_in_buffered_data += copy_this;
+              }
+          }
+      }/* while(...) */
+    }
+
+    return err;
+}
+
+extern int ZEXPORT zipCloseFileInZipRaw (zipFile file, uLong uncompressed_size, uLong crc32)
+{
+    return zipCloseFileInZipRaw64 (file, uncompressed_size, crc32);
+}
+
+extern int ZEXPORT zipCloseFileInZipRaw64 (zipFile file, ZPOS64_T uncompressed_size, uLong crc32)
+{
+    zip64_internal* zi;
+    ZPOS64_T compressed_size;
+    uLong invalidValue = 0xffffffff;
+    short datasize = 0;
+    int err=ZIP_OK;
+
+    if (file == NULL)
+        return ZIP_PARAMERROR;
+    zi = (zip64_internal*)file;
+
+    if (zi->in_opened_file_inzip == 0)
+        return ZIP_PARAMERROR;
+    zi->ci.stream.avail_in = 0;
+
+    if ((zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))
+                {
+                        while (err==ZIP_OK)
+                        {
+                                uLong uAvailOutBefore;
+                                if (zi->ci.stream.avail_out == 0)
+                                {
+                                        if (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)
+                                                err = ZIP_ERRNO;
+                                        zi->ci.stream.avail_out = (uInt)Z_BUFSIZE;
+                                        zi->ci.stream.next_out = zi->ci.buffered_data;
+                                }
+                                uAvailOutBefore = zi->ci.stream.avail_out;
+                                err=deflate(&zi->ci.stream,  Z_FINISH);
+                                zi->ci.pos_in_buffered_data += uAvailOutBefore - zi->ci.stream.avail_out;
+                        }
+                }
+    else if ((zi->ci.method == Z_BZIP2ED) && (!zi->ci.raw))
+    {
+#ifdef HAVE_BZIP2
+      err = BZ_FINISH_OK;
+      while (err==BZ_FINISH_OK)
+      {
+        uLong uTotalOutBefore;
+        if (zi->ci.bstream.avail_out == 0)
+        {
+          if (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)
+            err = ZIP_ERRNO;
+          zi->ci.bstream.avail_out = (uInt)Z_BUFSIZE;
+          zi->ci.bstream.next_out = (char*)zi->ci.buffered_data;
+        }
+        uTotalOutBefore = zi->ci.bstream.total_out_lo32;
+        err=BZ2_bzCompress(&zi->ci.bstream,  BZ_FINISH);
+        if(err == BZ_STREAM_END)
+          err = Z_STREAM_END;
+
+        zi->ci.pos_in_buffered_data += (uInt)(zi->ci.bstream.total_out_lo32 - uTotalOutBefore);
+      }
+
+      if(err == BZ_FINISH_OK)
+        err = ZIP_OK;
+#endif
+    }
+
+    if (err==Z_STREAM_END)
+        err=ZIP_OK; /* this is normal */
+
+    if ((zi->ci.pos_in_buffered_data>0) && (err==ZIP_OK))
+                {
+        if (zip64FlushWriteBuffer(zi)==ZIP_ERRNO)
+            err = ZIP_ERRNO;
+                }
+
+    if ((zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))
+    {
+        int tmp_err = deflateEnd(&zi->ci.stream);
+        if (err == ZIP_OK)
+            err = tmp_err;
+        zi->ci.stream_initialised = 0;
+    }
+#ifdef HAVE_BZIP2
+    else if((zi->ci.method == Z_BZIP2ED) && (!zi->ci.raw))
+    {
+      int tmperr = BZ2_bzCompressEnd(&zi->ci.bstream);
+                        if (err==ZIP_OK)
+                                err = tmperr;
+                        zi->ci.stream_initialised = 0;
+    }
+#endif
+
+    if (!zi->ci.raw)
+    {
+        crc32 = (uLong)zi->ci.crc32;
+        uncompressed_size = zi->ci.totalUncompressedData;
+    }
+    compressed_size = zi->ci.totalCompressedData;
+
+#    ifndef NOCRYPT
+    compressed_size += zi->ci.crypt_header_size;
+#    endif
+
+    /* update Current Item crc and sizes, */
+    if(compressed_size >= 0xffffffff || uncompressed_size >= 0xffffffff || zi->ci.pos_local_header >= 0xffffffff)
+    {
+      /*version Made by*/
+      zip64local_putValue_inmemory(zi->ci.central_header+4,(uLong)45,2);
+      /*version needed*/
+      zip64local_putValue_inmemory(zi->ci.central_header+6,(uLong)((zi->ci.flag & ZIP_ENCODING_UTF8) ? 63 : 45),2);
+    }
+
+    zip64local_putValue_inmemory(zi->ci.central_header+16,crc32,4); /*crc*/
+
+
+    if(compressed_size >= 0xffffffff)
+      zip64local_putValue_inmemory(zi->ci.central_header+20, invalidValue,4); /*compr size*/
+    else
+      zip64local_putValue_inmemory(zi->ci.central_header+20, compressed_size,4); /*compr size*/
+
+    /* set internal file attributes field */
+    if (zi->ci.stream.data_type == Z_ASCII)
+        zip64local_putValue_inmemory(zi->ci.central_header+36,(uLong)Z_ASCII,2);
+
+    if(uncompressed_size >= 0xffffffff)
+      zip64local_putValue_inmemory(zi->ci.central_header+24, invalidValue,4); /*uncompr size*/
+    else
+      zip64local_putValue_inmemory(zi->ci.central_header+24, uncompressed_size,4); /*uncompr size*/
+
+    /* Add ZIP64 extra info field for uncompressed size */
+    if(uncompressed_size >= 0xffffffff)
+      datasize += 8;
+
+    /* Add ZIP64 extra info field for compressed size */
+    if(compressed_size >= 0xffffffff)
+      datasize += 8;
+
+    /* Add ZIP64 extra info field for relative offset to local file header of current file */
+    if(zi->ci.pos_local_header >= 0xffffffff)
+      datasize += 8;
+
+    if(datasize > 0)
+    {
+      char* p = NULL;
+
+      if((uLong)(datasize + 4) > zi->ci.size_centralExtraFree)
+      {
+        /* we can not write more data to the buffer that we have room for. */
+        return ZIP_BADZIPFILE;
+      }
+
+      p = zi->ci.central_header + zi->ci.size_centralheader;
+
+      /* Add Extra Information Header for 'ZIP64 information' */
+      zip64local_putValue_inmemory(p, 0x0001, 2); /* HeaderID */
+      p += 2;
+      zip64local_putValue_inmemory(p, datasize, 2); /* DataSize */
+      p += 2;
+
+      if(uncompressed_size >= 0xffffffff)
+      {
+        zip64local_putValue_inmemory(p, uncompressed_size, 8);
+        p += 8;
+      }
+
+      if(compressed_size >= 0xffffffff)
+      {
+        zip64local_putValue_inmemory(p, compressed_size, 8);
+        p += 8;
+      }
+
+      if(zi->ci.pos_local_header >= 0xffffffff)
+      {
+        zip64local_putValue_inmemory(p, zi->ci.pos_local_header, 8);
+        p += 8;
+      }
+
+      /* Update how much extra free space we got in the memory buffer */
+      /* and increase the centralheader size so the new ZIP64 fields are included */
+      /* ( 4 below is the size of HeaderID and DataSize field ) */
+      zi->ci.size_centralExtraFree -= datasize + 4;
+      zi->ci.size_centralheader += datasize + 4;
+
+      /* Update the extra info size field */
+      zi->ci.size_centralExtra += datasize + 4;
+      zip64local_putValue_inmemory(zi->ci.central_header+30,(uLong)zi->ci.size_centralExtra,2);
+    }
+
+    if (err==ZIP_OK)
+        err = add_data_in_datablock(&zi->central_dir, zi->ci.central_header, (uLong)zi->ci.size_centralheader);
+
+    TRYFREE(zi->ci.central_header);
+
+    if (err==ZIP_OK)
+    {
+        if ((zi->flags & ZIP_SEQUENTIAL) == 0) {
+            /* Update the LocalFileHeader with the new values. */
+
+            ZPOS64_T cur_pos_inzip = ZTELL64(zi->z_filefunc,zi->filestream);
+
+            if (ZSEEK64(zi->z_filefunc,zi->filestream, zi->ci.pos_local_header + 14,ZLIB_FILEFUNC_SEEK_SET)!=0)
+                err = ZIP_ERRNO;
+
+            if (err==ZIP_OK)
+                err = zip64local_putValue(&zi->z_filefunc,zi->filestream,crc32,4); /* crc 32, unknown */
+
+            if(uncompressed_size >= 0xffffffff || compressed_size >= 0xffffffff)
+            {
+                if(zi->ci.pos_zip64extrainfo > 0)
+                {
+                    /* Update the size in the ZIP64 extended field. */
+                    if (ZSEEK64(zi->z_filefunc,zi->filestream, zi->ci.pos_zip64extrainfo + 4,ZLIB_FILEFUNC_SEEK_SET)!=0)
+                        err = ZIP_ERRNO;
+
+                    if (err==ZIP_OK) /* compressed size, unknown */
+                        err = zip64local_putValue(&zi->z_filefunc, zi->filestream, uncompressed_size, 8);
+
+                    if (err==ZIP_OK) /* uncompressed size, unknown */
+                        err = zip64local_putValue(&zi->z_filefunc, zi->filestream, compressed_size, 8);
+                }
+            }
+            else
+            {
+                if (err==ZIP_OK) /* compressed size, unknown */
+                    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,compressed_size,4);
+
+                if (err==ZIP_OK) /* uncompressed size, unknown */
+                    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,uncompressed_size,4);
+            }
+
+            if (ZSEEK64(zi->z_filefunc,zi->filestream, cur_pos_inzip,ZLIB_FILEFUNC_SEEK_SET)!=0)
+                err = ZIP_ERRNO;
+        }
+
+        if ((zi->ci.flag & 8) != 0) {
+            /* Write local Descriptor after file data */
+            if (err==ZIP_OK)
+                err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)DESCRIPTORHEADERMAGIC,4);
+            if (err==ZIP_OK)
+                err = zip64local_putValue(&zi->z_filefunc,zi->filestream,crc32,4); /* crc 32, unknown */
+            if (zi->ci.zip64) {
+                if (err==ZIP_OK) /* compressed size, unknown */
+                    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,compressed_size,8);
+
+                if (err==ZIP_OK) /* uncompressed size, unknown */
+                    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,uncompressed_size,8);
+            } else {
+                if (err==ZIP_OK) /* compressed size, unknown */
+                    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,compressed_size,4);
+                if (err==ZIP_OK) /* uncompressed size, unknown */
+                    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,uncompressed_size,4);
+            }
+        }
+    }
+
+    zi->number_entry ++;
+    zi->in_opened_file_inzip = 0;
+
+    return err;
+}
+
+extern int ZEXPORT zipCloseFileInZip (zipFile file)
+{
+    return zipCloseFileInZipRaw (file,0,0);
+}
+
+int Write_Zip64EndOfCentralDirectoryLocator(zip64_internal* zi, ZPOS64_T zip64eocd_pos_inzip)
+{
+  int err = ZIP_OK;
+  ZPOS64_T pos = zip64eocd_pos_inzip - zi->add_position_when_writting_offset;
+
+  err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)ZIP64ENDLOCHEADERMAGIC,4);
+
+  /*num disks*/
+    if (err==ZIP_OK) /* number of the disk with the start of the central directory */
+      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4);
+
+  /*relative offset*/
+    if (err==ZIP_OK) /* Relative offset to the Zip64EndOfCentralDirectory */
+      err = zip64local_putValue(&zi->z_filefunc,zi->filestream, pos,8);
+
+  /*total disks*/ /* Do not support spawning of disk so always say 1 here*/
+    if (err==ZIP_OK) /* number of the disk with the start of the central directory */
+      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)1,4);
+
+    return err;
+}
+
+int Write_Zip64EndOfCentralDirectoryRecord(zip64_internal* zi, uLong size_centraldir, ZPOS64_T centraldir_pos_inzip)
+{
+  int err = ZIP_OK;
+
+  uLong Zip64DataSize = 44;
+
+  err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)ZIP64ENDHEADERMAGIC,4);
+
+  if (err==ZIP_OK) /* size of this 'zip64 end of central directory' */
+    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(ZPOS64_T)Zip64DataSize,8); /* why ZPOS64_T of this ? */
+
+  if (err==ZIP_OK) /* version made by */
+    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)45,2);
+
+  if (err==ZIP_OK) /* version needed */
+    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)((zi->ci.flag & ZIP_ENCODING_UTF8) ? 63 : 45),2);
+
+  if (err==ZIP_OK) /* number of this disk */
+    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4);
+
+  if (err==ZIP_OK) /* number of the disk with the start of the central directory */
+    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4);
+
+  if (err==ZIP_OK) /* total number of entries in the central dir on this disk */
+    err = zip64local_putValue(&zi->z_filefunc, zi->filestream, zi->number_entry, 8);
+
+  if (err==ZIP_OK) /* total number of entries in the central dir */
+    err = zip64local_putValue(&zi->z_filefunc, zi->filestream, zi->number_entry, 8);
+
+  if (err==ZIP_OK) /* size of the central directory */
+    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(ZPOS64_T)size_centraldir,8);
+
+  if (err==ZIP_OK) /* offset of start of central directory with respect to the starting disk number */
+  {
+    ZPOS64_T pos = centraldir_pos_inzip - zi->add_position_when_writting_offset;
+    err = zip64local_putValue(&zi->z_filefunc,zi->filestream, (ZPOS64_T)pos,8);
+  }
+  return err;
+}
+int Write_EndOfCentralDirectoryRecord(zip64_internal* zi, uLong size_centraldir, ZPOS64_T centraldir_pos_inzip)
+{
+  int err = ZIP_OK;
+
+  /*signature*/
+  err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)ENDHEADERMAGIC,4);
+
+  if (err==ZIP_OK) /* number of this disk */
+    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,2);
+
+  if (err==ZIP_OK) /* number of the disk with the start of the central directory */
+    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,2);
+
+  if (err==ZIP_OK) /* total number of entries in the central dir on this disk */
+  {
+    {
+      if(zi->number_entry >= 0xFFFF)
+        err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0xffff,2); /* use value in ZIP64 record */
+      else
+        err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->number_entry,2);
+    }
+  }
+
+  if (err==ZIP_OK) /* total number of entries in the central dir */
+  {
+    if(zi->number_entry >= 0xFFFF)
+      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0xffff,2); /* use value in ZIP64 record */
+    else
+      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->number_entry,2);
+  }
+
+  if (err==ZIP_OK) /* size of the central directory */
+    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_centraldir,4);
+
+  if (err==ZIP_OK) /* offset of start of central directory with respect to the starting disk number */
+  {
+    ZPOS64_T pos = centraldir_pos_inzip - zi->add_position_when_writting_offset;
+    if(pos >= 0xffffffff)
+    {
+      err = zip64local_putValue(&zi->z_filefunc,zi->filestream, (uLong)0xffffffff,4);
+    }
+    else
+                  err = zip64local_putValue(&zi->z_filefunc,zi->filestream, (uLong)(centraldir_pos_inzip - zi->add_position_when_writting_offset),4);
+  }
+
+   return err;
+}
+
+int Write_GlobalComment(zip64_internal* zi, const char* global_comment)
+{
+  int err = ZIP_OK;
+  uInt size_global_comment = 0;
+
+  if(global_comment != NULL)
+    size_global_comment = (uInt)strlen(global_comment);
+
+  err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_global_comment,2);
+
+  if (err == ZIP_OK && size_global_comment > 0)
+  {
+    if (ZWRITE64(zi->z_filefunc,zi->filestream, global_comment, size_global_comment) != size_global_comment)
+      err = ZIP_ERRNO;
+  }
+  return err;
+}
+
+extern int ZEXPORT zipClose (zipFile file, const char* global_comment)
+{
+    zip64_internal* zi;
+    int err = 0;
+    uLong size_centraldir = 0;
+    ZPOS64_T centraldir_pos_inzip;
+    ZPOS64_T pos;
+
+    if (file == NULL)
+        return ZIP_PARAMERROR;
+
+    zi = (zip64_internal*)file;
+
+    if (zi->in_opened_file_inzip == 1)
+    {
+        err = zipCloseFileInZip (file);
+    }
+
+#ifndef NO_ADDFILEINEXISTINGZIP
+    if (global_comment==NULL)
+        global_comment = zi->globalcomment;
+#endif
+
+    centraldir_pos_inzip = ZTELL64(zi->z_filefunc,zi->filestream);
+
+    if (err==ZIP_OK)
+    {
+        linkedlist_datablock_internal* ldi = zi->central_dir.first_block;
+        while (ldi!=NULL)
+        {
+            if ((err==ZIP_OK) && (ldi->filled_in_this_block>0))
+            {
+                if (ZWRITE64(zi->z_filefunc,zi->filestream, ldi->data, ldi->filled_in_this_block) != ldi->filled_in_this_block)
+                    err = ZIP_ERRNO;
+            }
+
+            size_centraldir += ldi->filled_in_this_block;
+            ldi = ldi->next_datablock;
+        }
+    }
+    free_linkedlist(&(zi->central_dir));
+
+    pos = centraldir_pos_inzip - zi->add_position_when_writting_offset;
+    if(pos >= 0xffffffff || zi->number_entry > 0xFFFF)
+    {
+      ZPOS64_T Zip64EOCDpos = ZTELL64(zi->z_filefunc,zi->filestream);
+      Write_Zip64EndOfCentralDirectoryRecord(zi, size_centraldir, centraldir_pos_inzip);
+
+      Write_Zip64EndOfCentralDirectoryLocator(zi, Zip64EOCDpos);
+    }
+
+    if (err==ZIP_OK)
+      err = Write_EndOfCentralDirectoryRecord(zi, size_centraldir, centraldir_pos_inzip);
+
+    if(err == ZIP_OK)
+      err = Write_GlobalComment(zi, global_comment);
+
+    if ((zi->flags & ZIP_AUTO_CLOSE) != 0) {
+        if (ZCLOSE64(zi->z_filefunc,zi->filestream) != 0) {
+            if (err == ZIP_OK)
+                err = ZIP_ERRNO;
+        }
+    } else {
+        if (ZFAKECLOSE64(zi->z_filefunc,zi->filestream) != 0) {
+            if (err == ZIP_OK)
+                err = ZIP_ERRNO;
+        }
+    }
+
+#ifndef NO_ADDFILEINEXISTINGZIP
+    TRYFREE(zi->globalcomment);
+#endif
+    TRYFREE(zi);
+
+    return err;
+}
+
+extern int ZEXPORT zipRemoveExtraInfoBlock (char* pData, int* dataLen, short sHeader)
+{
+  char* p = pData;
+  int size = 0;
+  char* pNewHeader;
+  char* pTmp;
+  short header;
+  short dataSize;
+
+  int retVal = ZIP_OK;
+
+  if(pData == NULL || *dataLen < 4)
+    return ZIP_PARAMERROR;
+
+  pNewHeader = (char*)ALLOC(*dataLen);
+  if(!pNewHeader) {
+    return Z_MEM_ERROR;
+  }
+  pTmp = pNewHeader;
+
+  while(p < (pData + *dataLen))
+  {
+    header = *(short*)p;
+    dataSize = *(((short*)p)+1);
+
+    if( header == sHeader ) /* Header found. */
+    {
+      p += dataSize + 4; /* skip it. do not copy to temp buffer */
+    }
+    else
+    {
+      /* Extra Info block should not be removed, So copy it to the temp buffer. */
+      memcpy(pTmp, p, dataSize + 4);
+      p += dataSize + 4;
+      size += dataSize + 4;
+    }
+
+  }
+
+  if(size < *dataLen)
+  {
+    /* clean old extra info block. */
+    memset(pData,0, *dataLen);
+
+    /* copy the new extra info block over the old */
+    if(size > 0)
+      memcpy(pData, pNewHeader, size);
+
+    /* set the new extra info size */
+    *dataLen = size;
+
+    retVal = ZIP_OK;
+  }
+  else
+    retVal = ZIP_ERRNO;
+
+  TRYFREE(pNewHeader);
+
+  return retVal;
+}
+
+int ZEXPORT zipSetFlags(zipFile file, unsigned flags)
+{
+    zip64_internal* zi;
+    if (file == NULL)
+        return ZIP_PARAMERROR;
+    zi = (zip64_internal*)file;
+    zi->flags |= flags;
+    // If the output is non-seekable, the data descriptor is needed.
+    if ((zi->flags & ZIP_SEQUENTIAL) != 0) {
+        zi->flags |= ZIP_WRITE_DATA_DESCRIPTOR;
+    }
+    return ZIP_OK;
+}
+
+int ZEXPORT zipClearFlags(zipFile file, unsigned flags)
+{
+    zip64_internal* zi;
+    if (file == NULL)
+        return ZIP_PARAMERROR;
+    zi = (zip64_internal*)file;
+    zi->flags &= ~flags;
+    // If the data descriptor is not written, we can't use a non-seekable output.
+    if ((zi->flags & ZIP_WRITE_DATA_DESCRIPTOR) == 0) {
+        zi->flags &= ~ZIP_SEQUENTIAL;
+    }
+    return ZIP_OK;
+}
diff -ruN ./zip.h ../../dep/quazip/quazip/zip.h
--- ./zip.h	2020-11-27 04:16:54.992498165 +0200
+++ ../../dep/quazip/quazip/zip.h	2020-11-27 04:08:04.065851277 +0200
@@ -1,245 +1,391 @@
-/* zip.h -- IO for compress .zip files using zlib
-   Version 1.01e, February 12th, 2005
-
-   Copyright (C) 1998-2005 Gilles Vollant
-
-   This unzip package allow creates .ZIP file, compatible with PKZip 2.04g
-     WinZip, InfoZip tools and compatible.
-   Multi volume ZipFile (span) are not supported.
-   Encryption compatible with pkzip 2.04g only supported
-   Old compressions used by old PKZip 1.x are not supported
-
-  For uncompress .zip file, look at unzip.h
-
-
-   I WAIT FEEDBACK at mail info@winimage.com
-   Visit also http://www.winimage.com/zLibDll/unzip.html for evolution
-
-   Condition of use and distribution are the same than zlib :
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-   Modified by Sergey A. Tachenov to integrate with Qt.
-
-
-*/
-
-/* for more info about .ZIP format, see
-      http://www.info-zip.org/pub/infozip/doc/appnote-981119-iz.zip
-      http://www.info-zip.org/pub/infozip/doc/
-   PkWare has also a specification at :
-      ftp://ftp.pkware.com/probdesc.zip
-*/
-
-#ifndef _zip_H
-#define _zip_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#ifndef _ZLIB_H
-#include "zlib.h"
-#endif
-
-#ifndef _ZLIBIOAPI_H
-#include "ioapi.h"
-#endif
-
-#if defined(STRICTZIP) || defined(STRICTZIPUNZIP)
-/* like the STRICT of WIN32, we define a pointer that cannot be converted
-    from (void*) without cast */
-typedef struct TagzipFile__ { int unused; } zipFile__;
-typedef zipFile__ *zipFile;
-#else
-typedef voidp zipFile;
-#endif
-
-#define ZIP_OK                          (0)
-#define ZIP_EOF                         (0)
-#define ZIP_ERRNO                       (Z_ERRNO)
-#define ZIP_PARAMERROR                  (-102)
-#define ZIP_BADZIPFILE                  (-103)
-#define ZIP_INTERNALERROR               (-104)
-
-#define ZIP_WRITE_DATA_DESCRIPTOR 0x8u
-
-#ifndef DEF_MEM_LEVEL
-#  if MAX_MEM_LEVEL >= 8
-#    define DEF_MEM_LEVEL 8
-#  else
-#    define DEF_MEM_LEVEL  MAX_MEM_LEVEL
-#  endif
-#endif
-/* default memLevel */
-
-/* tm_zip contain date/time info */
-typedef struct tm_zip_s
-{
-    uInt tm_sec;            /* seconds after the minute - [0,59] */
-    uInt tm_min;            /* minutes after the hour - [0,59] */
-    uInt tm_hour;           /* hours since midnight - [0,23] */
-    uInt tm_mday;           /* day of the month - [1,31] */
-    uInt tm_mon;            /* months since January - [0,11] */
-    uInt tm_year;           /* years - [1980..2044] */
-} tm_zip;
-
-typedef struct
-{
-    tm_zip      tmz_date;       /* date in understandable format           */
-    uLong       dosDate;       /* if dos_date == 0, tmu_date is used      */
-/*    uLong       flag;        */   /* general purpose bit flag        2 bytes */
-
-    uLong       internal_fa;    /* internal file attributes        2 bytes */
-    uLong       external_fa;    /* external file attributes        4 bytes */
-} zip_fileinfo;
-
-typedef const char* zipcharpc;
-
-
-#define APPEND_STATUS_CREATE        (0)
-#define APPEND_STATUS_CREATEAFTER   (1)
-#define APPEND_STATUS_ADDINZIP      (2)
-
-extern zipFile ZEXPORT zipOpen OF((voidpf file, int append));
-/*
-  Create a zipfile.
-     file is whatever the IO API accepts. For Qt IO API it's a pointer to
-       QIODevice. For fopen() IO API it's a file name (const char*).
-     if the file pathname exist and append==APPEND_STATUS_CREATEAFTER, the zip
-       will be created at the end of the file.
-         (useful if the file contain a self extractor code)
-     if the file pathname exist and append==APPEND_STATUS_ADDINZIP, we will
-       add files in existing zip (be sure you don't add file that doesn't exist)
-     If the zipfile cannot be opened, the return value is NULL.
-     Else, the return value is a zipFile Handle, usable with other function
-       of this zip package.
-*/
-
-/* Note : there is no delete function into a zipfile.
-   If you want delete file into a zipfile, you must open a zipfile, and create another
-   Of couse, you can use RAW reading and writing to copy the file you did not want delte
-*/
-
-extern zipFile ZEXPORT zipOpen2 OF((voidpf file,
-                                   int append,
-                                   zipcharpc* globalcomment,
-                                   zlib_filefunc_def* pzlib_filefunc_def));
-
-extern int ZEXPORT zipOpenNewFileInZip OF((zipFile file,
-                       const char* filename,
-                       const zip_fileinfo* zipfi,
-                       const void* extrafield_local,
-                       uInt size_extrafield_local,
-                       const void* extrafield_global,
-                       uInt size_extrafield_global,
-                       const char* comment,
-                       int method,
-                       int level));
-/*
-  Open a file in the ZIP for writing.
-  filename : the filename in zip (if NULL, '-' without quote will be used
-  *zipfi contain supplemental information
-  if extrafield_local!=NULL and size_extrafield_local>0, extrafield_local
-    contains the extrafield data the the local header
-  if extrafield_global!=NULL and size_extrafield_global>0, extrafield_global
-    contains the extrafield data the the local header
-  if comment != NULL, comment contain the comment string
-  method contain the compression method (0 for store, Z_DEFLATED for deflate)
-  level contain the level of compression (can be Z_DEFAULT_COMPRESSION)
-*/
-
-
-extern int ZEXPORT zipOpenNewFileInZip2 OF((zipFile file,
-                                            const char* filename,
-                                            const zip_fileinfo* zipfi,
-                                            const void* extrafield_local,
-                                            uInt size_extrafield_local,
-                                            const void* extrafield_global,
-                                            uInt size_extrafield_global,
-                                            const char* comment,
-                                            int method,
-                                            int level,
-                                            int raw));
-
-/*
-  Same than zipOpenNewFileInZip, except if raw=1, we write raw file
- */
-
-extern int ZEXPORT zipOpenNewFileInZip3 OF((zipFile file,
-                                            const char* filename,
-                                            const zip_fileinfo* zipfi,
-                                            const void* extrafield_local,
-                                            uInt size_extrafield_local,
-                                            const void* extrafield_global,
-                                            uInt size_extrafield_global,
-                                            const char* comment,
-                                            int method,
-                                            int level,
-                                            int raw,
-                                            int windowBits,
-                                            int memLevel,
-                                            int strategy,
-                                            const char* password,
-                                            uLong crcForCtypting));
-
-/*
-  Same than zipOpenNewFileInZip2, except
-    windowBits,memLevel,,strategy : see parameter strategy in deflateInit2
-    password : crypting password (NULL for no crypting)
-    crcForCtypting : crc of file to compress (needed for crypting)
- */
-
-
-extern int ZEXPORT zipWriteInFileInZip OF((zipFile file,
-                       const void* buf,
-                       unsigned len));
-/*
-  Write data in the zipfile
-*/
-
-extern int ZEXPORT zipCloseFileInZip OF((zipFile file));
-/*
-  Close the current file in the zipfile
-*/
-
-extern int ZEXPORT zipCloseFileInZipRaw OF((zipFile file,
-                                            uLong uncompressed_size,
-                                            uLong crc32));
-/*
-  Close the current file in the zipfile, for fiel opened with
-    parameter raw=1 in zipOpenNewFileInZip2
-  uncompressed_size and crc32 are value for the uncompressed size
-*/
-
-extern int ZEXPORT zipClose OF((zipFile file,
-                const char* global_comment));
-/*
-  Close the zipfile
-*/
-
-/*
-   Added by Sergey A. Tachenov to tweak zipping behaviour.
-   */
-extern int ZEXPORT zipSetFlags(zipFile file, unsigned flags);
-extern int ZEXPORT zipClearFlags(zipFile file, unsigned flags);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _zip_H */
+/* zip.h -- IO on .zip files using zlib
+   Version 1.1, February 14h, 2010
+   part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )
+
+         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )
+
+         Modifications for Zip64 support
+         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )
+
+         For more info read MiniZip_info.txt
+
+         ---------------------------------------------------------------------------
+
+   Condition of use and distribution are the same than zlib :
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+
+        ---------------------------------------------------------------------------
+
+        Changes
+
+        See header of zip.h
+
+        ---------------------------------------------------------------------------
+
+  As per the requirement above, this file is plainly marked as modified
+  by Sergey A. Tachenov. Most modifications include the I/O API redesign
+  to support QIODevice interface. Some improvements and small fixes were also made.
+
+*/
+
+#ifndef _zip12_H
+#define _zip12_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+//#define HAVE_BZIP2
+
+#ifndef _ZLIB_H
+#include <zlib.h>
+#endif
+
+#ifndef _ZLIBIOAPI_H
+#include "ioapi.h"
+#endif
+
+#ifdef HAVE_BZIP2
+#include "bzlib.h"
+#endif
+
+#define Z_BZIP2ED 12
+
+#if defined(STRICTZIP) || defined(STRICTZIPUNZIP)
+/* like the STRICT of WIN32, we define a pointer that cannot be converted
+    from (void*) without cast */
+typedef struct TagzipFile__ { int unused; } zipFile__;
+typedef zipFile__ *zipFile;
+#else
+typedef voidp zipFile;
+#endif
+
+#define ZIP_OK                          (0)
+#define ZIP_EOF                         (0)
+#define ZIP_ERRNO                       (Z_ERRNO)
+#define ZIP_PARAMERROR                  (-102)
+#define ZIP_BADZIPFILE                  (-103)
+#define ZIP_INTERNALERROR               (-104)
+
+#define ZIP_WRITE_DATA_DESCRIPTOR 0x8u
+#define ZIP_AUTO_CLOSE 0x1u
+#define ZIP_SEQUENTIAL 0x2u
+#define ZIP_ENCODING_UTF8 0x0800u
+#define ZIP_DEFAULT_FLAGS (ZIP_AUTO_CLOSE | ZIP_WRITE_DATA_DESCRIPTOR)
+
+#ifndef DEF_MEM_LEVEL
+#  if MAX_MEM_LEVEL >= 8
+#    define DEF_MEM_LEVEL 8
+#  else
+#    define DEF_MEM_LEVEL  MAX_MEM_LEVEL
+#  endif
+#endif
+/* default memLevel */
+
+/* tm_zip contain date/time info */
+typedef struct tm_zip_s
+{
+    uInt tm_sec;            /* seconds after the minute - [0,59] */
+    uInt tm_min;            /* minutes after the hour - [0,59] */
+    uInt tm_hour;           /* hours since midnight - [0,23] */
+    uInt tm_mday;           /* day of the month - [1,31] */
+    uInt tm_mon;            /* months since January - [0,11] */
+    uInt tm_year;           /* years - [1980..2044] */
+} tm_zip;
+
+typedef struct
+{
+    tm_zip      tmz_date;       /* date in understandable format           */
+    uLong       dosDate;       /* if dos_date == 0, tmu_date is used      */
+/*    uLong       flag;        */   /* general purpose bit flag        2 bytes */
+
+    uLong       internal_fa;    /* internal file attributes        2 bytes */
+    uLong       external_fa;    /* external file attributes        4 bytes */
+} zip_fileinfo;
+
+typedef const char* zipcharpc;
+
+
+#define APPEND_STATUS_CREATE        (0)
+#define APPEND_STATUS_CREATEAFTER   (1)
+#define APPEND_STATUS_ADDINZIP      (2)
+
+extern zipFile ZEXPORT zipOpen OF((voidpf file, int append));
+extern zipFile ZEXPORT zipOpen64 OF((voidpf file, int append));
+/*
+  Create a zipfile.
+     the file argument depends on the API used, for QuaZip it's a QIODevice
+       pointer.
+     if the file pathname exist and append==APPEND_STATUS_CREATEAFTER, the zip
+       will be created at the end of the file.
+         (useful if the file contain a self extractor code)
+     if the file pathname exist and append==APPEND_STATUS_ADDINZIP, we will
+       add files in existing zip (be sure you don't add file that doesn't exist)
+     If the zipfile cannot be opened, the return value is NULL.
+     Else, the return value is a zipFile Handle, usable with other function
+       of this zip package.
+*/
+
+/* Note : there is no delete function into a zipfile.
+   If you want delete file into a zipfile, you must open a zipfile, and create another
+   Of couse, you can use RAW reading and writing to copy the file you did not want delte
+*/
+
+extern zipFile ZEXPORT zipOpen2 OF((voidpf file,
+                                   int append,
+                                   zipcharpc* globalcomment,
+                                   zlib_filefunc_def* pzlib_filefunc_def));
+
+extern zipFile ZEXPORT zipOpen2_64 OF((voidpf file,
+                                   int append,
+                                   zipcharpc* globalcomment,
+                                   zlib_filefunc64_def* pzlib_filefunc_def));
+
+/*
+ * Exported by Sergey A. Tachenov to suit the needs of QuaZip.
+ * Note that this function MAY change signature in order to
+ * provide new QuaZip features. You have been warned!
+ * */
+extern zipFile ZEXPORT zipOpen3 (voidpf file,
+                                 int append,
+                                 zipcharpc* globalcomment,
+                                 zlib_filefunc64_32_def* pzlib_filefunc64_32_def,
+                                 unsigned flags);
+
+extern int ZEXPORT zipOpenNewFileInZip OF((zipFile file,
+                       const char* filename,
+                       const zip_fileinfo* zipfi,
+                       const void* extrafield_local,
+                       uInt size_extrafield_local,
+                       const void* extrafield_global,
+                       uInt size_extrafield_global,
+                       const char* comment,
+                       int method,
+                       int level));
+
+extern int ZEXPORT zipOpenNewFileInZip64 OF((zipFile file,
+                       const char* filename,
+                       const zip_fileinfo* zipfi,
+                       const void* extrafield_local,
+                       uInt size_extrafield_local,
+                       const void* extrafield_global,
+                       uInt size_extrafield_global,
+                       const char* comment,
+                       int method,
+                       int level,
+                       int zip64));
+
+/*
+  Open a file in the ZIP for writing.
+  filename : the filename in zip (if NULL, '-' without quote will be used
+  *zipfi contain supplemental information
+  if extrafield_local!=NULL and size_extrafield_local>0, extrafield_local
+    contains the extrafield data the the local header
+  if extrafield_global!=NULL and size_extrafield_global>0, extrafield_global
+    contains the extrafield data the the local header
+  if comment != NULL, comment contain the comment string
+  method contain the compression method (0 for store, Z_DEFLATED for deflate)
+  level contain the level of compression (can be Z_DEFAULT_COMPRESSION)
+  zip64 is set to 1 if a zip64 extended information block should be added to the local file header.
+                    this MUST be '1' if the uncompressed size is >= 0xffffffff.
+
+*/
+
+
+extern int ZEXPORT zipOpenNewFileInZip2 OF((zipFile file,
+                                            const char* filename,
+                                            const zip_fileinfo* zipfi,
+                                            const void* extrafield_local,
+                                            uInt size_extrafield_local,
+                                            const void* extrafield_global,
+                                            uInt size_extrafield_global,
+                                            const char* comment,
+                                            int method,
+                                            int level,
+                                            int raw));
+
+
+extern int ZEXPORT zipOpenNewFileInZip2_64 OF((zipFile file,
+                                            const char* filename,
+                                            const zip_fileinfo* zipfi,
+                                            const void* extrafield_local,
+                                            uInt size_extrafield_local,
+                                            const void* extrafield_global,
+                                            uInt size_extrafield_global,
+                                            const char* comment,
+                                            int method,
+                                            int level,
+                                            int raw,
+                                            int zip64));
+/*
+  Same than zipOpenNewFileInZip, except if raw=1, we write raw file
+ */
+
+extern int ZEXPORT zipOpenNewFileInZip3 OF((zipFile file,
+                                            const char* filename,
+                                            const zip_fileinfo* zipfi,
+                                            const void* extrafield_local,
+                                            uInt size_extrafield_local,
+                                            const void* extrafield_global,
+                                            uInt size_extrafield_global,
+                                            const char* comment,
+                                            int method,
+                                            int level,
+                                            int raw,
+                                            int windowBits,
+                                            int memLevel,
+                                            int strategy,
+                                            const char* password,
+                                            uLong crcForCrypting));
+
+extern int ZEXPORT zipOpenNewFileInZip3_64 OF((zipFile file,
+                                            const char* filename,
+                                            const zip_fileinfo* zipfi,
+                                            const void* extrafield_local,
+                                            uInt size_extrafield_local,
+                                            const void* extrafield_global,
+                                            uInt size_extrafield_global,
+                                            const char* comment,
+                                            int method,
+                                            int level,
+                                            int raw,
+                                            int windowBits,
+                                            int memLevel,
+                                            int strategy,
+                                            const char* password,
+                                            uLong crcForCrypting,
+                                            int zip64
+                                            ));
+
+/*
+  Same than zipOpenNewFileInZip2, except
+    windowBits,memLevel,,strategy : see parameter strategy in deflateInit2
+    password : crypting password (NULL for no crypting)
+    crcForCrypting : crc of file to compress (needed for crypting)
+ */
+
+extern int ZEXPORT zipOpenNewFileInZip4 OF((zipFile file,
+                                            const char* filename,
+                                            const zip_fileinfo* zipfi,
+                                            const void* extrafield_local,
+                                            uInt size_extrafield_local,
+                                            const void* extrafield_global,
+                                            uInt size_extrafield_global,
+                                            const char* comment,
+                                            int method,
+                                            int level,
+                                            int raw,
+                                            int windowBits,
+                                            int memLevel,
+                                            int strategy,
+                                            const char* password,
+                                            uLong crcForCrypting,
+                                            uLong versionMadeBy,
+                                            uLong flagBase
+                                            ));
+
+
+extern int ZEXPORT zipOpenNewFileInZip4_64 OF((zipFile file,
+                                            const char* filename,
+                                            const zip_fileinfo* zipfi,
+                                            const void* extrafield_local,
+                                            uInt size_extrafield_local,
+                                            const void* extrafield_global,
+                                            uInt size_extrafield_global,
+                                            const char* comment,
+                                            int method,
+                                            int level,
+                                            int raw,
+                                            int windowBits,
+                                            int memLevel,
+                                            int strategy,
+                                            const char* password,
+                                            uLong crcForCrypting,
+                                            uLong versionMadeBy,
+                                            uLong flagBase,
+                                            int zip64
+                                            ));
+/*
+  Same than zipOpenNewFileInZip4, except
+    versionMadeBy : value for Version made by field
+    flag : value for flag field (compression level info will be added)
+ */
+
+
+extern int ZEXPORT zipWriteInFileInZip OF((zipFile file,
+                       const void* buf,
+                       unsigned len));
+/*
+  Write data in the zipfile
+*/
+
+extern int ZEXPORT zipCloseFileInZip OF((zipFile file));
+/*
+  Close the current file in the zipfile
+*/
+
+extern int ZEXPORT zipCloseFileInZipRaw OF((zipFile file,
+                                            uLong uncompressed_size,
+                                            uLong crc32));
+
+extern int ZEXPORT zipCloseFileInZipRaw64 OF((zipFile file,
+                                            ZPOS64_T uncompressed_size,
+                                            uLong crc32));
+
+/*
+  Close the current file in the zipfile, for file opened with
+    parameter raw=1 in zipOpenNewFileInZip2
+  uncompressed_size and crc32 are value for the uncompressed size
+*/
+
+extern int ZEXPORT zipClose OF((zipFile file,
+                const char* global_comment));
+/*
+  Close the zipfile
+*/
+
+
+extern int ZEXPORT zipRemoveExtraInfoBlock OF((char* pData, int* dataLen, short sHeader));
+/*
+  zipRemoveExtraInfoBlock -  Added by Mathias Svensson
+
+  Remove extra information block from a extra information data for the local file header or central directory header
+
+  It is needed to remove ZIP64 extra information blocks when before data is written if using RAW mode.
+
+  0x0001 is the signature header for the ZIP64 extra information blocks
+
+  usage.
+                        Remove ZIP64 Extra information from a central director extra field data
+              zipRemoveExtraInfoBlock(pCenDirExtraFieldData, &nCenDirExtraFieldDataLen, 0x0001);
+
+                        Remove ZIP64 Extra information from a Local File Header extra field data
+        zipRemoveExtraInfoBlock(pLocalHeaderExtraFieldData, &nLocalHeaderExtraFieldDataLen, 0x0001);
+*/
+
+/*
+   Added by Sergey A. Tachenov to tweak zipping behaviour.
+*/
+extern int ZEXPORT zipSetFlags(zipFile file, unsigned flags);
+extern int ZEXPORT zipClearFlags(zipFile file, unsigned flags);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _zip64_H */
